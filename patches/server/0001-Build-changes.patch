From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: violetc <58360096+s-yh-china@users.noreply.github.com>
Date: Tue, 13 Sep 2022 16:58:47 +0800
Subject: [PATCH] Build changes


diff --git a/build.gradle.kts b/build.gradle.kts
index ee49dd4f80ebdfc65cbf860e62d3c80796c8af2c..ad27050a721c62ca70fdcd889a686d825477d8e5 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -13,8 +13,12 @@ configurations.named(log4jPlugins.compileClasspathConfigurationName) {
 val alsoShade: Configuration by configurations.creating
 
 dependencies {
-    implementation(project(":paper-api"))
-    implementation(project(":paper-mojangapi"))
+	implementation(project(":leaves-api")) // Leaves
+	// Leaves start
+	implementation("io.papermc.paper:paper-mojangapi:1.20.1-R0.1-SNAPSHOT") {
+		exclude("io.papermc.paper", "paper-api")
+	}
+	// Leaves end
     // Paper start
     implementation("org.jline:jline-terminal-jansi:3.21.0")
     implementation("net.minecrell:terminalconsoleappender:1.3.0")
@@ -60,19 +64,30 @@ dependencies {
 }
 
 val craftbukkitPackageVersion = "1_20_R1" // Paper
+
+// Leaves start - hide irrelevant compilation warnings
+tasks.withType<JavaCompile> {
+    val compilerArgs = options.compilerArgs
+    compilerArgs.add("-Xlint:-module")
+    compilerArgs.add("-Xlint:-removal")
+    compilerArgs.add("-Xlint:-dep-ann")
+    compilerArgs.add("--add-modules=jdk.incubator.vector") // Leaves - SIMD support
+}
+// Leaves end - hide irrelevant compilation warnings
+
 tasks.jar {
     archiveClassifier.set("dev")
 
     manifest {
         val git = Git(rootProject.layout.projectDirectory.path)
         val gitHash = git("rev-parse", "--short=7", "HEAD").getText().trim()
-        val implementationVersion = System.getenv("BUILD_NUMBER") ?: "\"$gitHash\""
+        val implementationVersion = /* System.getenv("BUILD_NUMBER") ?: */ "\"$gitHash\"" // Leaves we dont have CI
         val date = git("show", "-s", "--format=%ci", gitHash).getText().trim() // Paper
         val gitBranch = git("rev-parse", "--abbrev-ref", "HEAD").getText().trim() // Paper
         attributes(
             "Main-Class" to "org.bukkit.craftbukkit.Main",
             "Implementation-Title" to "CraftBukkit",
-            "Implementation-Version" to "git-Paper-$implementationVersion",
+            "Implementation-Version" to "git-Leaves-$implementationVersion",
             "Implementation-Vendor" to date, // Paper
             "Specification-Title" to "Bukkit",
             "Specification-Version" to project.version,
@@ -149,7 +164,7 @@ fun TaskContainer.registerRunTask(
     name: String,
     block: JavaExec.() -> Unit
 ): TaskProvider<JavaExec> = register<JavaExec>(name) {
-    group = "paper"
+    group = "paperweight"
     mainClass.set("org.bukkit.craftbukkit.Main")
     standardInput = System.`in`
     workingDir = rootProject.layout.projectDirectory
@@ -174,6 +189,8 @@ fun TaskContainer.registerRunTask(
     minHeapSize = "${memoryGb}G"
     maxHeapSize = "${memoryGb}G"
 
+    jvmArgs("--add-modules=jdk.incubator.vector") // Leaves - SIMD support
+
     doFirst {
         workingDir.mkdirs()
     }
diff --git a/src/main/java/co/aikar/timings/TimingsExport.java b/src/main/java/co/aikar/timings/TimingsExport.java
index a2f71a6d1a9e98133dff6cd0f625da9435a8af14..45897b81a822b9523c16658ca46a507729f8d0d3 100644
--- a/src/main/java/co/aikar/timings/TimingsExport.java
+++ b/src/main/java/co/aikar/timings/TimingsExport.java
@@ -242,7 +242,8 @@ public class TimingsExport extends Thread {
         parent.put("config", createObject(
             pair("spigot", mapAsJSON(Bukkit.spigot().getSpigotConfig(), null)),
             pair("bukkit", mapAsJSON(Bukkit.spigot().getBukkitConfig(), null)),
-            pair("paper", mapAsJSON(Bukkit.spigot().getPaperConfig(), null))
+            pair("paper", mapAsJSON(Bukkit.spigot().getPaperConfig(), null)), // Leaves - add config to timings report
+			pair("leaves", mapAsJSON(Bukkit.spigot().getLeavesConfig(), null)) // Leaves - add config to timings report
         ));
 
         new TimingsExport(listeners, parent, history).start();
diff --git a/src/main/java/com/destroystokyo/paper/Metrics.java b/src/main/java/com/destroystokyo/paper/Metrics.java
index 4b002e8b75d117b726b0de274a76d3596fce015b..9ce4d3d96d2d5fbde1f0af599209c6c55038fb58 100644
--- a/src/main/java/com/destroystokyo/paper/Metrics.java
+++ b/src/main/java/com/destroystokyo/paper/Metrics.java
@@ -593,7 +593,8 @@ public class Metrics {
             boolean logFailedRequests = config.getBoolean("logFailedRequests", false);
             // Only start Metrics, if it's enabled in the config
             if (config.getBoolean("enabled", true)) {
-                Metrics metrics = new Metrics("Paper", serverUUID, logFailedRequests, Bukkit.getLogger());
+                // Leaves start - we have our own bstats page
+                Metrics metrics = new Metrics("Leaves", serverUUID, logFailedRequests, Bukkit.getLogger());
 
                 metrics.addCustomChart(new Metrics.SimplePie("minecraft_version", () -> {
                     String minecraftVersion = Bukkit.getVersion();
@@ -601,17 +602,21 @@ public class Metrics {
                     return minecraftVersion;
                 }));
 
+                metrics.addCustomChart(new Metrics.SimplePie("leaves_version", () -> {
+                    String serverVersion = Bukkit.getVersion();
+                    if (!serverVersion.startsWith("null")) {
+                        String gitHash = serverVersion.substring("git-Leaves-".length()).split("[-\\s]")[0].replaceAll("\"", "");
+                        return "git-Leaves-" + Bukkit.getMinecraftVersion() + "-" + gitHash;
+                    }
+                    return "unknown";
+                }));
+
+                if (top.leavesmc.leaves.LeavesConfig.bstatsPrivacyMode) {
+                    return;
+                }
+
                 metrics.addCustomChart(new Metrics.SingleLineChart("players", () -> Bukkit.getOnlinePlayers().size()));
                 metrics.addCustomChart(new Metrics.SimplePie("online_mode", () -> Bukkit.getOnlineMode() ? "online" : "offline"));
-                final String paperVersion;
-                final String implVersion = org.bukkit.craftbukkit.Main.class.getPackage().getImplementationVersion();
-                if (implVersion != null) {
-                    final String buildOrHash = implVersion.substring(implVersion.lastIndexOf('-') + 1);
-                    paperVersion = "git-Paper-%s-%s".formatted(Bukkit.getServer().getMinecraftVersion(), buildOrHash);
-                } else {
-                    paperVersion = "unknown";
-                }
-                metrics.addCustomChart(new Metrics.SimplePie("paper_version", () -> paperVersion));
 
                 metrics.addCustomChart(new Metrics.DrilldownPie("java_version", () -> {
                     Map<String, Map<String, Integer>> map = new HashMap<>();
@@ -643,41 +648,8 @@ public class Metrics {
 
                     return map;
                 }));
-
-                metrics.addCustomChart(new Metrics.DrilldownPie("legacy_plugins", () -> {
-                    Map<String, Map<String, Integer>> map = new HashMap<>();
-
-                    // count legacy plugins
-                    int legacy = 0;
-                    for (Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
-                        if (CraftMagicNumbers.isLegacy(plugin.getDescription())) {
-                            legacy++;
-                        }
-                    }
-
-                    // insert real value as lower dimension
-                    Map<String, Integer> entry = new HashMap<>();
-                    entry.put(String.valueOf(legacy), 1);
-
-                    // create buckets as higher dimension
-                    if (legacy == 0) {
-                        map.put("0 \uD83D\uDE0E", entry); // :sunglasses:
-                    } else if (legacy <= 5) {
-                        map.put("1-5", entry);
-                    } else if (legacy <= 10) {
-                        map.put("6-10", entry);
-                    } else if (legacy <= 25) {
-                        map.put("11-25", entry);
-                    } else if (legacy <= 50) {
-                        map.put("26-50", entry);
-                    } else {
-                        map.put("50+ \uD83D\uDE2D", entry); // :cry:
-                    }
-
-                    return map;
-                }));
+                // Leaves end - we have our own bstats page
             }
-
         }
     }
 }
diff --git a/src/main/java/com/destroystokyo/paper/PaperVersionFetcher.java b/src/main/java/com/destroystokyo/paper/PaperVersionFetcher.java
index 9d687da5bdf398bb3f6c84cdf1249a7213d09f2e..658f32456530cf8f291851da2789c8c3c3de6d27 100644
--- a/src/main/java/com/destroystokyo/paper/PaperVersionFetcher.java
+++ b/src/main/java/com/destroystokyo/paper/PaperVersionFetcher.java
@@ -20,7 +20,7 @@ import java.util.stream.StreamSupport;
 public class PaperVersionFetcher implements VersionFetcher {
     private static final java.util.regex.Pattern VER_PATTERN = java.util.regex.Pattern.compile("^([0-9\\.]*)\\-.*R"); // R is an anchor, will always give '-R' at end
     private static final String GITHUB_BRANCH_NAME = "master";
-    private static final String DOWNLOAD_PAGE = "https://papermc.io/downloads/paper";
+    private static final String DOWNLOAD_PAGE = "https://leavesmc.top/downloads/leaves"; // Leaves - change
     private static @Nullable String mcVer;
 
     @Override
@@ -31,8 +31,10 @@ public class PaperVersionFetcher implements VersionFetcher {
     @Nonnull
     @Override
     public Component getVersionMessage(@Nonnull String serverVersion) {
-        String[] parts = serverVersion.substring("git-Paper-".length()).split("[-\\s]");
-        final Component updateMessage = getUpdateStatusMessage("PaperMC/Paper", GITHUB_BRANCH_NAME, parts[0]);
+        // Leaves start - we dont have jenkins setup
+        String[] parts = serverVersion.substring("git-Leaves-".length()).split("[-\\s]");
+        final Component updateMessage = getUpdateStatusMessage("LeavesMC/Leaves", GITHUB_BRANCH_NAME, parts[0]);
+        // Leaves end - we dont have jenkins setup
         final Component history = getHistory();
 
         return history != null ? TextComponent.ofChildren(updateMessage, Component.newline(), history) : updateMessage;
@@ -56,14 +58,12 @@ public class PaperVersionFetcher implements VersionFetcher {
 
     private static Component getUpdateStatusMessage(@Nonnull String repo, @Nonnull String branch, @Nonnull String versionInfo) {
         int distance;
-        try {
-            int jenkinsBuild = Integer.parseInt(versionInfo);
-            distance = fetchDistanceFromSiteApi(jenkinsBuild, getMinecraftVersion());
-        } catch (NumberFormatException ignored) {
-            versionInfo = versionInfo.replace("\"", "");
-            distance = fetchDistanceFromGitHub(repo, branch, versionInfo);
-        }
 
+		// Leaves start - we dont have jenkins setup
+        versionInfo = versionInfo.replace("\"", "");
+        distance = fetchDistanceFromGitHub(repo, branch, versionInfo);
+		// Leaves end - we dont have jenkins setup
+       
         switch (distance) {
             case -1:
                 return Component.text("Error obtaining version information", NamedTextColor.YELLOW);
@@ -73,11 +73,12 @@ public class PaperVersionFetcher implements VersionFetcher {
                 return Component.text("Unknown version", NamedTextColor.YELLOW);
             default:
                 return Component.text("You are " + distance + " version(s) behind", NamedTextColor.YELLOW)
-                        .append(Component.newline())
-                        .append(Component.text("Download the new version at: ")
-                                .append(Component.text(DOWNLOAD_PAGE, NamedTextColor.GOLD)
-                                        .hoverEvent(Component.text("Click to open", NamedTextColor.WHITE))
-                                        .clickEvent(ClickEvent.openUrl(DOWNLOAD_PAGE))));
+                    .append(Component.newline())
+                    .append(Component.text("Download the new version at: ")
+                        .append(Component.text(DOWNLOAD_PAGE, NamedTextColor.GOLD)
+                            .hoverEvent(Component.text("Click to open", NamedTextColor.WHITE))
+                            .clickEvent(ClickEvent.openUrl(DOWNLOAD_PAGE))));
+
         }
     }
 
diff --git a/src/main/java/com/destroystokyo/paper/profile/PaperAuthenticationService.java b/src/main/java/com/destroystokyo/paper/profile/PaperAuthenticationService.java
index 1459a1f99fe614d072a087cda18788cf13102645..73bfda834fa704b208a5dd9271bb397a9f8b5983 100644
--- a/src/main/java/com/destroystokyo/paper/profile/PaperAuthenticationService.java
+++ b/src/main/java/com/destroystokyo/paper/profile/PaperAuthenticationService.java
@@ -8,7 +8,7 @@ import com.mojang.authlib.yggdrasil.YggdrasilEnvironment;
 import java.net.Proxy;
 
 public class PaperAuthenticationService extends YggdrasilAuthenticationService {
-    private final Environment environment;
+    protected final Environment environment; // Leaves - private -> protected
     public PaperAuthenticationService(Proxy proxy) {
         super(proxy);
         this.environment = EnvironmentParser.getEnvironmentFromProperties().orElse(YggdrasilEnvironment.PROD.getEnvironment());
diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
index 0133ea6feb1ab88f021f66855669f58367e7420b..d5e5463e3054cc06bd6589a864ff2003b1dfb9e3 100644
--- a/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
@@ -5,6 +5,7 @@ import net.minecraft.world.entity.Entity;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
+import top.leavesmc.leaves.util.ArrayConstants;
 
 // list with O(1) remove & contains
 /**
@@ -17,9 +18,7 @@ public final class EntityList implements Iterable<Entity> {
         this.entityToIndex.defaultReturnValue(Integer.MIN_VALUE);
     }
 
-    protected static final Entity[] EMPTY_LIST = new Entity[0];
-
-    protected Entity[] entities = EMPTY_LIST;
+    protected Entity[] entities = ArrayConstants.emptyEntityArray; // Leaves - reduce array allocations
     protected int count;
 
     public int size() {
diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java b/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java
index 277cfd9d1e8fff5d9b5e534b75c3c5162d58b0b7..19d5f3e167d7c94d33fcedc6c787d86ad5fee770 100644
--- a/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java
@@ -6,6 +6,7 @@ import java.util.Arrays;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.GlobalPalette;
+import top.leavesmc.leaves.util.ArrayConstants;
 
 /**
  * @author Spottedleaf
@@ -20,9 +21,7 @@ public final class IBlockDataList {
         this.map.defaultReturnValue(Long.MAX_VALUE);
     }
 
-    private static final long[] EMPTY_LIST = new long[0];
-
-    private long[] byIndex = EMPTY_LIST;
+    private long[] byIndex = ArrayConstants.emptyLongArray; // Leaves - reduce array allocations
     private int size;
 
     public static int getLocationKey(final int x, final int y, final int z) {
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
index 41b9405d6759d865e0d14dd4f95163e9690e967d..67008112e1d1c059938838c544f093fa1f0a4fee 100644
--- a/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
+++ b/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
@@ -26,7 +26,7 @@ public abstract class AreaMap<E> {
 
     // we use linked for better iteration.
     // map of: coordinate to set of objects in coordinate
-    protected final Long2ObjectOpenHashMap<PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E>> areaMap = new Long2ObjectOpenHashMap<>(1024, 0.7f);
+    protected Long2ObjectOpenHashMap<PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E>> areaMap = new Long2ObjectOpenHashMap<>(1024, 0.7f); // Leaves - not final
     protected final PooledLinkedHashSets<E> pooledHashSets;
 
     protected final ChangeCallback<E> addCallback;
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java
index 46954db7ecd35ac4018fdf476df7c8020d7ce6c8..044c51ebb058fc36074fd178929e3279335f6c99 100644
--- a/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java
+++ b/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java
@@ -5,7 +5,7 @@ import net.minecraft.server.level.ServerPlayer;
 /**
  * @author Spottedleaf
  */
-public final class PlayerAreaMap extends AreaMap<ServerPlayer> {
+public class PlayerAreaMap extends AreaMap<ServerPlayer> { // Leaves - not final
 
     public PlayerAreaMap() {
         super();
diff --git a/src/main/java/io/papermc/paper/adventure/ChatProcessor.java b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
index 774fb97912f766589f3548f659618ad554e0503f..c5678071366c39ae642c8c1a638e3d4de297c26f 100644
--- a/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
+++ b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
@@ -353,7 +353,7 @@ public final class ChatProcessor {
 
         private void sendToServer(final ChatType.Bound chatType, final @Nullable Function<Audience, net.minecraft.network.chat.Component> msgFunction) {
             final PlayerChatMessage toConsoleMessage = msgFunction == null ? ChatProcessor.this.message : ChatProcessor.this.message.withUnsignedContent(msgFunction.apply(ChatProcessor.this.server.console));
-            ChatProcessor.this.server.logChatMessage(toConsoleMessage.decoratedContent(), chatType, ChatProcessor.this.server.getPlayerList().verifyChatTrusted(toConsoleMessage) ? null : "Not Secure");
+            ChatProcessor.this.server.logChatMessage(toConsoleMessage.decoratedContent(), chatType, ChatProcessor.this.server.getPlayerList().verifyChatTrusted(toConsoleMessage) || top.leavesmc.leaves.LeavesConfig.noChatSign ? null : "Not Secure"); // Leaves - No Not Secure
         }
     }
 
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
index abd0217cf0bff183c8e262edc173a53403797c1a..f2659e1973e7ef5c5b64ba0bf3b27e5da1f53905 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
@@ -607,7 +607,7 @@ public final class ChunkHolderManager {
                 // Delay unload chunk patch originally by Aikar, updated to 1.20 by jpenilla
                 // these days, the patch is mostly useful to keep chunks ticking when players teleport
                 // so that their pets can teleport with them as well.
-                final long delayTimeout = this.world.paperConfig().chunks.delayChunkUnloadsBy.ticks();
+                final long delayTimeout = top.leavesmc.leaves.LeavesConfig.mcTechnicalMode ? 0 : this.world.paperConfig().chunks.delayChunkUnloadsBy.ticks(); // Leaves - mc technical survival mode
                 final TicketType<ChunkPos> toAdd;
                 final long timeout;
                 if (type == RegionizedPlayerChunkLoader.REGION_PLAYER_TICKET && delayTimeout > 0) {
diff --git a/src/main/java/io/papermc/paper/command/subcommands/VersionCommand.java b/src/main/java/io/papermc/paper/command/subcommands/VersionCommand.java
index ae60bd96b5284d54676d8e7e4dd5d170b526ec1e..ad33c51ea9f74d2afd39c9139a9114b0f4436400 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/VersionCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/VersionCommand.java
@@ -7,6 +7,7 @@ import org.bukkit.command.CommandSender;
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.checkerframework.framework.qual.DefaultQualifier;
+import top.leavesmc.leaves.util.ArrayConstants;
 
 @DefaultQualifier(NonNull.class)
 public final class VersionCommand implements PaperSubcommand {
@@ -14,7 +15,7 @@ public final class VersionCommand implements PaperSubcommand {
     public boolean execute(final CommandSender sender, final String subCommand, final String[] args) {
         final @Nullable Command ver = MinecraftServer.getServer().server.getCommandMap().getCommand("version");
         if (ver != null) {
-            ver.execute(sender, "paper", new String[0]);
+            ver.execute(sender, "paper", ArrayConstants.emptyStringArray); // Leaves - reduce array allocations
         }
         return true;
     }
diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index d7f541d94941a341a70dfac025a3d3601dd1aca8..a00a0a8148107fae1f8a2dce671bb0d08d5ba886 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -50,8 +50,8 @@ public class GlobalConfiguration extends ConfigurationPart {
     public Timings timings;
 
     public class Timings extends ConfigurationPart.Post {
-        public boolean enabled = true;
-        public boolean verbose = true;
+        public boolean enabled = false; // Leaves - def false
+        public boolean verbose = false; // Leaves - def false
         public String url = "https://timings.aikar.co/";
         public boolean serverNamePrivacy = false;
         public List<String> hiddenConfigEntries = List.of(
@@ -212,7 +212,7 @@ public class GlobalConfiguration extends ConfigurationPart {
             }
 
             public boolean isEnabled() {
-                return this.interval > 0.0 && this.maxPacketRate > 0.0;
+                return !top.leavesmc.leaves.LeavesConfig.disablePacketLimit && (this.interval > 0.0 && this.maxPacketRate > 0.0); // Leaves - disable packet limit
             }
 
             public enum ViolateAction {
diff --git a/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java b/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java
index ad2177cdbc61a6f41c7e2ed81af262d4ffe7d861..4a0da4436998fc21506996216bd9c094806eb6c9 100644
--- a/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java
+++ b/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java
@@ -293,6 +293,7 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
             for (ServerLevel level : server.getAllLevels()) {
                 this.createWorldConfig(createWorldContextMap(level), reloader(this.worldConfigClass, level.paperConfig()));
             }
+            top.leavesmc.leaves.LeavesConfig.doMcTechnicalMode(); // Leaves - mc technical survival mode
         } catch (Exception ex) {
             throw new RuntimeException("Could not reload paper configuration files", ex);
         }
diff --git a/src/main/java/io/papermc/paper/util/MCUtil.java b/src/main/java/io/papermc/paper/util/MCUtil.java
index cb4379268b191d331c71be44642baac381ffaaf6..f5db4e41b9f3d90138076e8b30a81e4c22497136 100644
--- a/src/main/java/io/papermc/paper/util/MCUtil.java
+++ b/src/main/java/io/papermc/paper/util/MCUtil.java
@@ -211,7 +211,13 @@ public final class MCUtil {
     }
 
     public static long getCoordinateKey(final Entity entity) {
-        return ((long)(MCUtil.fastFloor(entity.getZ()) >> 4) << 32) | ((MCUtil.fastFloor(entity.getX()) >> 4) & 0xFFFFFFFFL);
+        // Leaves start - eliminate double -> long cast in hotpath
+        if (top.leavesmc.leaves.LeavesConfig.optimizeEntityCoordinateKey) {
+            return ((long)(entity.blockPosition.getZ() >> 4) << 32) | ((entity.blockPosition.getX() >> 4) & 0xFFFFFFFFL);
+        } else {
+            return ((long)(MCUtil.fastFloor(entity.getZ()) >> 4) << 32) | ((MCUtil.fastFloor(entity.getX()) >> 4) & 0xFFFFFFFFL);
+        }
+        // Leaves end - eliminate double -> long cast in hotpath
     }
 
     public static long getCoordinateKey(final ChunkPos pair) {
diff --git a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
index 7e8dc9e8f381abfdcce2746edc93122d623622d1..59403aa7b77adab763c60f3f7805c802a94dcd41 100644
--- a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
+++ b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
@@ -24,6 +24,7 @@ import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.function.Predicate;
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public final class ChunkEntitySlices {
 
@@ -82,7 +83,7 @@ public final class ChunkEntitySlices {
             }
         }
 
-        return ret.toArray(new org.bukkit.entity.Entity[0]);
+        return ret.toArray(ArrayConstants.emptyBukkitEntityArray); // Leaves - reduce array allocations
     }
 
     public CompoundTag save() {
@@ -303,7 +304,7 @@ public final class ChunkEntitySlices {
 
     protected static final class BasicEntityList<E extends Entity> {
 
-        protected static final Entity[] EMPTY = new Entity[0];
+        // protected static final Entity[] EMPTY = new Entity[0]; // Leaves - reduce array allocations
         protected static final int DEFAULT_CAPACITY = 4;
 
         protected E[] storage;
@@ -314,7 +315,7 @@ public final class ChunkEntitySlices {
         }
 
         public BasicEntityList(final int cap) {
-            this.storage = (E[])(cap <= 0 ? EMPTY : new Entity[cap]);
+            this.storage = (E[])(cap <= 0 ? ArrayConstants.emptyEntityArray : new Entity[cap]); // Leaves - reduce array allocations
         }
 
         public boolean isEmpty() {
@@ -326,7 +327,7 @@ public final class ChunkEntitySlices {
         }
 
         private void resize() {
-            if (this.storage == EMPTY) {
+            if (this.storage == ArrayConstants.emptyEntityArray) { // Leaves - reduce array allocations
                 this.storage = (E[])new Entity[DEFAULT_CAPACITY];
             } else {
                 this.storage = Arrays.copyOf(this.storage, this.storage.length * 2);
diff --git a/src/main/java/net/minecraft/advancements/Advancement.java b/src/main/java/net/minecraft/advancements/Advancement.java
index 81359be381fc9bcb56a9cc83e70a6afa6e838c6a..23f930775d8d684da915ca72ca1c4b27572fb056 100644
--- a/src/main/java/net/minecraft/advancements/Advancement.java
+++ b/src/main/java/net/minecraft/advancements/Advancement.java
@@ -46,7 +46,7 @@ public class Advancement {
     public Advancement(ResourceLocation id, @Nullable Advancement parent, @Nullable DisplayInfo display, AdvancementRewards rewards, Map<String, Criterion> criteria, String[][] requirements, boolean sendsTelemetryEvent) {
         this.id = id;
         this.display = display;
-        this.criteria = ImmutableMap.copyOf(criteria);
+        this.criteria = !top.leavesmc.leaves.LeavesConfig.skipCloningAdvancementCriteria ? ImmutableMap.copyOf(criteria) : criteria; // Leaves - skip cloning advancement criteria
         this.parent = parent;
         this.rewards = rewards;
         this.requirements = requirements;
diff --git a/src/main/java/net/minecraft/advancements/critereon/EntityEquipmentPredicate.java b/src/main/java/net/minecraft/advancements/critereon/EntityEquipmentPredicate.java
index b8ef0f9c815799d54edcdb26dc0b4c1c281fc03e..85ccff2938dc138e5d309448cd631fe534effd42 100644
--- a/src/main/java/net/minecraft/advancements/critereon/EntityEquipmentPredicate.java
+++ b/src/main/java/net/minecraft/advancements/critereon/EntityEquipmentPredicate.java
@@ -13,7 +13,7 @@ import net.minecraft.world.item.Items;
 
 public class EntityEquipmentPredicate {
     public static final EntityEquipmentPredicate ANY = new EntityEquipmentPredicate(ItemPredicate.ANY, ItemPredicate.ANY, ItemPredicate.ANY, ItemPredicate.ANY, ItemPredicate.ANY, ItemPredicate.ANY);
-    public static final EntityEquipmentPredicate CAPTAIN = new EntityEquipmentPredicate(ItemPredicate.Builder.item().of(Items.WHITE_BANNER).hasNbt(Raid.getLeaderBannerInstance().getTag()).build(), ItemPredicate.ANY, ItemPredicate.ANY, ItemPredicate.ANY, ItemPredicate.ANY, ItemPredicate.ANY);
+    public static final EntityEquipmentPredicate CAPTAIN = new EntityEquipmentPredicate(ItemPredicate.Builder.item().of(Items.WHITE_BANNER).hasNbt(top.leavesmc.leaves.LeavesConfig.cacheOminousBannerItem ? Raid.LEADER_BANNER.getTag() : Raid.getLeaderBannerInstance().getTag()).build(), ItemPredicate.ANY, ItemPredicate.ANY, ItemPredicate.ANY, ItemPredicate.ANY, ItemPredicate.ANY); // Leaves - cache ominous banner item
     private final ItemPredicate head;
     private final ItemPredicate chest;
     private final ItemPredicate legs;
diff --git a/src/main/java/net/minecraft/commands/arguments/ArgumentSignatures.java b/src/main/java/net/minecraft/commands/arguments/ArgumentSignatures.java
index 72a8aa676836fcb3b4578689d16af65e18f55bbe..47a06936a4727c6209a7ad0fb8fb10995d36513c 100644
--- a/src/main/java/net/minecraft/commands/arguments/ArgumentSignatures.java
+++ b/src/main/java/net/minecraft/commands/arguments/ArgumentSignatures.java
@@ -13,10 +13,17 @@ public record ArgumentSignatures(List<ArgumentSignatures.Entry> entries) {
     private static final int MAX_ARGUMENT_COUNT = 8;
     private static final int MAX_ARGUMENT_NAME_LENGTH = 16;
 
+    // Leaves start - no chat sign
     public ArgumentSignatures(FriendlyByteBuf buf) {
-        this(buf.readCollection(FriendlyByteBuf.limitValue(ArrayList::new, 8), ArgumentSignatures.Entry::new));
+        this(readSign(buf));
     }
 
+    private static List<ArgumentSignatures.Entry> readSign(FriendlyByteBuf buf) {
+        var entries = buf.readCollection(FriendlyByteBuf.limitValue(ArrayList::new, 8), Entry::new);
+        return top.leavesmc.leaves.LeavesConfig.noChatSign ? List.of() : entries;
+    }
+    // Leaves end - no chat sign
+
     @Nullable
     public MessageSignature get(String argumentName) {
         for(ArgumentSignatures.Entry entry : this.entries) {
diff --git a/src/main/java/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java b/src/main/java/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java
index 9b0049dfeaec9b688bf276f2ac2b18943b5696b2..8a7733f83c2ba0c73069357184d77eee57959a07 100644
--- a/src/main/java/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java
+++ b/src/main/java/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java
@@ -63,7 +63,7 @@ public class ShearsDispenseItemBehavior extends OptionalDispenseItemBehavior {
             BlockPos blockposition = pointer.getPos().relative((Direction) pointer.getBlockState().getValue(DispenserBlock.FACING));
 
             this.setSuccess(ShearsDispenseItemBehavior.tryShearBeehive(worldserver, blockposition) || ShearsDispenseItemBehavior.tryShearLivingEntity(worldserver, blockposition, bukkitBlock, craftItem)); // CraftBukkit
-            if (this.isSuccess() && stack.hurt(1, worldserver.getRandom(), (ServerPlayer) null)) {
+            if (this.isSuccess() && stack.hurt(1, worldserver.getRandom(), (ServerPlayer) null) && !top.leavesmc.leaves.LeavesConfig.shearsInDispenserCanZeroAmount) { // Leaves - Make shears in dispenser can unlimited use
                 stack.setCount(0);
             }
         }
diff --git a/src/main/java/net/minecraft/nbt/ByteArrayTag.java b/src/main/java/net/minecraft/nbt/ByteArrayTag.java
index 163b1895bcbd16e93d36cd60d03e6b21df51cba7..4c56f92e111ad457f9c8cb0694ea01f2a59be3c5 100644
--- a/src/main/java/net/minecraft/nbt/ByteArrayTag.java
+++ b/src/main/java/net/minecraft/nbt/ByteArrayTag.java
@@ -7,6 +7,7 @@ import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
 import org.apache.commons.lang3.ArrayUtils;
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public class ByteArrayTag extends CollectionTag<ByteTag> {
 
@@ -175,7 +176,7 @@ public class ByteArrayTag extends CollectionTag<ByteTag> {
     }
 
     public void clear() {
-        this.data = new byte[0];
+        this.data = ArrayConstants.emptyByteArray; // Leaves - reduce array allocations
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/nbt/CompoundTag.java b/src/main/java/net/minecraft/nbt/CompoundTag.java
index 7e94ebe06fc62293e665d6db19e42d947e7eb30f..b9661ba4b120e378ee1aff1fa1592827e512ec48 100644
--- a/src/main/java/net/minecraft/nbt/CompoundTag.java
+++ b/src/main/java/net/minecraft/nbt/CompoundTag.java
@@ -17,6 +17,7 @@ import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public class CompoundTag implements Tag {
     public static final Codec<CompoundTag> CODEC = Codec.PASSTHROUGH.comapFlatMap((dynamic) -> {
@@ -379,7 +380,7 @@ public class CompoundTag implements Tag {
             throw new ReportedException(this.createReport(key, ByteArrayTag.TYPE, var3));
         }
 
-        return new byte[0];
+        return ArrayConstants.emptyByteArray; // Leaves - reduce array allocations
     }
 
     public int[] getIntArray(String key) {
@@ -391,7 +392,7 @@ public class CompoundTag implements Tag {
             throw new ReportedException(this.createReport(key, IntArrayTag.TYPE, var3));
         }
 
-        return new int[0];
+        return ArrayConstants.emptyIntArray; // Leaves - reduce array allocations
     }
 
     public long[] getLongArray(String key) {
@@ -403,7 +404,7 @@ public class CompoundTag implements Tag {
             throw new ReportedException(this.createReport(key, LongArrayTag.TYPE, var3));
         }
 
-        return new long[0];
+        return ArrayConstants.emptyLongArray; // Leaves - reduce array allocations
     }
 
     public CompoundTag getCompound(String key) {
diff --git a/src/main/java/net/minecraft/nbt/IntArrayTag.java b/src/main/java/net/minecraft/nbt/IntArrayTag.java
index 25ad2c6ff968f4a6b16b4dea3f67341a4261f2a4..478bc2428e133414d13e9a44ad7c2c567c13411e 100644
--- a/src/main/java/net/minecraft/nbt/IntArrayTag.java
+++ b/src/main/java/net/minecraft/nbt/IntArrayTag.java
@@ -7,6 +7,7 @@ import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
 import org.apache.commons.lang3.ArrayUtils;
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public class IntArrayTag extends CollectionTag<IntTag> {
 
@@ -189,7 +190,7 @@ public class IntArrayTag extends CollectionTag<IntTag> {
     }
 
     public void clear() {
-        this.data = new int[0];
+        this.data = ArrayConstants.emptyIntArray; // Leaves - reduce array allocations
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index cf20f0983fc25b26cf92b9d3a28746b1909fc56b..c8d62a76bfa1a54b6ecb23f0d53ba2db15fcb1f7 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -47,6 +47,7 @@ import org.apache.commons.lang3.Validate;
 import org.slf4j.Logger;
 import org.slf4j.Marker;
 import org.slf4j.MarkerFactory;
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
@@ -325,7 +326,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     public void setListener(PacketListener listener) {
-        Validate.notNull(listener, "packetListener", new Object[0]);
+        Validate.notNull(listener, "packetListener", ArrayConstants.emptyObjectArray); // Leaves - reduce array allocations
         this.packetListener = listener;
     }
     // Paper start
diff --git a/src/main/java/net/minecraft/network/FriendlyByteBuf.java b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
index 9938bb90bef84cf784f9a1ceb02a1a45aa8b48a1..923b77b9793369395f5f138ef03d8b489957caa1 100644
--- a/src/main/java/net/minecraft/network/FriendlyByteBuf.java
+++ b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
@@ -67,6 +67,7 @@ import net.minecraft.nbt.NbtIo;
 import net.minecraft.nbt.Tag;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.protocol.status.ServerStatus;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.util.Crypt;
@@ -154,6 +155,16 @@ public class FriendlyByteBuf extends ByteBuf {
     public <T> void writeJsonWithCodec(Codec<T> codec, T value) {
         DataResult<JsonElement> dataresult = codec.encodeStart(JsonOps.INSTANCE, value);
 
+        // Leaves start - no chat sign
+        if (codec == ServerStatus.CODEC) {
+            JsonElement element = Util.getOrThrow(dataresult, string -> new EncoderException("Failed to encode: " + string + " " + value));
+            element.getAsJsonObject().addProperty("preventsChatReports", top.leavesmc.leaves.LeavesConfig.noChatSign);
+
+            this.writeUtf(GSON.toJson(element));
+			return;
+        }
+        // Leaves end - no chat sign
+
         this.writeUtf(FriendlyByteBuf.GSON.toJson((JsonElement) Util.getOrThrow(dataresult, (s) -> {
             return new EncoderException("Failed to encode: " + s + " " + value);
         })));
diff --git a/src/main/java/net/minecraft/network/protocol/PacketUtils.java b/src/main/java/net/minecraft/network/protocol/PacketUtils.java
index d2f0a0755317f5fa9a1ccf7db346aa77fd287d80..9c7fb1b7c2ff458e72bdcfa80c49252cd78e7d14 100644
--- a/src/main/java/net/minecraft/network/protocol/PacketUtils.java
+++ b/src/main/java/net/minecraft/network/protocol/PacketUtils.java
@@ -49,6 +49,10 @@ public class PacketUtils {
                     co.aikar.timings.Timing timing = co.aikar.timings.MinecraftTimings.getPacketTiming(packet); // Paper - timings
                     try (co.aikar.timings.Timing ignored = timing.startTiming()) { // Paper - timings
                         packet.handle(listener);
+                    // Leaves start - update suppression crash fix
+                    } catch (top.leavesmc.leaves.util.UpdateSuppressionException exception) {
+                        top.leavesmc.leaves.LeavesLogger.LOGGER.info(exception.getMessage());
+                    // Leaves start - update suppression crash fix
                     } catch (Exception exception) {
                         if (listener.shouldPropagateHandlingExceptions()) {
                             throw exception;
diff --git a/src/main/java/net/minecraft/network/protocol/game/ServerboundChatPacket.java b/src/main/java/net/minecraft/network/protocol/game/ServerboundChatPacket.java
index d1d2fc0c57523c1abf1e8bfec913c78927c3dafc..50c1b722231c2add72663c475ae9068a35bfd524 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ServerboundChatPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ServerboundChatPacket.java
@@ -8,10 +8,18 @@ import net.minecraft.network.chat.MessageSignature;
 import net.minecraft.network.protocol.Packet;
 
 public record ServerboundChatPacket(String message, Instant timeStamp, long salt, @Nullable MessageSignature signature, LastSeenMessages.Update lastSeenMessages) implements Packet<ServerGamePacketListener> {
+    // Leaves start - no chat sign
     public ServerboundChatPacket(FriendlyByteBuf buf) {
-        this(buf.readUtf(256), buf.readInstant(), buf.readLong(), buf.readNullable(MessageSignature::read), new LastSeenMessages.Update(buf));
+        this(buf.readUtf(256), buf.readInstant(), buf.readLong(), buf.readNullable(ServerboundChatPacket::readSign), new LastSeenMessages.Update(buf));
     }
 
+    private static MessageSignature readSign(FriendlyByteBuf buf) {
+        byte[] bs = new byte[256];
+        buf.readBytes(bs);
+        return top.leavesmc.leaves.LeavesConfig.noChatSign ? null : new MessageSignature(bs);
+    }
+    // Leaves end - no chat sign
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeUtf(this.message, 256);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ServerboundChatSessionUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ServerboundChatSessionUpdatePacket.java
index 9d6db4a378036559efab91c8b7dcf2a6b0c2cce6..2c349dc502ce275a8215766933f4855f1c7bd726 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ServerboundChatSessionUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ServerboundChatSessionUpdatePacket.java
@@ -16,6 +16,11 @@ public record ServerboundChatSessionUpdatePacket(RemoteChatSession.Data chatSess
 
     @Override
     public void handle(ServerGamePacketListener listener) {
+        // Leaves start - no chat report
+        if (top.leavesmc.leaves.LeavesConfig.noChatSign) {
+            return;
+        }
+        // Leaves end - no chat report
         listener.handleChatSessionUpdate(this);
     }
 }
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index dae36c6452ccd57a436dd918547b64d59957ab0a..973ecf723e4239307600b42f2d12c264f44d1827 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -193,7 +193,7 @@ public class Main {
                 file = new File(bukkitConfiguration.getString("settings.world-container", "."));
             }
             // Paper end - fix SPIGOT-5824
-            Services services = Services.create(new com.destroystokyo.paper.profile.PaperAuthenticationService(Proxy.NO_PROXY), file, userCacheFile, optionset); // Paper
+            Services services = Services.create(new top.leavesmc.leaves.profile.LeavesAuthenticationService(Proxy.NO_PROXY), file, userCacheFile, optionset); // Paper // Leaves - extra-yggdrasil-service
             // CraftBukkit start
             String s = (String) Optional.ofNullable((String) optionset.valueOf("world")).orElse(dedicatedserversettings.getProperties().levelName);
             LevelStorageSource convertable = LevelStorageSource.createDefault(file.toPath());
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 3238cbcba567b1242c77e41f6b6f19a8d157fb4e..9bd10bf6877852b684cb3dbfa1cc426aa4ab3df6 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -127,6 +127,7 @@ import net.minecraft.util.profiling.metrics.storage.MetricsPersister;
 import net.minecraft.util.thread.ReentrantBlockableEventLoop;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.RandomSequences;
+import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.ai.village.VillageSiege;
 import net.minecraft.world.entity.npc.CatSpawner;
@@ -263,7 +264,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private boolean isDemo;
     private volatile boolean isReady;
     private long lastOverloadWarning;
-    protected final Services services;
+    public final Services services; // Leaves - protected -> public
     private long lastServerStatus;
     public final Thread serverThread;
     private long nextTickTime;
@@ -633,6 +634,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
         // Paper end
 
+        top.leavesmc.leaves.bot.ServerBot.loadAllBot(); // Leaves - load resident bot
+
         this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD);
         this.server.getPluginManager().callEvent(new ServerLoadEvent(ServerLoadEvent.LoadType.STARTUP));
         this.connection.acceptConnections();
@@ -938,6 +941,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         MinecraftServer.LOGGER.info("Stopping server");
         Commands.COMMAND_SENDING_POOL.shutdownNow(); // Paper - Shutdown and don't bother finishing
         MinecraftTimings.stopServer(); // Paper
+        top.leavesmc.leaves.bot.ServerBot.saveOrRemoveAllBot(); // Leaves - save or remove bot
         // CraftBukkit start
         if (this.server != null) {
             this.server.disablePlugins();
@@ -1118,6 +1122,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             LOGGER.info("Done ({})! For help, type \"help\"", doneTime);
             // Paper end
 
+			top.leavesmc.leaves.LeavesConfig.createWorldSections = false; // Leaves - dont let plugin create worlds fill our config
             org.spigotmc.WatchdogThread.tick(); // Paper
             org.spigotmc.WatchdogThread.hasStarted = true; // Paper
             Arrays.fill( recentTps, 20 );
@@ -1554,7 +1559,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             try {
                 worldserver.timings.doTick.startTiming(); // Spigot
-                worldserver.tick(shouldKeepTicking);
+                // Leaves start
+                try {
+                    worldserver.tick(shouldKeepTicking);
+                } catch (top.leavesmc.leaves.util.UpdateSuppressionException e) {
+                    top.leavesmc.leaves.LeavesLogger.LOGGER.info(e.getMessage());
+                }
+                // Leaves end
                 // Paper start
                 for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkSource().chunkMap.regionManagers) {
                     regionManager.recalculateRegions();
@@ -1596,6 +1607,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         this.profiler.popPush("server gui refresh");
 
+        top.leavesmc.leaves.protocol.BBORProtocol.tick(); // Leaves - bbor
+        top.leavesmc.leaves.protocol.AppleSkinProtocol.tick(); // Leaves - appleskin
+        top.leavesmc.leaves.util.BreakBedrockList.endTick(); // Leaves - break bedrock list
+        top.leavesmc.leaves.protocol.bladeren.MsptSyncProtocol.tick(this); // Leaves - mspt sync
+
         MinecraftTimings.tickablesTimer.startTiming(); // Spigot // Paper
         for (int i = 0; i < this.tickables.size(); ++i) {
             ((Runnable) this.tickables.get(i)).run();
@@ -1693,7 +1709,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     @DontObfuscate
     public String getServerModName() {
-        return "Paper"; // Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "Leaves"; // Leaves - Leaves > //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public SystemReport fillSystemReport(SystemReport details) {
@@ -2272,6 +2288,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public ProfilerFiller getProfiler() {
+        // Leaves start - disable method profiler
+        if (top.leavesmc.leaves.LeavesConfig.disableMethodProfiler) {
+            return net.minecraft.util.profiling.InactiveProfiler.INSTANCE;
+        }
+        // Leaves end - disable method profiler
         return this.profiler;
     }
 
diff --git a/src/main/java/net/minecraft/server/PlayerAdvancements.java b/src/main/java/net/minecraft/server/PlayerAdvancements.java
index acc49f66bf34e2507d0ee6fec0a56b11bfc68f46..fd9e85dab7c511873824cac56a270ff435792292 100644
--- a/src/main/java/net/minecraft/server/PlayerAdvancements.java
+++ b/src/main/java/net/minecraft/server/PlayerAdvancements.java
@@ -43,7 +43,9 @@ import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.players.PlayerList;
 import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.GameType;
 import org.slf4j.Logger;
+import top.leavesmc.leaves.bot.ServerBot;
 
 public class PlayerAdvancements {
 
@@ -224,6 +226,16 @@ public class PlayerAdvancements {
     }
 
     public boolean award(Advancement advancement, String criterionName) {
+        // Leaves start - bot can't get advancement
+        if (player instanceof ServerBot) {
+            return false;
+        }
+        // Leaves end - bot can't get advancement
+        // Leaves start - spectator don't get advancement
+        if (top.leavesmc.leaves.LeavesConfig.spectatorDontGetAdvancement && player.gameMode.getGameModeForPlayer() == GameType.SPECTATOR) {
+            return false;
+        }
+        // Leaves end - spectator don't get advancement
         boolean flag = false;
         AdvancementProgress advancementprogress = this.getOrStartProgress(advancement);
         boolean flag1 = advancementprogress.isDone();
diff --git a/src/main/java/net/minecraft/server/ServerScoreboard.java b/src/main/java/net/minecraft/server/ServerScoreboard.java
index 3a4a0727ad44322e3ba85512cd077808dab080b7..4a1a5f5c4672262875caa17bc7da8aa221b82742 100644
--- a/src/main/java/net/minecraft/server/ServerScoreboard.java
+++ b/src/main/java/net/minecraft/server/ServerScoreboard.java
@@ -132,6 +132,7 @@ public class ServerScoreboard extends Scoreboard {
     @Override
     public void onObjectiveAdded(Objective objective) {
         super.onObjectiveAdded(objective);
+        top.leavesmc.leaves.util.BreakBedrockList.onScoreboardAdd(objective); // Leaves - break bedrock list
         this.setDirty();
     }
 
@@ -148,6 +149,7 @@ public class ServerScoreboard extends Scoreboard {
     @Override
     public void onObjectiveRemoved(Objective objective) {
         super.onObjectiveRemoved(objective);
+        top.leavesmc.leaves.util.BreakBedrockList.onScoreboardRemove(objective); // Leaves - break bedrock list
         if (this.trackedObjectives.contains(objective)) {
             this.stopTrackingObjective(objective);
         }
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 9f422cbeaa52b3e6a0a27af4f8ad4ddb7808483f..9abc92d8c98c1075ebc74e9dc4290b887913cc29 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -217,10 +217,14 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         org.spigotmc.WatchdogThread.doStart(org.spigotmc.SpigotConfig.timeoutTime, org.spigotmc.SpigotConfig.restartOnCrash);
         thread.start(); // Paper - start console thread after MinecraftServer.console & PaperConfig are initialized
         io.papermc.paper.command.PaperCommands.registerCommands(this);
-        com.destroystokyo.paper.Metrics.PaperMetrics.startMetrics();
         com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // load version history now
         io.papermc.paper.brigadier.PaperBrigadierProviderImpl.INSTANCE.getClass(); // init PaperBrigadierProvider
         // Paper end
+		
+		top.leavesmc.leaves.LeavesConfig.init((java.io.File) options.valueOf("leaves-settings")); // Leaves - Server Config
+        top.leavesmc.leaves.LeavesConfig.registerCommands(); // Leaves - Server Command
+
+        com.destroystokyo.paper.Metrics.PaperMetrics.startMetrics(); // Leaves - down
 
         this.setPvpAllowed(dedicatedserverproperties.pvp);
         this.setFlightAllowed(dedicatedserverproperties.allowFlight);
@@ -639,7 +643,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
     public boolean enforceSecureProfile() {
         DedicatedServerProperties dedicatedserverproperties = this.getProperties();
 
-        return dedicatedserverproperties.enforceSecureProfile && dedicatedserverproperties.onlineMode && this.services.profileKeySignatureValidator() != null;
+        return dedicatedserverproperties.enforceSecureProfile && dedicatedserverproperties.onlineMode && this.services.profileKeySignatureValidator() != null && !top.leavesmc.leaves.LeavesConfig.noChatSign; // Leaves - No Secure profile;
     }
 
     protected boolean convertOldUsers() {
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 469083208110d5735e1bbda7a15c55a032d0e8cc..092c7a1430c1e380cdaec308624afce0733a4556 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -195,7 +195,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerChunkTickRangeMap;
     // Paper end - optimise ChunkMap#anyPlayerCloseEnoughForSpawning
 
-    void addPlayerToDistanceMaps(ServerPlayer player) {
+    public void addPlayerToDistanceMaps(ServerPlayer player) { // Leaves - package -> public
         this.level.playerChunkLoader.addPlayer(player); // Paper - replace chunk loader
         int chunkX = MCUtil.getChunkCoordinate(player.getX());
         int chunkZ = MCUtil.getChunkCoordinate(player.getZ());
@@ -217,7 +217,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.playerGeneralAreaMap.add(player, chunkX, chunkZ, GENERAL_AREA_MAP_SQUARE_RADIUS); // Paper - optimise checkDespawn
     }
 
-    void removePlayerFromDistanceMaps(ServerPlayer player) {
+    public void removePlayerFromDistanceMaps(ServerPlayer player) { // Leaves - package -> public
         this.level.playerChunkLoader.removePlayer(player); // Paper - replace chunk loader
 
         // Paper start - optimise ChunkMap#anyPlayerCloseEnoughForSpawning
@@ -295,7 +295,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper - rewrite chunk system
         this.tickingGenerated = new AtomicInteger();
         this.playerMap = new PlayerMap();
-        this.entityMap = new Int2ObjectOpenHashMap();
+        this.entityMap = top.leavesmc.leaves.LeavesConfig.useOptimizedCollection ? new it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap() : new Int2ObjectOpenHashMap(); // Leaves - se linked map for entity trackers - provides faster iteration
         this.chunkTypeCache = new Long2ByteOpenHashMap();
         this.chunkSaveCooldowns = new Long2LongOpenHashMap();
         this.unloadQueue = Queues.newConcurrentLinkedQueue();
@@ -1081,7 +1081,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     private boolean skipPlayer(ServerPlayer player) {
-        return player.isSpectator() && !this.level.getGameRules().getBoolean(GameRules.RULE_SPECTATORSGENERATECHUNKS);
+        return (player.isSpectator() && !this.level.getGameRules().getBoolean(GameRules.RULE_SPECTATORSGENERATECHUNKS))
+            || (top.leavesmc.leaves.LeavesConfig.elytraAeronauticsNoChunk && player.elytraAeronauticsNoChunk); // Leaves - Elytra aeronautics
     }
 
     void updatePlayerStatus(ServerPlayer player, boolean added) {
@@ -1122,6 +1123,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public void move(ServerPlayer player) {
         // Paper - delay this logic for the entity tracker tick, no need to duplicate it
 
+        if (player.elytraAeronauticsNoChunk) return;
         int i = SectionPos.blockToSectionCoord(player.getBlockX());
         int j = SectionPos.blockToSectionCoord(player.getBlockZ());
         SectionPos sectionposition = player.getLastSectionPos();
@@ -1556,19 +1558,45 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             return ChunkMap.this.level.getServer().getScaledTrackingDistance(initialDistance);
         }
 
+        // Leaves start
+        private static int getHighestRange(Entity parent, int highest) {
+            List<Entity> passengers = parent.getPassengers();
+
+            for (int i = 0, size = passengers.size(); i < size; i++) {
+                Entity entity = passengers.get(i);
+                int range = entity.getType().clientTrackingRange() * 16;
+                range = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, range); // Paper
+
+                if (range > highest) { // Paper - we need the lowest range thanks to the fact that our tracker doesn't account for passenger logic // Tuinity - not anymore!
+                    highest = range;
+                }
+
+                highest = getHighestRange(entity, highest);
+            }
+
+            return highest;
+        }
+        // Leaves end
+
         private int getEffectiveRange() {
             int i = this.range;
-            Iterator iterator = this.entity.getIndirectPassengers().iterator();
+            // Leaves start - remove iterators and streams
+            if (top.leavesmc.leaves.LeavesConfig.removeRangeCheckStreams) {
+                i = getHighestRange(this.entity, i);
+            } else {
+                Iterator iterator = this.entity.getIndirectPassengers().iterator();
 
-            while (iterator.hasNext()) {
-                Entity entity = (Entity) iterator.next();
-                int j = entity.getType().clientTrackingRange() * 16;
-                j = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, j); // Paper
+                while (iterator.hasNext()) {
+                    Entity entity = (Entity) iterator.next();
+                    int j = entity.getType().clientTrackingRange() * 16;
+                    j = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, j); // Paper
 
-                if (j > i) {
-                    i = j;
+                    if (j > i) {
+                        i = j;
+                    }
                 }
             }
+            // Leaves end - remove iterators and streams
 
             return this.scaledRange(i);
         }
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 488a253e218409b5f0b4a872cee0928578fa7582..a1046f68b078be2dc0e7fda129cc5beb81bd9e1f 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -553,35 +553,47 @@ public class ServerChunkCache extends ChunkSource {
             ProfilerFiller gameprofilerfiller = this.level.getProfiler();
 
             gameprofilerfiller.push("pollingChunks");
+            // Leaves start - reset ice & snow tick random
+            if (top.leavesmc.leaves.LeavesConfig.optimizeChunkTicking) {
+                this.level.resetIceAndSnowTick();
+            }
+            // Leaves end - reset ice & snow tick random
             int k = this.level.getGameRules().getInt(GameRules.RULE_RANDOMTICKING);
             boolean flag1 = level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) != 0L && worlddata.getGameTime() % level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) == 0L; // CraftBukkit
 
-            gameprofilerfiller.push("naturalSpawnCount");
-            this.level.timings.countNaturalMobs.startTiming(); // Paper - timings
-            int l = this.distanceManager.getNaturalSpawnChunkCount();
-            // Paper start - per player mob spawning
+            // Leaves start - skip unnecessary mob spawning computations
             NaturalSpawner.SpawnState spawnercreature_d; // moved down
-            if ((this.spawnFriendlies || this.spawnEnemies) && this.chunkMap.playerMobDistanceMap != null) { // don't count mobs when animals and monsters are disabled
-                // re-set mob counts
-                for (ServerPlayer player : this.level.players) {
-                    Arrays.fill(player.mobCounts, 0);
+            boolean flag2 = this.level.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING) && !this.level.players().isEmpty(); // CraftBukkit
+            boolean flag2AndHasNaturalSpawn = flag2 && this.anySpawnCategoryIsSpawnedThisTick();
+            if (!top.leavesmc.leaves.LeavesConfig.skipUnnecessaryMobSpawningComputations || flag2AndHasNaturalSpawn) {
+                gameprofilerfiller.push("naturalSpawnCount");
+                this.level.timings.countNaturalMobs.startTiming(); // Paper - timings
+                int l = this.distanceManager.getNaturalSpawnChunkCount();
+                // Paper start - per player mob spawning
+                if ((this.spawnFriendlies || this.spawnEnemies) && this.chunkMap.playerMobDistanceMap != null) { // don't count mobs when animals and monsters are disabled
+                    // re-set mob counts
+                    for (ServerPlayer player : this.level.players) {
+                        Arrays.fill(player.mobCounts, 0);
+                    }
+                    spawnercreature_d = NaturalSpawner.createState(l, this.level.getAllEntities(), this::getFullChunk, null, true);
+                } else {
+                    spawnercreature_d = NaturalSpawner.createState(l, this.level.getAllEntities(), this::getFullChunk, this.chunkMap.playerMobDistanceMap == null ? new LocalMobCapCalculator(this.chunkMap) : null, false);
                 }
-                spawnercreature_d = NaturalSpawner.createState(l, this.level.getAllEntities(), this::getFullChunk, null, true);
+                // Paper end
+                this.level.timings.countNaturalMobs.stopTiming(); // Paper - timings
+
+                this.lastSpawnState = spawnercreature_d;
+                gameprofilerfiller.popPush("filteringLoadedChunks");
             } else {
-                spawnercreature_d = NaturalSpawner.createState(l, this.level.getAllEntities(), this::getFullChunk, this.chunkMap.playerMobDistanceMap == null ? new LocalMobCapCalculator(this.chunkMap) : null, false);
+                spawnercreature_d = null;
             }
-            // Paper end
-            this.level.timings.countNaturalMobs.stopTiming(); // Paper - timings
-
-            this.lastSpawnState = spawnercreature_d;
-            gameprofilerfiller.popPush("filteringLoadedChunks");
             // Paper - moved down
             this.level.timings.chunkTicks.startTiming(); // Paper
 
             // Paper - moved down
 
             gameprofilerfiller.popPush("spawnAndTick");
-            boolean flag2 = this.level.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING) && !this.level.players().isEmpty(); // CraftBukkit
+            // Leaves start - skip unnecessary mob spawning computations
 
             // Paper - only shuffle if per-player mob spawning is disabled
             // Paper - moved natural spawn event up
@@ -612,7 +624,7 @@ public class ServerChunkCache extends ChunkSource {
 
                 if ((true || this.level.isNaturalSpawningAllowed(chunkcoordintpair)) && this.chunkMap.anyPlayerCloseEnoughForSpawning(holder, chunkcoordintpair, false)) { // Paper - optimise anyPlayerCloseEnoughForSpawning // Paper - the chunk is known ticking
                     chunk1.incrementInhabitedTime(j);
-                    if (flag2 && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair) && this.chunkMap.anyPlayerCloseEnoughForSpawning(holder, chunkcoordintpair, true)) { // Spigot // Paper - optimise anyPlayerCloseEnoughForSpawning & optimise chunk tick iteration
+                    if ((top.leavesmc.leaves.LeavesConfig.skipUnnecessaryMobSpawningComputations ? flag2AndHasNaturalSpawn : flag2) && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair) && this.chunkMap.anyPlayerCloseEnoughForSpawning(holder, chunkcoordintpair, true)) { // Spigot // Paper - optimise anyPlayerCloseEnoughForSpawning & optimise chunk tick iteration // Leaves -skip unnecessary mob spawning computations
                         NaturalSpawner.spawnForChunk(this.level, chunk1, spawnercreature_d, this.spawnFriendlies, this.spawnEnemies, flag1);
                     }
 
@@ -677,6 +689,18 @@ public class ServerChunkCache extends ChunkSource {
         }
     }
 
+    // Leaves start - skip unnecessary mob spawning computations
+    public boolean anySpawnCategoryIsSpawnedThisTick() {
+        long gameTime = this.level.getLevelData().getGameTime();
+        for (long ticksForSpawnCategory : this.level.ticksPerSpawnCategory.values()) {
+            if (ticksForSpawnCategory != 0L && gameTime % ticksForSpawnCategory == 0L) {
+                return true;
+            }
+        }
+        return false;
+    }
+    // Leaves stop - skip unnecessary mob spawning computations
+
     private void getFullChunk(long pos, Consumer<LevelChunk> chunkConsumer) {
         ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos);
 
diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index 81d0b2933040a451441f660f9e46199ae3b111e3..b840dbdd83eb985615f7de02439ae474dd1afe01 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -194,6 +194,7 @@ public class ServerEntity {
                             flag4 = true;
                             flag5 = true;
                         }
+                        // Leaves end - Better checking
                     } else {
                         this.wasOnGround = this.entity.onGround();
                         this.teleportDelay = 0;
@@ -201,6 +202,11 @@ public class ServerEntity {
                         flag4 = true;
                         flag5 = true;
                     }
+                    // Leaves start - dont send useless entity packets
+                    if (top.leavesmc.leaves.LeavesConfig.dontSendUselessEntityPackets && isUselessPacket(packet1)) {
+                        packet1 = null;
+                    }
+                    // Leaves end - dont send useless entity packets
                 }
 
                 if ((this.trackDelta || this.entity.hasImpulse || this.entity instanceof LivingEntity && ((LivingEntity) this.entity).isFallFlying()) && this.tickCount > 0) {
@@ -273,6 +279,21 @@ public class ServerEntity {
         });
     }
 
+    // Leaves start - dont send useless entity packets
+    private boolean isUselessPacket(Packet<?> possibleUselessPacket) {
+        if (possibleUselessPacket instanceof ClientboundMoveEntityPacket packet) {
+            if (possibleUselessPacket instanceof ClientboundMoveEntityPacket.Pos) {
+                return packet.getXa() == 0 && packet.getYa() == 0 && packet.getZa() == 0;
+            } else if (possibleUselessPacket instanceof ClientboundMoveEntityPacket.PosRot) {
+                return packet.getXa() == 0 && packet.getYa() == 0 && packet.getZa() == 0 && packet.getyRot() == 0 && packet.getxRot() == 0;
+            } else if (possibleUselessPacket instanceof ClientboundMoveEntityPacket.Rot) {
+                return packet.getyRot() == 0 && packet.getxRot() == 0;
+            }
+        }
+        return false;
+    }
+    // Leaves end - dont send useless entity packets
+
     public void removePairing(ServerPlayer player) {
         this.entity.stopSeenByPlayer(player);
         player.connection.send(new ClientboundRemoveEntitiesPacket(new int[]{this.entity.getId()}));
@@ -330,7 +351,7 @@ public class ServerEntity {
 
         if (this.entity instanceof LivingEntity) {
             List<Pair<EquipmentSlot, ItemStack>> list = Lists.newArrayList();
-            EquipmentSlot[] aenumitemslot = EquipmentSlot.values();
+            EquipmentSlot[] aenumitemslot = EquipmentSlot.VALUES; // Leaves - reduce array allocations
             int i = aenumitemslot.length;
 
             for (int j = 0; j < i; ++j) {
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 18aac3da3c88f33b1a71a5920a8daa27e9723913..709229d6226464d2a0bc773a3916c811f42a69aa 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -177,6 +177,7 @@ import org.bukkit.event.world.GenericGameEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public class ServerLevel extends Level implements WorldGenLevel {
 
@@ -869,7 +870,24 @@ public class ServerLevel extends Level implements WorldGenLevel {
                             }
 
                             gameprofilerfiller.push("tick");
-                            this.guardEntityTick(this::tickNonPassenger, entity);
+                            // Leaves start - copied from this.guardEntityTick
+                            if (top.leavesmc.leaves.LeavesConfig.removeTickGuardLambda) {
+                                try {
+                                    this.tickNonPassenger(entity); // Leaves - changed
+                                    MinecraftServer.getServer().executeMidTickTasks(); // Tuinity - execute chunk tasks mid tick
+                                } catch (Throwable throwable) {
+                                    if (throwable instanceof ThreadDeath) throw throwable; // Paper
+                                    // Paper start - Prevent tile entity and entity crashes
+                                    final String msg = String.format("Entity threw exception at %s:%s,%s,%s", entity.level().getWorld().getName(), entity.getX(), entity.getY(), entity.getZ());
+                                    MinecraftServer.LOGGER.error(msg, throwable);
+                                    getCraftServer().getPluginManager().callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerInternalException(msg, throwable)));
+                                    entity.discard();
+                                    // Paper end
+                                }
+                            } else {
+                                this.guardEntityTick(this::tickNonPassenger, entity);
+                            }
+                            // Leaves end - copied from this.guardEntityTick
                             gameprofilerfiller.pop();
                         }
                     }
@@ -934,9 +952,16 @@ public class ServerLevel extends Level implements WorldGenLevel {
     }
     // Paper start - optimise random block ticking
     private final BlockPos.MutableBlockPos chunkTickMutablePosition = new BlockPos.MutableBlockPos();
-    private final io.papermc.paper.util.math.ThreadUnsafeRandom randomTickRandom = new io.papermc.paper.util.math.ThreadUnsafeRandom(this.random.nextLong());
+    // private final io.papermc.paper.util.math.ThreadUnsafeRandom randomTickRandom = new io.papermc.paper.util.math.ThreadUnsafeRandom(this.random.nextLong()); // Leaves - moved to super
     // Paper end
 
+    // Leaves start - reset ice & snow tick random
+    private int currentIceAndSnowTick = 0;
+    protected void resetIceAndSnowTick() {
+        this.currentIceAndSnowTick = this.randomTickRandom.nextInt(16);
+    }
+    // Leaves end - reset ice & snow tick random
+
     public void tickChunk(LevelChunk chunk, int randomTickSpeed) {
         ChunkPos chunkcoordintpair = chunk.getPos();
         boolean flag = this.isRaining();
@@ -947,7 +972,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         gameprofilerfiller.push("thunder");
         final BlockPos.MutableBlockPos blockposition = this.chunkTickMutablePosition; // Paper - use mutable to reduce allocation rate, final to force compile fail on change
 
-        if (!this.paperConfig().environment.disableThunder && flag && this.isThundering() && this.spigotConfig.thunderChance > 0 && this.random.nextInt(this.spigotConfig.thunderChance) == 0) { // Spigot // Paper - disable thunder
+        if (!this.paperConfig().environment.disableThunder && flag && this.isThundering() && this.spigotConfig.thunderChance > 0 && (top.leavesmc.leaves.LeavesConfig.optimizeChunkTicking ? chunk.shouldDoLightning(this.random) : this.random.nextInt(this.spigotConfig.thunderChance) == 0)) { // Spigot // Paper - disable thunder // Leaves - replace random with shouldDoLightning
             blockposition.set(this.findLightningTargetAround(this.getBlockRandomPos(j, 0, k, 15))); // Paper
             if (this.isRainingAt(blockposition)) {
                 DifficultyInstance difficultydamagescaler = this.getCurrentDifficultyAt(blockposition);
@@ -978,7 +1003,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         int l;
         int i1;
 
-        if (!this.paperConfig().environment.disableIceAndSnow && this.random.nextInt(16) == 0) { // Paper - Disable ice and snow
+        if (!this.paperConfig().environment.disableIceAndSnow && (top.leavesmc.leaves.LeavesConfig.optimizeChunkTicking ? (this.currentIceAndSnowTick++ & 15) == 0 : this.random.nextInt(16) == 0)) { // Paper - Disable ice and snow // Paper - optimise random ticking  // Leaves - optimize further random ticking
             // Paper start - optimise chunk ticking
             this.getRandomBlockPosition(j, 0, k, 15, blockposition);
             int normalY = chunk.getHeight(Heightmap.Types.MOTION_BLOCKING, blockposition.getX() & 15, blockposition.getZ() & 15) + 1;
@@ -1054,7 +1079,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                     BlockPos blockposition2 = blockposition.set(j + randomX, randomY, k + randomZ);
                     BlockState iblockdata = com.destroystokyo.paper.util.maplist.IBlockDataList.getBlockDataFromRaw(raw);
 
-                    iblockdata.randomTick(this, blockposition2, this.randomTickRandom);
+                    iblockdata.randomTick(this, blockposition2.immutable(), this.randomTickRandom); // Leaves - reduce array allocations
                     // We drop the fluid tick since LAVA is ALREADY TICKED by the above method (See LiquidBlock).
                     // TODO CHECK ON UPDATE (ping the Canadian)
                 }
@@ -1309,7 +1334,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     public static List<Entity> getCurrentlyTickingEntities() {
         Entity ticking = currentlyTickingEntity.get();
-        List<Entity> ret = java.util.Arrays.asList(ticking == null ? new Entity[0] : new Entity[] { ticking });
+        List<Entity> ret = java.util.Arrays.asList(ticking == null ? ArrayConstants.emptyEntityArray : new Entity[] { ticking }); // Leaves - reduce array allocations
 
         return ret;
     }
@@ -2752,11 +2777,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             // Spigot end
             // Spigot Start
             if (entity.getBukkitEntity() instanceof org.bukkit.inventory.InventoryHolder && (!(entity instanceof ServerPlayer) || entity.getRemovalReason() != Entity.RemovalReason.KILLED)) { // SPIGOT-6876: closeInventory clears death message
-                // Paper start
-                if (entity.getBukkitEntity() instanceof org.bukkit.inventory.Merchant merchant && merchant.getTrader() != null) {
-                    merchant.getTrader().closeInventory(org.bukkit.event.inventory.InventoryCloseEvent.Reason.UNLOADED);
-                }
-                // Paper end
+                // Leaves - fix trading with the void
                 for (org.bukkit.entity.HumanEntity h : Lists.newArrayList(((org.bukkit.inventory.InventoryHolder) entity.getBukkitEntity()).getInventory().getViewers())) {
                     h.closeInventory(org.bukkit.event.inventory.InventoryCloseEvent.Reason.UNLOADED); // Paper
                 }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 9d46536f80b5b3e6641fd377c02166a431edfd77..18cd81c3cd96d96ef6774c03d125d314ee373c28 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -185,6 +185,8 @@ import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.event.player.PlayerToggleSneakEvent;
 import org.bukkit.inventory.MainHand;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.util.ReturnPortalManager;
 // CraftBukkit end
 
 public class ServerPlayer extends Player {
@@ -277,6 +279,10 @@ public class ServerPlayer extends Player {
     public final com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> cachedSingleHashSet; // Paper
     public PlayerNaturallySpawnCreaturesEvent playerNaturallySpawnedEvent; // Paper
     public org.bukkit.event.player.PlayerQuitEvent.QuitReason quitReason = null; // Paper - there are a lot of changes to do if we change all methods leading to the event
+    // Leaves start - player operation limiter
+    private int instaBreakCountPerTick = 0;
+    private int placeBlockCountPerTick = 0;
+    // Leaves end - player operation limiter
 
     private final java.util.concurrent.atomic.AtomicReference<io.papermc.paper.chunk.system.RegionizedPlayerChunkLoader.ViewDistances> viewDistances = new java.util.concurrent.atomic.AtomicReference<>(new io.papermc.paper.chunk.system.RegionizedPlayerChunkLoader.ViewDistances(-1, -1, -1));
     public io.papermc.paper.chunk.system.RegionizedPlayerChunkLoader.PlayerChunkLoaderData chunkLoader;
@@ -710,6 +716,7 @@ public class ServerPlayer extends Player {
             this.joining = false;
         }
         // CraftBukkit end
+        this.resetOperationCountPerTick(); // Leaves - player operation limiter
         this.gameMode.tick();
         this.wardenSpawnTracker.tick();
         --this.spawnInvulnerableTime;
@@ -718,15 +725,19 @@ public class ServerPlayer extends Player {
         }
 
         // Paper start - Configurable container update tick rate
-        if (--containerUpdateDelay <= 0) {
-            this.containerMenu.broadcastChanges();
-            containerUpdateDelay = this.level().paperConfig().tickRates.containerUpdate;
-        }
-        // Paper end
-        if (!this.level().isClientSide && this.containerMenu != this.inventoryMenu && (this.isImmobile() || !this.containerMenu.stillValid(this))) { // Paper - auto close while frozen
-            this.closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason.CANT_USE); // Paper
-            this.containerMenu = this.inventoryMenu;
+        // Leaves start - skip bot
+        if (!(this instanceof ServerBot)) {
+            if (--containerUpdateDelay <= 0) {
+                this.containerMenu.broadcastChanges();
+                containerUpdateDelay = this.level().paperConfig().tickRates.containerUpdate;
+            }
+            // Paper end
+            if (!this.level().isClientSide && this.containerMenu != this.inventoryMenu && (this.isImmobile() || !this.containerMenu.stillValid(this))) { // Paper - auto close while frozen
+                this.closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason.CANT_USE); // Paper
+                this.containerMenu = this.inventoryMenu;
+            }
         }
+        // Leaves end - skip bot
 
         Entity entity = this.getCamera();
 
@@ -742,7 +753,7 @@ public class ServerPlayer extends Player {
             }
         }
 
-        CriteriaTriggers.TICK.trigger(this);
+        if (!(this instanceof ServerBot)) CriteriaTriggers.TICK.trigger(this); // Leaves - skip bot
         if (this.levitationStartPos != null) {
             CriteriaTriggers.LEVITATION.trigger(this, this.levitationStartPos, this.tickCount - this.levitationStartTime);
         }
@@ -935,7 +946,7 @@ public class ServerPlayer extends Player {
         java.util.List<org.bukkit.inventory.ItemStack> loot = new java.util.ArrayList<org.bukkit.inventory.ItemStack>(this.getInventory().getContainerSize());
         boolean keepInventory = this.level().getGameRules().getBoolean(GameRules.RULE_KEEPINVENTORY) || this.isSpectator();
 
-        if (!keepInventory) {
+        if (!keepInventory || this instanceof ServerBot) { // Leaves - skip bot
             for (ItemStack item : this.getInventory().getContents()) {
                 if (!item.isEmpty() && !EnchantmentHelper.hasVanishingCurse(item)) {
                     loot.add(CraftItemStack.asCraftMirror(item));
@@ -1245,6 +1256,7 @@ public class ServerPlayer extends Player {
                 this.setServerLevel(worldserver);
                 this.connection.teleport(exit); // CraftBukkit - use internal teleport without event
                 this.connection.resetPosition();
+                if (top.leavesmc.leaves.LeavesConfig.fixPaper9372) this.mainSupportingBlockPos = Optional.empty(); // Leaves - fix paper 9372
                 worldserver.addDuringPortalTeleport(this);
                 worldserver1.getProfiler().pop();
                 this.triggerDimensionChangeTriggers(worldserver1);
@@ -1264,10 +1276,35 @@ public class ServerPlayer extends Player {
                 this.lastSentHealth = -1.0F;
                 this.lastSentFood = -1;
 
+                // Leaves start - bot support
+                if (top.leavesmc.leaves.LeavesConfig.fakeplayerSupport) {
+                    ServerBot.getBots().forEach(bot1 ->
+                        bot1.render(this.connection, true,this.getBukkitEntity().getWorld() == bot1.getBukkitEntity().getWorld())); // Leaves - render bot
+                }
+                // Leaves end - bot support
+
                 // CraftBukkit start
                 PlayerChangedWorldEvent changeEvent = new PlayerChangedWorldEvent(this.getBukkitEntity(), worldserver1.getWorld());
                 this.level().getCraftServer().getPluginManager().callEvent(changeEvent);
                 // CraftBukkit end
+                // Leaves start - nether portal fix
+                if (top.leavesmc.leaves.LeavesConfig.netherPortalFix) {
+                    final ResourceKey<Level> fromDim = worldserver1.dimension();
+                    final ResourceKey<Level> toDim = level().dimension();
+                    final ResourceKey<Level> OVERWORLD = Level.OVERWORLD;
+                    final ResourceKey<Level> THE_NETHER = Level.NETHER;
+                    if (!((fromDim != OVERWORLD || toDim != THE_NETHER) && (fromDim != THE_NETHER || toDim != OVERWORLD))) {
+                        BlockPos lastPos = this.lastPos;
+                        if (lastPos != null) {
+                            BlockUtil.FoundRectangle fromPortal = ReturnPortalManager.findPortalAt(this, fromDim, lastPos);
+                            BlockPos toPos = this.blockPosition();
+                            if (fromPortal != null) {
+                                ReturnPortalManager.storeReturnPortal(this, toDim, toPos, fromPortal);
+                            }
+                        }
+                    }
+                }
+                // Leaves end - nether portal fix
             }
             // Paper start
             if (this.isBlocking()) {
@@ -1320,6 +1357,30 @@ public class ServerPlayer extends Player {
     protected Optional<BlockUtil.FoundRectangle> getExitPortal(ServerLevel worldserver, BlockPos blockposition, boolean flag, WorldBorder worldborder, int searchRadius, boolean canCreatePortal, int createRadius) { // CraftBukkit
         Optional<BlockUtil.FoundRectangle> optional = super.getExitPortal(worldserver, blockposition, flag, worldborder, searchRadius, canCreatePortal, createRadius); // CraftBukkit
 
+        // Leaves start - nether portal fix
+        if (top.leavesmc.leaves.LeavesConfig.netherPortalFix) {
+            BlockPos fromPos = blockPosition();
+            final ResourceKey<Level> fromDim = level().dimension();
+            final ResourceKey<Level> toDim = level().dimension();
+            final ResourceKey<Level> OVERWORLD = Level.OVERWORLD;
+            final ResourceKey<Level> THE_NETHER = Level.NETHER;
+            boolean isTeleportBetweenNetherAndOverworld = (fromDim == OVERWORLD && toDim == THE_NETHER)
+                || (fromDim == THE_NETHER && toDim == OVERWORLD);
+            if (isInsidePortal && isTeleportBetweenNetherAndOverworld) {
+                ReturnPortalManager.ReturnPortal returnPortal = ReturnPortalManager.findReturnPortal(this, fromDim, fromPos);
+                if (returnPortal != null) {
+                    MinecraftServer server = getServer();
+                    if (server != null) {
+                        Level toLevel = server.getLevel(toDim);
+                        if (toLevel != null) {
+                            return Optional.of(returnPortal.rectangle());
+                        }
+                    }
+                }
+            }
+        }
+        // Leaves end - nether portal fix
+
         if (optional.isPresent() || !canCreatePortal) { // CraftBukkit
             return optional;
         } else {
@@ -1907,6 +1968,7 @@ public class ServerPlayer extends Player {
     public void moveTo(double x, double y, double z) {
         super.moveTo(x, y, z);
         this.connection.resetPosition();
+        if (top.leavesmc.leaves.LeavesConfig.fixPaper9372) this.mainSupportingBlockPos = Optional.empty(); // Leaves - fix paper 9372
     }
 
     @Override
@@ -2143,6 +2205,7 @@ public class ServerPlayer extends Player {
 
             this.connection.send(new ClientboundSetCameraPacket(this.camera));
             this.connection.resetPosition();
+            if (top.leavesmc.leaves.LeavesConfig.fixPaper9372) this.mainSupportingBlockPos = Optional.empty(); // Leaves - fix paper 9372
         }
     }
 
@@ -2595,6 +2658,7 @@ public class ServerPlayer extends Player {
     public void forceSetPositionRotation(double x, double y, double z, float yaw, float pitch) {
         this.moveTo(x, y, z, yaw, pitch);
         this.connection.resetPosition();
+        if (top.leavesmc.leaves.LeavesConfig.fixPaper9372) this.mainSupportingBlockPos = Optional.empty(); // Leaves - fix paper 9372
     }
 
     @Override
@@ -2648,5 +2712,32 @@ public class ServerPlayer extends Player {
     public CraftPlayer getBukkitEntity() {
         return (CraftPlayer) super.getBukkitEntity();
     }
+
+    // Leaves start - player operation limiter
+    private void resetOperationCountPerTick() {
+        instaBreakCountPerTick = 0;
+        placeBlockCountPerTick = 0;
+    }
+
+    public int getInstaBreakCountPerTick() {
+        return instaBreakCountPerTick;
+    }
+
+    public int getPlaceBlockCountPerTick() {
+        return placeBlockCountPerTick;
+    }
+
+    public void addInstaBreakCountPerTick() {
+        ++instaBreakCountPerTick;
+    }
+
+    public void addPlaceBlockCountPerTick() {
+        ++placeBlockCountPerTick;
+    }
+
+    public boolean allowOperation() {
+        return (instaBreakCountPerTick == 0 || placeBlockCountPerTick == 0) && (instaBreakCountPerTick <= 1 && placeBlockCountPerTick <= 2);
+    }
+    // Leaves end - player operation limiter
     // CraftBukkit end
 }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
index baf3e79489e310f443788bc917c553ae7ea86c89..a13581eceb914e37a6a7843da60c26436548dfdd 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
@@ -44,6 +44,7 @@ import org.bukkit.event.Event;
 import org.bukkit.event.block.Action;
 import org.bukkit.event.player.PlayerGameModeChangeEvent;
 import org.bukkit.event.player.PlayerInteractEvent;
+import top.leavesmc.leaves.event.player.PlayerOperationLimitEvent;
 // CraftBukkit end
 
 public class ServerPlayerGameMode {
@@ -334,6 +335,19 @@ public class ServerPlayerGameMode {
     }
 
     public void destroyAndAck(BlockPos pos, int sequence, String reason) {
+        // Leaves start - player operation limiter
+        if (top.leavesmc.leaves.LeavesConfig.playerOperationLimiter) {
+            if (reason.equals("insta mine")) {
+                player.addInstaBreakCountPerTick();
+                if (!player.allowOperation()) {
+                    MinecraftServer.getServer().server.getPluginManager().callEvent(new PlayerOperationLimitEvent(player.getBukkitEntity(), PlayerOperationLimitEvent.Operation.MINE, CraftBlock.at(level, pos)));
+                    this.player.connection.send(new ClientboundBlockUpdatePacket(pos, this.level.getBlockState(pos)));
+                    this.debugLogging(pos, false, sequence, reason);
+                    return;
+                }
+            }
+        }
+        // Leaves end - player operation limiter
         if (this.destroyBlock(pos)) {
             this.debugLogging(pos, true, sequence, reason);
         } else {
diff --git a/src/main/java/net/minecraft/server/level/WorldGenRegion.java b/src/main/java/net/minecraft/server/level/WorldGenRegion.java
index 877498729c66de9aa6a27c9148f7494d7895615c..28386146cada17442d3b3f1517512b95ddcc6a9f 100644
--- a/src/main/java/net/minecraft/server/level/WorldGenRegion.java
+++ b/src/main/java/net/minecraft/server/level/WorldGenRegion.java
@@ -83,6 +83,10 @@ public class WorldGenRegion implements WorldGenLevel {
     private Supplier<String> currentlyGenerating;
     private final AtomicLong subTickCount = new AtomicLong();
     private static final ResourceLocation WORLDGEN_REGION_RANDOM = new ResourceLocation("worldgen_region_random");
+    // Leaves start - optimize world generation chunk and block access
+    private ChunkAccess[] chunksArr;
+    private int minChunkX, minChunkZ;
+    // Leaves end - optimize world generation chunk and block access
 
     public WorldGenRegion(ServerLevel world, List<ChunkAccess> chunks, ChunkStatus status, int placementRadius) {
         this.generatingStatus = status;
@@ -105,6 +109,11 @@ public class WorldGenRegion implements WorldGenLevel {
             this.lastPos = ((ChunkAccess) chunks.get(chunks.size() - 1)).getPos();
             this.structureManager = world.structureManager().forWorldGenRegion(this);
         }
+        // Leaves start - optimize world generation chunk and block access
+        this.minChunkX = this.firstPos.x;
+        this.minChunkZ = this.firstPos.z;
+        this.chunksArr = chunks.toArray(new ChunkAccess[0]);
+        // Leaves end - optimize world generation chunk and block access
     }
 
     public boolean isOldChunkAround(ChunkPos chunkPos, int checkRadius) {
@@ -122,8 +131,29 @@ public class WorldGenRegion implements WorldGenLevel {
 
     @Override
     public ChunkAccess getChunk(int chunkX, int chunkZ) {
-        return this.getChunk(chunkX, chunkZ, ChunkStatus.EMPTY);
+        // Leaves start - optimize world generation chunk and block access
+        if (!top.leavesmc.leaves.LeavesConfig.optimizeWorldGenerationAccess) {
+            return this.getChunk(chunkX, chunkZ, ChunkStatus.EMPTY);
+        } else {
+            int x = chunkX - this.minChunkX;
+            int z = chunkZ - this.minChunkZ;
+            int w = this.size;
+
+            if (x >= 0 && z >= 0 && x < w && z < w) {
+                return this.chunksArr[x + z * w];
+            } else {
+                throw new NullPointerException("No chunk exists at " + new ChunkPos(chunkX, chunkZ));
+            }
+        }
+        // Leaves end - optimize world generation chunk and block access
+    }
+
+    // Leaves start - optimize world generation chunk and block access
+    public ChunkAccess getChunk(BlockPos pos) {
+        // Skip checking chunk.getStatus().isAtLeast(ChunkStatus.EMPTY) here, because it is always true
+        return this.getChunk(SectionPos.blockToSectionCoord(pos.getX()), SectionPos.blockToSectionCoord(pos.getZ()));
     }
+    // Leaves end - optimize world generation chunk and block access
 
     @Nullable
     @Override
@@ -182,7 +212,21 @@ public class WorldGenRegion implements WorldGenLevel {
 
     @Override
     public BlockState getBlockState(BlockPos pos) {
-        return this.getChunk(SectionPos.blockToSectionCoord(pos.getX()), SectionPos.blockToSectionCoord(pos.getZ())).getBlockState(pos);
+        // Leaves start - optimize world generation chunk and block access
+        if (!top.leavesmc.leaves.LeavesConfig.optimizeWorldGenerationAccess) {
+            return this.getChunk(SectionPos.blockToSectionCoord(pos.getX()), SectionPos.blockToSectionCoord(pos.getZ())).getBlockState(pos);
+        } else {
+            int x = SectionPos.blockToSectionCoord(pos.getX()) - this.minChunkX;
+            int z = SectionPos.blockToSectionCoord(pos.getZ()) - this.minChunkZ;
+            int w = this.size;
+
+            if (x >= 0 && z >= 0 && x < w && z < w) {
+                return this.chunksArr[x + z * w].getBlockState(pos);
+            } else {
+                throw new NullPointerException("No chunk exists at " + new ChunkPos(pos));
+            }
+        }
+        // Leaves end - optimize world generation chunk and block access
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 316740b2ba4c85828f544249c8cdd6fa1b525d3f..18f6eaefb4db548c08afb053ef7df37890036141 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -245,7 +245,9 @@ import org.bukkit.inventory.CraftingInventory;
 import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.inventory.InventoryView;
 import org.bukkit.inventory.SmithingInventory;
+import top.leavesmc.leaves.util.ProtocolUtils;
 // CraftBukkit end
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public class ServerGamePacketListenerImpl implements ServerPlayerConnection, TickablePacketListener, ServerGamePacketListener {
 
@@ -321,6 +323,12 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
         this.chatMessageChain = new FutureChain(server.chatExecutor); // CraftBukkit - async chat
         // CraftBukkit start - add fields and methods
         this.cserver = server.server;
+        // Leaves start - Syncmatica Protocol
+        this.exchangeTarget = new top.leavesmc.leaves.protocol.syncmatica.exchange.ExchangeTarget(this);
+        if (top.leavesmc.leaves.LeavesConfig.syncmaticaProtocol) {
+            top.leavesmc.leaves.protocol.syncmatica.SyncmaticaProtocol.getCommunicationManager().onPlayerJoin(exchangeTarget, player);
+        }
+        // Leaves end - Syncmatica Protocol
     }
 
     private final org.bukkit.craftbukkit.CraftServer cserver;
@@ -345,6 +353,8 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
     }
     // CraftBukkit end
 
+    public final top.leavesmc.leaves.protocol.syncmatica.exchange.ExchangeTarget exchangeTarget; // Leaves - Syncmatica Protocol
+
     @Override
     public void tick() {
         if (this.ackBlockChangesUpTo > -1) {
@@ -404,7 +414,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
         if (this.keepAlivePending) {
             if (!this.processedDisconnect && elapsedTime >= KEEPALIVE_LIMIT) { // check keepalive limit, don't fire if already disconnected
                 ServerGamePacketListenerImpl.LOGGER.warn("{} was kicked due to keepalive timeout!", this.player.getScoreboardName()); // more info
-                this.disconnect(Component.translatable("disconnect.timeout", new Object[0]), org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT); // Paper - kick event cause
+                this.disconnect(Component.translatable("disconnect.timeout", ArrayConstants.emptyObjectArray), org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT); // Paper - kick event cause // Leaves - reduce array allocations
             }
         } else {
             if (elapsedTime >= 15000L) { // 15 seconds
@@ -644,7 +654,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
                 speed *= 2f; // TODO: Get the speed of the vehicle instead of the player
 
                 // Paper start - Prevent moving into unloaded chunks
-                if (this.player.level().paperConfig().chunks.preventMovingIntoUnloadedChunks && (
+                if (this.player.level().paperConfig().chunks.preventMovingIntoUnloadedChunks && !player.elytraAeronauticsNoChunk && ( // Leaves - no chunk load
                     !worldserver.areChunksLoadedForMove(this.player.getBoundingBox().expandTowards(new Vec3(toX, toY, toZ).subtract(this.player.position()))) ||
                         !worldserver.areChunksLoadedForMove(entity.getBoundingBox().expandTowards(new Vec3(toX, toY, toZ).subtract(entity.position())))
                     )) {
@@ -883,13 +893,13 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
         // PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // Paper - run this async
         // CraftBukkit start
         if (this.chatSpamTickCount.addAndGet(io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.tabSpamIncrement) > io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.tabSpamLimit && !this.server.getPlayerList().isOp(this.player.getGameProfile())) { // Paper start - split and make configurable
-            server.scheduleOnMain(() -> this.disconnect(Component.translatable("disconnect.spam", new Object[0]), org.bukkit.event.player.PlayerKickEvent.Cause.SPAM)); // Paper - kick event cause
+            server.scheduleOnMain(() -> this.disconnect(Component.translatable("disconnect.spam", ArrayConstants.emptyObjectArray), org.bukkit.event.player.PlayerKickEvent.Cause.SPAM)); // Paper - kick event cause // Leaves - reduce array allocations
             return;
         }
         // Paper start
         String str = packet.getCommand(); int index = -1;
         if (str.length() > 64 && ((index = str.indexOf(' ')) == -1 || index >= 64)) {
-            server.scheduleOnMain(() -> this.disconnect(Component.translatable("disconnect.spam", new Object[0]), org.bukkit.event.player.PlayerKickEvent.Cause.SPAM)); // Paper
+            server.scheduleOnMain(() -> this.disconnect(Component.translatable("disconnect.spam", ArrayConstants.emptyObjectArray), org.bukkit.event.player.PlayerKickEvent.Cause.SPAM)); // Paper - kick event cause // Leaves - reduce array allocations
             return;
         }
         // Paper end
@@ -1948,7 +1958,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
                 Vec3 vec3d2 = vec3d.subtract(vec3d1);
                 double d0 = 1.0000001D;
 
-                if (Math.abs(vec3d2.x()) < 1.0000001D && Math.abs(vec3d2.y()) < 1.0000001D && Math.abs(vec3d2.z()) < 1.0000001D) {
+                if (top.leavesmc.leaves.LeavesConfig.disableDistanceCheckForUseItem || (Math.abs(vec3d2.x()) < 1.0000001D && Math.abs(vec3d2.y()) < 1.0000001D && Math.abs(vec3d2.z()) < 1.0000001D)) { // Leaves - disable check
                     Direction enumdirection = movingobjectpositionblock.getDirection();
 
                     this.player.resetLastActionTime();
@@ -2110,6 +2120,11 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
             this.processedDisconnect = true;
         }
         // CraftBukkit end
+        // Leaves start - Syncmatica Protocol
+        if (top.leavesmc.leaves.LeavesConfig.syncmaticaProtocol) {
+            top.leavesmc.leaves.protocol.syncmatica.SyncmaticaProtocol.getCommunicationManager().onPlayerLeave(exchangeTarget);
+        }
+        // Leaves end - Syncmatica Protocol
         this.chatMessageChain.close();
         ServerGamePacketListenerImpl.LOGGER.info("{} lost connection: {}", this.player.getName().getString(), reason.getString());
         // CraftBukkit start - Replace vanilla quit message handling with our own.
@@ -2145,10 +2160,27 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
 
     @Override
     public void send(Packet<?> packet) {
+        // Leaves start - no ClientboundPlayerChatHeaderPacket and rebuild ClientboundPlayerChatPacket
+        if (top.leavesmc.leaves.LeavesConfig.noChatSign) {
+            if (packet instanceof ClientboundPlayerChatPacket chat) {
+                packet = new ClientboundSystemChatPacket(chat.chatType().resolve(this.player.level().registryAccess())
+                    .get().decorate(chat.unsignedContent() != null ? chat.unsignedContent()
+                        : Component.literal(chat.body().content())), false);
+            }
+        }
+        // Leaves end - no ClientboundPlayerChatHeaderPacket and rebuild ClientboundPlayerChatPacket
         this.send(packet, (PacketSendListener) null);
     }
 
     public void send(Packet<?> packet, @Nullable PacketSendListener callbacks) {
+        // Leaves start - no ClientboundPlayerChatHeaderPacket and rebuild ClientboundPlayerChatPacket
+        if (top.leavesmc.leaves.LeavesConfig.noChatSign) {
+            if (packet instanceof ClientboundPlayerChatPacket chat && callbacks != null) {
+                this.send(chat);
+                return;
+            }
+        }
+        // Leaves end - no ClientboundPlayerChatHeaderPacket and rebuild ClientboundPlayerChatPacket
         // CraftBukkit start
         if (packet == null || this.processedDisconnect) { // Spigot
             return;
@@ -2330,7 +2362,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
     }
 
     private Optional<LastSeenMessages> tryHandleChat(String message, Instant timestamp, LastSeenMessages.Update acknowledgment) {
-        if (!this.updateChatOrder(timestamp)) {
+        if (!top.leavesmc.leaves.LeavesConfig.disableCheckOutOfOrderCommand && !this.updateChatOrder(timestamp)) { // Leaves - disable check to support Velocity
             ServerGamePacketListenerImpl.LOGGER.warn("{} sent out-of-order chat: '{}': {} > {}", this.player.getName().getString(), message, this.lastChatTimeStamp.get().getEpochSecond(), timestamp.getEpochSecond()); // Paper
             this.server.scheduleOnMain(() -> { // Paper - push to main
             this.disconnect(Component.translatable("multiplayer.disconnect.out_of_order_chat"), org.bukkit.event.player.PlayerKickEvent.Cause.OUT_OF_ORDER_CHAT); // Paper - kick event ca
@@ -3296,7 +3328,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
         // Paper start
         if (!org.bukkit.Bukkit.isPrimaryThread()) {
             if (this.recipeSpamPackets.addAndGet(io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.recipeSpamIncrement) > io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.recipeSpamLimit) {
-                this.server.scheduleOnMain(() -> this.disconnect(net.minecraft.network.chat.Component.translatable("disconnect.spam", new Object[0]), org.bukkit.event.player.PlayerKickEvent.Cause.SPAM)); // Paper - kick event cause
+                this.server.scheduleOnMain(() -> this.disconnect(net.minecraft.network.chat.Component.translatable("disconnect.spam", ArrayConstants.emptyObjectArray), org.bukkit.event.player.PlayerKickEvent.Cause.SPAM)); // Paper - kick event cause // Leaves - reduce array allocations
                 return;
             }
         }
@@ -3538,6 +3570,31 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
                 this.disconnect("Invalid payload UNREGISTER!", org.bukkit.event.player.PlayerKickEvent.Cause.INVALID_PAYLOAD); // Paper - kick event cause
             }
         } else {
+            // Leaves start - leaves extra protocol
+            try {
+                if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol && ProtocolUtils.isNamespacePacket(packet, top.leavesmc.leaves.protocol.PcaSyncProtocol.PROTOCOL_ID)) {
+                    top.leavesmc.leaves.protocol.PcaSyncProtocol.handlePacket(server, player, packet);
+                }
+                if (top.leavesmc.leaves.LeavesConfig.bborProtocol && packet.identifier.equals(top.leavesmc.leaves.protocol.BBORProtocol.SUBSCRIBE)) {
+                    top.leavesmc.leaves.protocol.BBORProtocol.onPlayerSubscribed(player);
+                }
+                if (top.leavesmc.leaves.LeavesConfig.jadeProtocol && ProtocolUtils.isNamespacePacket(packet, top.leavesmc.leaves.protocol.JadeProtocol.PROTOCOL_ID)) {
+                    top.leavesmc.leaves.protocol.JadeProtocol.handlePacket(server, player, packet);
+                }
+                if (top.leavesmc.leaves.LeavesConfig.syncmaticaProtocol && ProtocolUtils.isNamespacePacket(packet, top.leavesmc.leaves.protocol.syncmatica.SyncmaticaProtocol.PROTOCOL_ID)) {
+                    top.leavesmc.leaves.protocol.syncmatica.SyncmaticaProtocol.getCommunicationManager().onPacketGet(packet, this);
+                }
+                if (top.leavesmc.leaves.LeavesConfig.leavesCarpetSupport && ProtocolUtils.isNamespacePacket(packet, top.leavesmc.leaves.protocol.CarpetServerProtocol.PROTOCOL_ID)) {
+                    top.leavesmc.leaves.protocol.CarpetServerProtocol.handlePacket(player, packet);
+                }
+                if (top.leavesmc.leaves.LeavesConfig.msptSyncProtocol && ProtocolUtils.isNamespacePacket(packet, top.leavesmc.leaves.protocol.bladeren.MsptSyncProtocol.PROTOCOL_ID)) {
+                    top.leavesmc.leaves.protocol.bladeren.MsptSyncProtocol.handlePacket(player, packet);
+                }
+            } catch (Exception ex) {
+                ServerGamePacketListenerImpl.LOGGER.error("Couldn\'t dispatch custom payload", ex);
+                this.disconnect("Invalid custom payload!", org.bukkit.event.player.PlayerKickEvent.Cause.INVALID_PAYLOAD);
+            }
+            // Leaves end - leaves extra protocol
             try {
                 byte[] data = new byte[packet.data.readableBytes()];
                 packet.data.readBytes(data);
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 2ff578e4a953ffcf5176815ba8e3f06f73499989..bf082b9c3947d6037328526e5bfafe2bc3774d03 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -43,6 +43,7 @@ import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.player.AsyncPlayerPreLoginEvent;
 import org.bukkit.event.player.PlayerPreLoginEvent;
 // CraftBukkit end
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener, TickablePacketListener {
 
@@ -236,8 +237,10 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
 
     @Override
     public void handleHello(ServerboundHelloPacket packet) {
-        Validate.validState(this.state == ServerLoginPacketListenerImpl.State.HELLO, "Unexpected hello packet", new Object[0]);
-        Validate.validState(ServerLoginPacketListenerImpl.isValidUsername(packet.name()), "Invalid characters in username", new Object[0]);
+        // Gale start - JettPack - reduce array allocations
+        Validate.validState(this.state == ServerLoginPacketListenerImpl.State.HELLO, "Unexpected hello packet", ArrayConstants.emptyObjectArray);
+        Validate.validState(ServerLoginPacketListenerImpl.isValidUsername(packet.name()), "Invalid characters in username", ArrayConstants.emptyObjectArray);
+        // Gale end - JettPack - reduce array allocations
         // Paper start - validate usernames
         if (io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode() && io.papermc.paper.configuration.GlobalConfiguration.get().unsupportedSettings.performUsernameValidation) {
             if (!this.iKnowThisMayNotBeTheBestIdeaButPleaseDisableUsernameValidation && !validateUsername(packet.name())) {
@@ -296,7 +299,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
 
     @Override
     public void handleKey(ServerboundKeyPacket packet) {
-        Validate.validState(this.state == ServerLoginPacketListenerImpl.State.KEY, "Unexpected key packet", new Object[0]);
+        Validate.validState(this.state == ServerLoginPacketListenerImpl.State.KEY, "Unexpected key packet", ArrayConstants.emptyObjectArray); // Leaves - reduce array allocations
 
         final String s;
 
diff --git a/src/main/java/net/minecraft/server/network/ServerStatusPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerStatusPacketListenerImpl.java
index 2c13147bc063a09bb7907d6f90c3a1e811a09eb1..b6332639468dbfc3086f100809fdb3d471867d12 100644
--- a/src/main/java/net/minecraft/server/network/ServerStatusPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerStatusPacketListenerImpl.java
@@ -153,6 +153,12 @@ public class ServerStatusPacketListenerImpl implements ServerStatusPacketListene
             this.connection.send(new ClientboundStatusResponsePacket(ping));
             // CraftBukkit end
             */
+            // Leaves start - dont respond it before start full
+            var status = MinecraftServer.getServer().getStatus();
+            if (top.leavesmc.leaves.LeavesConfig.dontRespondPingBeforeStart && (status == null || status.version() == null || status.version().isEmpty())) {
+                return;
+            }
+            // Leaves end - dont respond it before start full
             com.destroystokyo.paper.network.StandardPaperServerListPingEventImpl.processRequest(MinecraftServer.getServer(), this.connection);
             // Paper end
         }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index fff7ad7a45f310783ac96b44575ad3db13d537fa..16670088947fe126674fa9058f4fc8df01546a2c 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -27,6 +27,8 @@ import java.util.UUID;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+
+import net.minecraft.BlockUtil;
 import net.minecraft.ChatFormatting;
 import net.minecraft.FileUtil;
 import net.minecraft.commands.CommandSourceStack;
@@ -81,6 +83,7 @@ import net.minecraft.server.ServerScoreboard;
 import net.minecraft.tags.BlockTags;
 import net.minecraft.tags.TagNetworkSerialization;
 import net.minecraft.util.Mth;
+import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.effect.MobEffectInstance;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
@@ -101,6 +104,7 @@ import net.minecraft.world.scores.Objective;
 import net.minecraft.world.scores.PlayerTeam;
 import net.minecraft.world.scores.Scoreboard; // Paper
 import net.minecraft.world.scores.Team;
+import top.leavesmc.leaves.bot.ServerBot;
 import org.slf4j.Logger;
 
 // CraftBukkit start
@@ -130,6 +134,9 @@ import org.bukkit.event.player.PlayerRespawnEvent.RespawnReason;
 import org.bukkit.event.player.PlayerSpawnChangeEvent;
 // CraftBukkit end
 
+import top.leavesmc.leaves.util.ArrayConstants;
+import top.leavesmc.leaves.util.ReturnPortalManager; // Leaves - return portal fix
+
 public abstract class PlayerList {
 
     public static final File USERBANLIST_FILE = new File("banned-players.json");
@@ -342,6 +349,26 @@ public abstract class PlayerList {
             return;
         }
 
+        // Leaves start - bot support
+        if (top.leavesmc.leaves.LeavesConfig.fakeplayerSupport) {
+            ServerBot bot = ServerBot.getBot(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT));
+            if (bot != null) {
+                bot.die(bot.damageSources().fellOutOfWorld()); // Leaves - remove bot with the same name
+                this.playersByName.put(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT), player);
+                this.playersByUUID.put(player.getUUID(), player);
+            }
+            ServerBot.getBots().forEach(bot1 ->
+                bot1.render(playerconnection, true,player.getBukkitEntity().getWorld() == bot1.getBukkitEntity().getWorld())); // Leaves - render bot
+        }
+        // Leaves end - bot support
+        top.leavesmc.leaves.protocol.PcaSyncProtocol.onJoin(player); // Leaves - pca
+        top.leavesmc.leaves.protocol.BBORProtocol.onPlayerLoggedIn(player); // Leaves - bbor
+        top.leavesmc.leaves.protocol.JadeProtocol.onPlayerJoin(player); // Leaves - Jade
+        top.leavesmc.leaves.protocol.AppleSkinProtocol.onPlayerLoggedIn(player); // Leaves - appleskin
+        top.leavesmc.leaves.protocol.CarpetServerProtocol.onPlayerJoin(player); // Leaves - carpet
+        top.leavesmc.leaves.protocol.bladeren.MsptSyncProtocol.onPlayerJoin(player); // Leaves - mspt sync
+        top.leavesmc.leaves.protocol.bladeren.LeavesProtocol.onPlayerJoin(player); // Leaves - leaves protocol
+
         final net.kyori.adventure.text.Component jm = playerJoinEvent.joinMessage();
 
         if (jm != null && !jm.equals(net.kyori.adventure.text.Component.empty())) { // Paper - Adventure
@@ -584,6 +611,9 @@ public abstract class PlayerList {
         return this.remove(entityplayer, net.kyori.adventure.text.Component.translatable("multiplayer.player.left", net.kyori.adventure.text.format.NamedTextColor.YELLOW, io.papermc.paper.configuration.GlobalConfiguration.get().messages.useDisplayNameInQuitMessage ? entityplayer.getBukkitEntity().displayName() : PaperAdventure.asAdventure(entityplayer.getDisplayName())));
     }
     public net.kyori.adventure.text.Component remove(ServerPlayer entityplayer, net.kyori.adventure.text.Component leaveMessage) {
+        top.leavesmc.leaves.protocol.BBORProtocol.onPlayerLoggedOut(entityplayer); // Leaves - bbor
+        top.leavesmc.leaves.protocol.AppleSkinProtocol.onPlayerLoggedOut(entityplayer); // Leaves - appleskin
+        top.leavesmc.leaves.protocol.bladeren.MsptSyncProtocol.onPlayerLoggedOut(entityplayer); // Leaves - mspt sync
         // Paper end
         ServerLevel worldserver = entityplayer.serverLevel();
 
@@ -700,7 +730,7 @@ public abstract class PlayerList {
         while (iterator.hasNext()) {
             entityplayer = (ServerPlayer) iterator.next();
             this.save(entityplayer); // CraftBukkit - Force the player's inventory to be saved
-            entityplayer.connection.disconnect(Component.translatable("multiplayer.disconnect.duplicate_login", new Object[0]), org.bukkit.event.player.PlayerKickEvent.Cause.DUPLICATE_LOGIN); // Paper - kick event cause
+            entityplayer.connection.disconnect(Component.translatable("multiplayer.disconnect.duplicate_login", ArrayConstants.emptyObjectArray), org.bukkit.event.player.PlayerKickEvent.Cause.DUPLICATE_LOGIN); // Paper - kick event cause // Leaves - reduce array allocations
         }
 
         // Instead of kicking then returning, we need to store the kick reason
@@ -964,6 +994,24 @@ public abstract class PlayerList {
         if (fromWorld != location.getWorld()) {
             PlayerChangedWorldEvent event = new PlayerChangedWorldEvent(entityplayer.getBukkitEntity(), fromWorld);
             server.server.getPluginManager().callEvent(event);
+            // Leaves start - nether portal fix
+            if (top.leavesmc.leaves.LeavesConfig.netherPortalFix) {
+                final ResourceKey<Level> fromDim = entityplayer.level().dimension();
+                final ResourceKey<Level> toDim = entityplayer1.level().dimension();
+                final ResourceKey<Level> OVERWORLD = Level.OVERWORLD;
+                final ResourceKey<Level> THE_NETHER = Level.NETHER;
+                if (!((fromDim != OVERWORLD || toDim != THE_NETHER) && (fromDim != THE_NETHER || toDim != OVERWORLD))) {
+                    BlockPos lastPos = entityplayer1.lastPos;
+                    if (lastPos != null) {
+                        BlockUtil.FoundRectangle fromPortal = ReturnPortalManager.findPortalAt(entityplayer1, fromDim, lastPos);
+                        BlockPos toPos = entityplayer1.blockPosition();
+                        if (fromPortal != null) {
+                            ReturnPortalManager.storeReturnPortal(entityplayer1, toDim, toPos, fromPortal);
+                        }
+                    }
+                }
+            }
+            // Leaves end - nether portal fix
         }
 
         // Save player file again if they were disconnected
@@ -1087,11 +1135,16 @@ public abstract class PlayerList {
     }
 
     public String[] getPlayerNamesArray() {
-        String[] astring = new String[this.players.size()];
+        String[] astring = new String[this.players.size() + ServerBot.getBots().size()]; // Leaves - fakeplayer support
 
         for (int i = 0; i < this.players.size(); ++i) {
             astring[i] = ((ServerPlayer) this.players.get(i)).getGameProfile().getName();
         }
+        // Leaves start - fakeplayer support
+        for (int i = this.players.size(); i < astring.length; ++i) {
+            astring[i] = ((ServerPlayer) ServerBot.getBots().get(i - this.players.size())).getGameProfile().getName();
+        }
+        // Leaves end - fakeplayer support
 
         return astring;
     }
@@ -1248,6 +1301,7 @@ public abstract class PlayerList {
         player.connection.send(new ClientboundInitializeBorderPacket(worldborder));
         player.connection.send(new ClientboundSetTimePacket(world.getGameTime(), world.getDayTime(), world.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)));
         player.connection.send(new ClientboundSetDefaultSpawnPositionPacket(world.getSharedSpawnPos(), world.getSharedSpawnAngle()));
+        top.leavesmc.leaves.protocol.XaeroMapProtocol.onSendWorldInfo(player); // Leaves - xaero map protocol
         if (world.isRaining()) {
             // CraftBukkit start - handle player weather
             // entityplayer.connection.send(new PacketPlayOutGameStateChange(PacketPlayOutGameStateChange.START_RAINING, 0.0F));
@@ -1431,7 +1485,7 @@ public abstract class PlayerList {
     }
 
     public boolean verifyChatTrusted(PlayerChatMessage message) { // Paper - private -> public
-        return message.hasSignature() && !message.hasExpiredServer(Instant.now());
+        return top.leavesmc.leaves.LeavesConfig.noChatSign || (message.hasSignature() && !message.hasExpiredServer(Instant.now())); // Leaves - No Not Secure
     }
 
     // CraftBukkit start
@@ -1549,10 +1603,22 @@ public abstract class PlayerList {
             entityplayer.connection.send(packetplayoutrecipeupdate);
             entityplayer.getRecipeBook().sendInitialRecipeBook(entityplayer);
         }
-
+        top.leavesmc.leaves.protocol.BBORProtocol.onDataPackReload(); // Leaves - bbor
     }
 
     public boolean isAllowCheatsForAllPlayers() {
         return this.allowCheatsForAllPlayers;
     }
+
+    // Leaves start - fakeplayer support
+    public void addNewBot(ServerBot bot) {
+        playersByName.put(bot.getScoreboardName().toLowerCase(java.util.Locale.ROOT), bot);
+        playersByUUID.put(bot.getUUID(), bot);
+    }
+
+    public void removeBot(ServerBot bot) {
+        playersByName.remove(bot.getScoreboardName().toLowerCase(java.util.Locale.ROOT));
+        playersByUUID.remove(bot.getUUID());
+    }
+    // Leaves end - fakeplayer support
 }
diff --git a/src/main/java/net/minecraft/server/players/StoredUserList.java b/src/main/java/net/minecraft/server/players/StoredUserList.java
index 9e8112fbc40a1d89c0f73ea4452e0fa1bb459bf4..fbca8ae92a91673e1ebc45c7587e0d847698e2d3 100644
--- a/src/main/java/net/minecraft/server/players/StoredUserList.java
+++ b/src/main/java/net/minecraft/server/players/StoredUserList.java
@@ -27,6 +27,7 @@ import javax.annotation.Nullable;
 import net.minecraft.Util;
 import net.minecraft.util.GsonHelper;
 import org.slf4j.Logger;
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public abstract class StoredUserList<K, V extends StoredUserEntry<K>> {
 
@@ -96,7 +97,7 @@ public abstract class StoredUserList<K, V extends StoredUserEntry<K>> {
     }
 
     public String[] getUserList() {
-        return (String[]) this.map.keySet().toArray(new String[0]);
+        return (String[]) this.map.keySet().toArray(ArrayConstants.emptyStringArray); // Leaves - reduce array allocations
     }
 
     public boolean isEmpty() {
diff --git a/src/main/java/net/minecraft/util/BitStorage.java b/src/main/java/net/minecraft/util/BitStorage.java
index 8bafd5fd7499ba4a04bf706cfd1e156073716e21..7082022412dc75e3d84c74acd19bb8452e477d0c 100644
--- a/src/main/java/net/minecraft/util/BitStorage.java
+++ b/src/main/java/net/minecraft/util/BitStorage.java
@@ -1,6 +1,7 @@
 package net.minecraft.util;
 
 import java.util.function.IntConsumer;
+import net.minecraft.world.level.chunk.Palette;
 
 public interface BitStorage {
     int getAndSet(int index, int value);
@@ -31,4 +32,6 @@ public interface BitStorage {
 
     }
     // Paper end
+
+    <T> void compact(Palette<T> srcPalette, Palette<T> dstPalette, short[] out); // Leaves - faster chunk serialization
 }
diff --git a/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java b/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
index 50a9f33aa31e9273c7c52d4bb2b02f0f884f7ba5..820343861893a0aba55ede10ac2a2594de4438d0 100644
--- a/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
+++ b/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
@@ -13,7 +13,7 @@ import java.util.Map;
 import java.util.stream.Collectors;
 
 public class ClassInstanceMultiMap<T> extends AbstractCollection<T> {
-    private final Map<Class<?>, List<T>> byClass = Maps.newHashMap();
+    private final Map<Class<?>, List<T>> byClass = top.leavesmc.leaves.LeavesConfig.useOptimizedCollection ? new it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap<>(2) : Maps.newHashMap(); // Leaves - replace class map with optimized collection
     private final Class<T> baseClass;
     private final List<T> allInstances = Lists.newArrayList();
 
@@ -55,14 +55,24 @@ public class ClassInstanceMultiMap<T> extends AbstractCollection<T> {
     }
 
     public <S> Collection<S> find(Class<S> type) {
-        if (!this.baseClass.isAssignableFrom(type)) {
-            throw new IllegalArgumentException("Don't know how to search for " + type);
-        } else {
-            List<? extends T> list = this.byClass.computeIfAbsent(type, (typeClass) -> {
-                return this.allInstances.stream().filter(typeClass::isInstance).collect(Collectors.toList());
-            });
-            return Collections.unmodifiableCollection(list);
+        // Leaves start - avoid Class#isAssignableFrom call in ClassInstanceMultiMap
+        Collection<T> collection = this.byClass.get(type);
+        if (collection == null) {
+            collection = this.createAllOfType(type);
         }
+        return (Collection<S>) Collections.unmodifiableCollection(collection);
+    }
+
+    private <S> Collection<T> createAllOfType(Class<S> type) {
+        List<T> list = new java.util.ArrayList<>(1);
+        for (T allElement : this.allInstances) {
+            if (type.isInstance(allElement)) {
+                list.add(allElement);
+            }
+        }
+        this.byClass.put(type, list);
+        return list;
+        // Leaves end - avoid Class#isAssignableFrom call in ClassInstanceMultiMap
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/util/RandomSource.java b/src/main/java/net/minecraft/util/RandomSource.java
index ff1ad1024419182f7f3de578442c1c033d4c9ebb..d93f3eeea17d58ccc01c6010b2d49f813dc0d85f 100644
--- a/src/main/java/net/minecraft/util/RandomSource.java
+++ b/src/main/java/net/minecraft/util/RandomSource.java
@@ -55,7 +55,14 @@ public interface RandomSource {
     double nextGaussian();
 
     default double triangle(double mode, double deviation) {
-        return mode + deviation * (this.nextDouble() - this.nextDouble());
+        // Leaves start - flattenTriangularDistribution
+        if (top.leavesmc.leaves.LeavesConfig.flattenTriangularDistribution) {
+            this.nextDouble();
+            return mode + deviation * (-1 + this.nextDouble() * 2);
+        } else {
+            return mode + deviation * (this.nextDouble() - this.nextDouble());
+        }
+        // Leaves end - flattenTriangularDistribution
     }
 
     default void consumeCount(int count) {
diff --git a/src/main/java/net/minecraft/util/SimpleBitStorage.java b/src/main/java/net/minecraft/util/SimpleBitStorage.java
index e4d0d7e8fc58b8f9f614d74a141e452166e0364c..efe0a8b008d25a4c396bc9945d6466b672bc209b 100644
--- a/src/main/java/net/minecraft/util/SimpleBitStorage.java
+++ b/src/main/java/net/minecraft/util/SimpleBitStorage.java
@@ -3,6 +3,7 @@ package net.minecraft.util;
 import java.util.function.IntConsumer;
 import javax.annotation.Nullable;
 import org.apache.commons.lang3.Validate;
+import net.minecraft.world.level.chunk.Palette;
 
 public class SimpleBitStorage implements BitStorage {
     private static final int[] MAGIC = new int[]{-1, -1, 0, Integer.MIN_VALUE, 0, 0, 1431655765, 1431655765, 0, Integer.MIN_VALUE, 0, 1, 858993459, 858993459, 0, 715827882, 715827882, 0, 613566756, 613566756, 0, Integer.MIN_VALUE, 0, 2, 477218588, 477218588, 0, 429496729, 429496729, 0, 390451572, 390451572, 0, 357913941, 357913941, 0, 330382099, 330382099, 0, 306783378, 306783378, 0, 286331153, 286331153, 0, Integer.MIN_VALUE, 0, 3, 252645135, 252645135, 0, 238609294, 238609294, 0, 226050910, 226050910, 0, 214748364, 214748364, 0, 204522252, 204522252, 0, 195225786, 195225786, 0, 186737708, 186737708, 0, 178956970, 178956970, 0, 171798691, 171798691, 0, 165191049, 165191049, 0, 159072862, 159072862, 0, 153391689, 153391689, 0, 148102320, 148102320, 0, 143165576, 143165576, 0, 138547332, 138547332, 0, Integer.MIN_VALUE, 0, 4, 130150524, 130150524, 0, 126322567, 126322567, 0, 122713351, 122713351, 0, 119304647, 119304647, 0, 116080197, 116080197, 0, 113025455, 113025455, 0, 110127366, 110127366, 0, 107374182, 107374182, 0, 104755299, 104755299, 0, 102261126, 102261126, 0, 99882960, 99882960, 0, 97612893, 97612893, 0, 95443717, 95443717, 0, 93368854, 93368854, 0, 91382282, 91382282, 0, 89478485, 89478485, 0, 87652393, 87652393, 0, 85899345, 85899345, 0, 84215045, 84215045, 0, 82595524, 82595524, 0, 81037118, 81037118, 0, 79536431, 79536431, 0, 78090314, 78090314, 0, 76695844, 76695844, 0, 75350303, 75350303, 0, 74051160, 74051160, 0, 72796055, 72796055, 0, 71582788, 71582788, 0, 70409299, 70409299, 0, 69273666, 69273666, 0, 68174084, 68174084, 0, Integer.MIN_VALUE, 0, 5};
@@ -201,4 +202,44 @@ public class SimpleBitStorage implements BitStorage {
             super(message);
         }
     }
+
+    // Leaves start - faster chunk serialization
+    @Override
+    public <T> void compact(Palette<T> srcPalette, Palette<T> dstPalette, short[] out) {
+        if (this.size >= Short.MAX_VALUE) {
+            throw new IllegalStateException("Array too large");
+        }
+
+        if (this.size != out.length) {
+            throw new IllegalStateException("Array size mismatch");
+        }
+
+        short[] mappings = new short[(int) (this.mask + 1)];
+
+        int idx = 0;
+
+        for (long word : this.data) {
+            long bits = word;
+
+            for (int elementIdx = 0; elementIdx < this.valuesPerLong; ++elementIdx) {
+                int value = (int) (bits & this.mask);
+                int remappedId = mappings[value];
+
+                if (remappedId == 0) {
+                    remappedId = dstPalette.idFor(srcPalette.valueFor(value)) + 1;
+                    mappings[value] = (short) remappedId;
+                }
+
+                out[idx] = (short) (remappedId - 1);
+                bits >>= this.bits;
+
+                ++idx;
+
+                if (idx >= this.size) {
+                    return;
+                }
+            }
+        }
+    }
+    // Leaves end - faster chunk serialization
 }
diff --git a/src/main/java/net/minecraft/util/ZeroBitStorage.java b/src/main/java/net/minecraft/util/ZeroBitStorage.java
index 311625277a26c9c187025a1036978229241b965f..53e81721507cfc8f88be0ca9565746d78b2a1686 100644
--- a/src/main/java/net/minecraft/util/ZeroBitStorage.java
+++ b/src/main/java/net/minecraft/util/ZeroBitStorage.java
@@ -3,9 +3,11 @@ package net.minecraft.util;
 import java.util.Arrays;
 import java.util.function.IntConsumer;
 import org.apache.commons.lang3.Validate;
+import net.minecraft.world.level.chunk.Palette;
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public class ZeroBitStorage implements BitStorage {
-    public static final long[] RAW = new long[0];
+    public static final long[] RAW = ArrayConstants.emptyLongArray; // Leaves - reduce array allocations
     private final int size;
 
     public ZeroBitStorage(int size) {
@@ -72,4 +74,6 @@ public class ZeroBitStorage implements BitStorage {
     public BitStorage copy() {
         return this;
     }
+
+    @Override public <T> void compact(Palette<T> srcPalette, Palette<T> dstPalette, short[] out) {}  // Leaves - faster chunk serialization
 }
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 4c298406ce06d39f8279049270c88ec0830733b1..515b90384ce5a168496635226f4df92ea3a7a915 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -306,7 +306,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public double yo;
     public double zo;
     private Vec3 position;
-    private BlockPos blockPosition;
+    public BlockPos blockPosition; // Leaves - private -> public
     private ChunkPos chunkPosition;
     private Vec3 deltaMovement;
     private float yRot;
@@ -314,6 +314,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public float yRotO;
     public float xRotO;
     private AABB bb;
+    private boolean boundingBoxChanged = false; // Leaves - skip entity move if movement is zero
     public boolean onGround;
     public boolean horizontalCollision;
     public boolean verticalCollision;
@@ -417,6 +418,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     private UUID originWorld;
     public boolean freezeLocked = false; // Paper - Freeze Tick Lock API
     public boolean collidingWithWorldBorder; // Paper
+    private CompoundTag leavesData = new CompoundTag(); // Leaves - Leaves ex data
 
     public void setOrigin(@javax.annotation.Nonnull Location location) {
         this.origin = location.toVector();
@@ -433,6 +435,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         return this.originWorld;
     }
     // Paper end
+    // public final BlockPos.MutableBlockPos cachedBlockPos = new BlockPos.MutableBlockPos(); // Leaves - used where needed ?
+
     public float getBukkitYaw() {
         return this.yRot;
     }
@@ -507,59 +511,56 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         this.isLegacyTrackingEntity = isLegacyTrackingEntity;
     }
 
+    // Leaves start - better metond
+    private org.spigotmc.TrackingRange.TrackingRangeType getFurthestEntity(Entity entity, net.minecraft.server.level.ChunkMap chunkMap, org.spigotmc.TrackingRange.TrackingRangeType type, int range) {
+        List<Entity> passengers = entity.getPassengers();
+        for (int i = 0, size = passengers.size(); i < size; i++) {
+            Entity passenger = passengers.get(i);
+            org.spigotmc.TrackingRange.TrackingRangeType passengerType = passenger.trackingRangeType;
+            int passengerRange = chunkMap.getEntityTrackerRange(passengerType.ordinal());
+            if (passengerRange > range) {
+                type = passengerType;
+                range = passengerRange;
+            }
+
+            type = this.getFurthestEntity(passenger, chunkMap, type, range);
+        }
+
+        return type;
+    }
+    // Leaves end - better metond
+
     public final com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> getPlayersInTrackRange() {
         // determine highest range of passengers
         if (this.passengers.isEmpty()) {
             return ((ServerLevel)this.level).getChunkSource().chunkMap.playerEntityTrackerTrackMaps[this.trackingRangeType.ordinal()]
                 .getObjectsInRange(MCUtil.getCoordinateKey(this));
         }
-        Iterable<Entity> passengers = this.getIndirectPassengers();
+        // Leaves start - use getFurthestEntity to skip getIndirectPassengers
         net.minecraft.server.level.ChunkMap chunkMap = ((ServerLevel)this.level).getChunkSource().chunkMap;
         org.spigotmc.TrackingRange.TrackingRangeType type = this.trackingRangeType;
         int range = chunkMap.getEntityTrackerRange(type.ordinal());
 
-        for (Entity passenger : passengers) {
-            org.spigotmc.TrackingRange.TrackingRangeType passengerType = passenger.trackingRangeType;
-            int passengerRange = chunkMap.getEntityTrackerRange(passengerType.ordinal());
-            if (passengerRange > range) {
-                type = passengerType;
-                range = passengerRange;
+        if (top.leavesmc.leaves.LeavesConfig.removeGetNearPlayerStreams) {
+            type = this.getFurthestEntity(this, chunkMap, type, range);
+        } else {
+            Iterable<Entity> passengers = this.getIndirectPassengers();
+            for (Entity passenger : passengers) {
+                org.spigotmc.TrackingRange.TrackingRangeType passengerType = passenger.trackingRangeType;
+                int passengerRange = chunkMap.getEntityTrackerRange(passengerType.ordinal());
+                if (passengerRange > range) {
+                    type = passengerType;
+                    range = passengerRange;
+                }
             }
         }
+        // Leaves end - use getFurthestEntity to skip getIndirectPassengers
 
         return chunkMap.playerEntityTrackerTrackMaps[type.ordinal()].getObjectsInRange(MCUtil.getCoordinateKey(this));
     }
     // Paper end - optimise entity tracking
-    // Paper start - make end portalling safe
-    public BlockPos portalBlock;
-    public ServerLevel portalWorld;
-    public void tickEndPortal() {
-        BlockPos pos = this.portalBlock;
-        ServerLevel world = this.portalWorld;
-        this.portalBlock = null;
-        this.portalWorld = null;
-
-        if (pos == null || world == null || world != this.level) {
-            return;
-        }
 
-        if (this.isPassenger() || this.isVehicle() || !this.canChangeDimensions() || this.isRemoved() || !this.valid || !this.isAlive()) {
-            return;
-        }
-
-        ResourceKey<Level> resourcekey = world.getTypeKey() == LevelStem.END ? Level.OVERWORLD : Level.END; // CraftBukkit - SPIGOT-6152: send back to main overworld in custom ends
-        ServerLevel worldserver = world.getServer().getLevel(resourcekey);
-
-        org.bukkit.event.entity.EntityPortalEnterEvent event = new org.bukkit.event.entity.EntityPortalEnterEvent(this.getBukkitEntity(), new org.bukkit.Location(world.getWorld(), pos.getX(), pos.getY(), pos.getZ()));
-        event.callEvent();
-
-        if (this instanceof ServerPlayer) {
-            ((ServerPlayer)this).changeDimension(worldserver, PlayerTeleportEvent.TeleportCause.END_PORTAL);
-            return;
-        }
-        this.teleportTo(worldserver, null);
-    }
-    // Paper end - make end portalling safe
+	// Leaves - fix gravity block duper
 
     public Entity(EntityType<?> type, Level world) {
         this.id = Entity.ENTITY_COUNTER.incrementAndGet();
@@ -568,7 +569,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         this.bb = Entity.INITIAL_AABB;
         this.stuckSpeedMultiplier = Vec3.ZERO;
         this.nextStep = 1.0F;
-        this.random = SHARED_RANDOM; // Paper
+        this.random = top.leavesmc.leaves.LeavesConfig.useVanillaRandom ? RandomSource.create() : SHARED_RANDOM; // Paper // Leaves - vanilla plz
         this.remainingFireTicks = -this.getFireImmuneTicks();
         this.fluidHeight = new Object2DoubleArrayMap(2);
         this.fluidOnEyes = new HashSet();
@@ -1066,6 +1067,13 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     // Paper end - detailed watchdog information
 
     public void move(MoverType movementType, Vec3 movement) {
+        // Leaves start - skip entity move if movement is zero
+        if (top.leavesmc.leaves.LeavesConfig.skipEntityMoveIfMovementIsZero) {
+            if (!this.boundingBoxChanged && movement.equals(Vec3.ZERO)) {
+                return;
+            }
+        }
+        // Leaves end - skip entity move if movement is zero
         // Paper start - detailed watchdog information
         io.papermc.paper.util.TickThread.ensureTickThread("Cannot move an entity off-main");
         synchronized (this.posLock) {
@@ -1088,7 +1096,13 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
                     return;
                 }
             }
-
+            // Leaves start - elytra aeronautics
+            if (top.leavesmc.leaves.LeavesConfig.elytraAeronauticsNoChunk && this instanceof Player player) {
+                if (movementType == MoverType.PLAYER && player.isFallFlying()) {
+                    top.leavesmc.leaves.util.ElytraAeronauticsHelper.flightBehaviour(player, movement);
+                }
+            }
+            // Leaves end - elytra aeronautics
             this.level().getProfiler().push("move");
             if (this.stuckSpeedMultiplier.lengthSqr() > 1.0E-7D) {
                 movement = movement.multiply(this.stuckSpeedMultiplier);
@@ -1223,9 +1237,16 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
                 }
 
                 this.tryCheckInsideBlocks();
-                float f = this.getBlockSpeedFactor();
-
-                this.setDeltaMovement(this.getDeltaMovement().multiply((double) f, 1.0D, (double) f));
+                // Leaves start - skip negligible planar movement multiplication
+                Vec3 oldDeltaMovement = this.getDeltaMovement();
+                if (!top.leavesmc.leaves.LeavesConfig.skipNegligiblePlanarMovementMultiplication ||
+                    (oldDeltaMovement.x < -1e-6 || oldDeltaMovement.x > 1e-6 || oldDeltaMovement.z < -1e-6 || oldDeltaMovement.z > 1e-6)) {
+                    float f = this.getBlockSpeedFactor();
+                    if (!top.leavesmc.leaves.LeavesConfig.skipNegligiblePlanarMovementMultiplication || (f < 1 - 1e-6 || f > 1 + 1e-6)) {
+                        this.setDeltaMovement(this.getDeltaMovement().multiply((double) f, 1.0D, (double) f));
+                    }
+                }
+                // Leaves end - skip negligible planar movement multiplication
                 // Paper start - remove expensive streams from here
                 boolean noneMatch = true;
                 AABB fireSearchBox = this.getBoundingBox().deflate(1.0E-6D);
@@ -1442,7 +1463,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         return offsetFactor;
     }
 
-    private Vec3 collide(Vec3 movement) {
+    public Vec3 collide(Vec3 movement) { // Leaves - private -> public
         // Paper start - optimise collisions
         // This is a copy of vanilla's except that it uses strictly AABB math
         if (movement.x == 0.0 && movement.y == 0.0 && movement.z == 0.0) {
@@ -1991,9 +2012,23 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     /** @deprecated */
     @Deprecated
     public float getLightLevelDependentMagicValue() {
-        return this.level().hasChunkAt(this.getBlockX(), this.getBlockZ()) ? this.level().getLightLevelDependentMagicValue(BlockPos.containing(this.getX(), this.getEyeY(), this.getZ())) : 0.0F;
+        // Leaves start - optimize sun burn tick
+        if (!top.leavesmc.leaves.LeavesConfig.optimizeSunBurnTick) {
+            return this.level().hasChunkAt(this.getBlockX(), this.getBlockZ()) ? this.level().getLightLevelDependentMagicValue(BlockPos.containing(this.getX(), this.getEyeY(), this.getZ())) : 0.0F;
+        } else {
+            return this.getLightLevelDependentMagicValue(BlockPos.containing(this.getX(), this.getEyeY(), this.getZ()));
+        }
+        // Leaves end - optimize sun burn tick
     }
 
+    // Leaves start - optimize sun burn tick
+    /** @deprecated */
+    @Deprecated
+    public float getLightLevelDependentMagicValue(BlockPos pos) {
+        return this.level().hasChunkAt(this.getBlockX(), this.getBlockZ()) ? this.level.getLightLevelDependentMagicValue(pos) : 0.0F;
+    }
+    // Leaves end - optimize sun burn tick
+
     public void absMoveTo(double x, double y, double z, float yaw, float pitch) {
         this.absMoveTo(x, y, z);
         this.setYRot(yaw % 360.0F);
@@ -2011,6 +2046,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         this.yo = y;
         this.zo = d4;
         this.setPos(d3, y, d4);
+        if (this instanceof Player player && player.elytraAeronauticsNoChunk) return; // Leaves - elytra aeronautics
         if (this.valid) this.level.getChunk((int) Math.floor(this.getX()) >> 4, (int) Math.floor(this.getZ()) >> 4); // CraftBukkit
     }
 
@@ -2437,6 +2473,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
                 nbt.putBoolean("Paper.FreezeLock", true);
             }
             // Paper end
+            nbt.put("Leaves.Data", leavesData); // Leaves - leaves ex data
             return nbt;
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.forThrowable(throwable, "Saving entity NBT");
@@ -2605,6 +2642,11 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
                 freezeLocked = nbt.getBoolean("Paper.FreezeLock");
             }
             // Paper end
+            // Leaves start - leaves ex data
+            if (nbt.contains("Leaves.Data")) {
+                leavesData = nbt.getCompound("Leaves.Data");
+            }
+            // Leaves end - leaves ex data
 
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.forThrowable(throwable, "Loading entity NBT");
@@ -3061,7 +3103,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
             }
 
             this.processPortalCooldown();
-            this.tickEndPortal(); // Paper - make end portalling safe
+			// Leaves - fix gravity block duper
         }
     }
 
@@ -3960,6 +4002,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     }
 
     public final void setBoundingBox(AABB boundingBox) {
+        if (!this.bb.equals(boundingBox)) this.boundingBoxChanged = true; // Leaves - skip entity move if movement is zero
         // CraftBukkit start - block invalid bounding boxes
         double minX = boundingBox.minX,
                 minY = boundingBox.minY,
@@ -4288,16 +4331,18 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     }
 
     public boolean updateFluidHeightAndDoFluidPushing(TagKey<Fluid> tag, double speed) {
-        if (this.touchingUnloadedChunk()) {
+        if (!top.leavesmc.leaves.LeavesConfig.reduceEntityFluidLookup && this.touchingUnloadedChunk()) { // Leaves - cost of a lookup here is the same cost as below, so skip
             return false;
         } else {
             AABB axisalignedbb = this.getBoundingBox().deflate(0.001D);
-            int i = Mth.floor(axisalignedbb.minX);
-            int j = Mth.ceil(axisalignedbb.maxX);
-            int k = Mth.floor(axisalignedbb.minY);
-            int l = Mth.ceil(axisalignedbb.maxY);
-            int i1 = Mth.floor(axisalignedbb.minZ);
-            int j1 = Mth.ceil(axisalignedbb.maxZ);
+            // Leaves start - rename
+            int minBlockX = Mth.floor(axisalignedbb.minX);
+            int maxBlockX = Mth.ceil(axisalignedbb.maxX);
+            int minBlockY = Mth.floor(axisalignedbb.minY);
+            int maxBlockY = Mth.ceil(axisalignedbb.maxY);
+            int minBlockZ = Mth.floor(axisalignedbb.minZ);
+            int maxBlockZ = Mth.ceil(axisalignedbb.maxZ);
+            // Leaves end
             double d1 = 0.0D;
             boolean flag = this.isPushedByFluid();
             boolean flag1 = false;
@@ -4305,38 +4350,123 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
             int k1 = 0;
             BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
 
-            for (int l1 = i; l1 < j; ++l1) {
-                for (int i2 = k; i2 < l; ++i2) {
-                    for (int j2 = i1; j2 < j1; ++j2) {
-                        blockposition_mutableblockposition.set(l1, i2, j2);
-                        FluidState fluid = this.level().getFluidState(blockposition_mutableblockposition);
+            // Leaves start - based off CollisionUtil.getCollisionsForBlocksOrWorldBorder
+            if (top.leavesmc.leaves.LeavesConfig.reduceEntityFluidLookup) {
+                final int minSection = io.papermc.paper.util.WorldUtil.getMinSection(this.level);
+                final int maxSection = io.papermc.paper.util.WorldUtil.getMaxSection(this.level);
+                final int minBlock = minSection << 4;
+                final int maxBlock = (maxSection << 4) | 15;
+
+                // special cases:
+                if (minBlockY > maxBlock || maxBlockY < minBlock) {
+                    // no point in checking
+                    return false;
+                }
+
+                int minYIterate = Math.max(minBlock, minBlockY);
+                int maxYIterate = Math.min(maxBlock, maxBlockY);
 
-                        if (fluid.is(tag)) {
-                            double d2 = (double) ((float) i2 + fluid.getHeight(this.level(), blockposition_mutableblockposition));
+                int minChunkX = minBlockX >> 4;
+                int maxChunkX = maxBlockX >> 4;
 
-                            if (d2 >= axisalignedbb.minY) {
-                                flag1 = true;
-                                d1 = Math.max(d2 - axisalignedbb.minY, d1);
-                                if (flag) {
-                                    Vec3 vec3d1 = fluid.getFlow(this.level(), blockposition_mutableblockposition);
+                int minChunkZ = minBlockZ >> 4;
+                int maxChunkZ = maxBlockZ >> 4;
 
-                                    if (d1 < 0.4D) {
-                                        vec3d1 = vec3d1.scale(d1);
-                                    }
+                for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
+                    int minZ = currChunkZ == minChunkZ ? minBlockZ & 15 : 0; // coordinate in chunk
+                    int maxZ = currChunkZ == maxChunkZ ? maxBlockZ & 15 : 16; // coordinate in chunk
+
+                    for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
+                        int minX = currChunkX == minChunkX ? minBlockX & 15 : 0; // coordinate in chunk
+                        int maxX = currChunkX == maxChunkX ? maxBlockX & 15 : 16; // coordinate in chunk
 
-                                    vec3d = vec3d.add(vec3d1);
-                                    ++k1;
+                        net.minecraft.world.level.chunk.ChunkAccess chunk = this.level.getChunkIfLoadedImmediately(currChunkX, currChunkZ);
+                        if (chunk == null) {
+                            return false; // if we're touching an unloaded chunk then it's false
+                        }
+
+                        net.minecraft.world.level.chunk.LevelChunkSection[] sections = chunk.getSections();
+
+                        for (int currY = minYIterate; currY < maxYIterate; ++currY) {
+                            net.minecraft.world.level.chunk.LevelChunkSection section = sections[(currY >> 4) - minSection];
+
+                            if (section == null || section.hasOnlyAir() || section.fluidStateCount == 0) { // if no fluids, nothing in this section
+                                // empty
+                                // skip to next section
+                                currY = (currY & ~(15)) + 15; // increment by 15: iterator loop increments by the extra one
+                                continue;
+                            }
+
+                            net.minecraft.world.level.chunk.PalettedContainer<BlockState> blocks = section.states;
+
+                            for (int currZ = minZ; currZ < maxZ; ++currZ) {
+                                for (int currX = minX; currX < maxX; ++currX) {
+                                    FluidState fluid = blocks.get(currX & 15, currY & 15, currZ & 15).getFluidState();
+
+                                    if (fluid.is(tag)) {
+                                        blockposition_mutableblockposition.set((currChunkX << 4) + currX, currY, (currChunkZ << 4) + currZ);
+                                        double d2 = (double) ((float) currY + fluid.getHeight(this.level, blockposition_mutableblockposition));
+
+                                        if (d2 >= axisalignedbb.minY) {
+                                            flag1 = true;
+                                            d1 = Math.max(d2 - axisalignedbb.minY, d1);
+                                            if (flag) {
+                                                Vec3 vec3d1 = fluid.getFlow(this.level, blockposition_mutableblockposition);
+
+                                                if (d1 < 0.4D) {
+                                                    vec3d1 = vec3d1.scale(d1);
+                                                }
+
+                                                vec3d = vec3d.add(vec3d1);
+                                                ++k1;
+                                            }
+                                            // CraftBukkit start - store last lava contact location
+                                            if (tag == FluidTags.LAVA) {
+                                                this.lastLavaContact = blockposition_mutableblockposition.immutable();
+                                            }
+                                            // CraftBukkit end
+                                        }
+                                    }
                                 }
-                                // CraftBukkit start - store last lava contact location
-                                if (tag == FluidTags.LAVA) {
-                                    this.lastLavaContact = blockposition_mutableblockposition.immutable();
+                            }
+                        }
+                    }
+                }
+            } else {
+                for (int l1 = minBlockX; l1 < maxBlockX; ++l1) {
+                    for (int i2 = minBlockY; i2 < maxBlockY; ++i2) {
+                        for (int j2 = minBlockZ; j2 < maxBlockZ; ++j2) {
+                            blockposition_mutableblockposition.set(l1, i2, j2);
+                            FluidState fluid = this.level().getFluidState(blockposition_mutableblockposition);
+
+                            if (fluid.is(tag)) {
+                                double d2 = (double) ((float) i2 + fluid.getHeight(this.level(), blockposition_mutableblockposition));
+
+                                if (d2 >= axisalignedbb.minY) {
+                                    flag1 = true;
+                                    d1 = Math.max(d2 - axisalignedbb.minY, d1);
+                                    if (flag) {
+                                        Vec3 vec3d1 = fluid.getFlow(this.level(), blockposition_mutableblockposition);
+
+                                        if (d1 < 0.4D) {
+                                            vec3d1 = vec3d1.scale(d1);
+                                        }
+
+                                        vec3d = vec3d.add(vec3d1);
+                                        ++k1;
+                                    }
+                                    // CraftBukkit start - store last lava contact location
+                                    if (tag == FluidTags.LAVA) {
+                                        this.lastLavaContact = blockposition_mutableblockposition.immutable();
+                                    }
+                                    // CraftBukkit end
                                 }
-                                // CraftBukkit end
                             }
                         }
                     }
                 }
             }
+            // Leaves end
 
             if (vec3d.length() > 0.0D) {
                 if (k1 > 0) {
@@ -4788,4 +4918,10 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         return ((net.minecraft.server.level.ServerChunkCache) level.getChunkSource()).isPositionTicking(this);
     }
     // Paper end
+
+    // Leaves start - leaves ex data
+    public CompoundTag getLeavesData() {
+        return leavesData;
+    }
+    // Leaves end - leaves ex data
 }
diff --git a/src/main/java/net/minecraft/world/entity/EquipmentSlot.java b/src/main/java/net/minecraft/world/entity/EquipmentSlot.java
index 97ff19efa0b3943ccb7a6e02cba6ed2fea61adac..b8995b0af34a1d790f48aa8e1090d20451da912a 100644
--- a/src/main/java/net/minecraft/world/entity/EquipmentSlot.java
+++ b/src/main/java/net/minecraft/world/entity/EquipmentSlot.java
@@ -12,6 +12,7 @@ public enum EquipmentSlot {
     private final int index;
     private final int filterFlag;
     private final String name;
+    public static final EquipmentSlot[] VALUES = EquipmentSlot.values(); // Leaves - reduce array allocations
 
     private EquipmentSlot(EquipmentSlot.Type type, int entityId, int armorStandId, String name) {
         this.type = type;
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index e11d7283662834047b2ff81a2fd25a4263792deb..a930062bd4a43df7f74d92ab8a178f13528204d8 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -242,7 +242,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
     protected ItemStack useItem;
     protected int useItemRemaining;
     protected int fallFlyTicks;
-    private BlockPos lastPos;
+    public BlockPos lastPos; // Leaves - private -> public
     private Optional<BlockPos> lastClimbablePos;
     @Nullable
     private DamageSource lastDamageSource;
@@ -414,7 +414,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
             boolean flag = this instanceof net.minecraft.world.entity.player.Player;
 
             if (!this.level().isClientSide) {
-                if (this.isInWall()) {
+                if ((!top.leavesmc.leaves.LeavesConfig.enableSuffocationOptimization || (tickCount % 10 == 0 && couldPossiblyBeHurt(1.0F))) && this.isInWall()) { // Leaves - optimize suffocation
                     this.hurt(this.damageSources().inWall(), 1.0F);
                 } else if (flag && !this.level().getWorldBorder().isWithinBounds(this.getBoundingBox())) {
                     double d0 = this.level().getWorldBorder().getDistanceToBorder(this) + this.level().getWorldBorder().getDamageSafeZone();
@@ -583,11 +583,11 @@ public abstract class LivingEntity extends Entity implements Attackable {
     }
 
     protected void tryAddFrost() {
-        if (!this.getBlockStateOnLegacy().isAir()) {
+        if (top.leavesmc.leaves.LeavesConfig.checkFrozenTicksBeforeLandingBlock || !this.getBlockStateOnLegacy().isAir()) { // Leaves - check frozen ticks before landing block
             int i = this.getTicksFrozen();
 
             if (i > 0) {
-                AttributeInstance attributemodifiable = this.getAttribute(Attributes.MOVEMENT_SPEED);
+                AttributeInstance attributemodifiable = !top.leavesmc.leaves.LeavesConfig.checkFrozenTicksBeforeLandingBlock || !this.getBlockStateOnLegacy().isAir() ? this.getAttribute(Attributes.MOVEMENT_SPEED) : null; // Leaves - check frozen ticks before landing block
 
                 if (attributemodifiable == null) {
                     return;
@@ -1369,6 +1369,15 @@ public abstract class LivingEntity extends Entity implements Attackable {
         return this.getHealth() <= 0.0F;
     }
 
+    // Leaves start - optimize suffocation
+    public boolean couldPossiblyBeHurt(float amount) {
+        if ((float) this.invulnerableTime > (float) this.invulnerableDuration / 2.0F && amount <= this.lastHurt) {
+            return false;
+        }
+        return true;
+    }
+    // Leaves end - optimize suffocation
+
     @Override
     public boolean hurt(DamageSource source, float amount) {
         if (this.isInvulnerableTo(source)) {
@@ -1577,12 +1586,12 @@ public abstract class LivingEntity extends Entity implements Attackable {
             }
 
             org.bukkit.inventory.EquipmentSlot handSlot = (hand != null) ? org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(hand) : null;
-            EntityResurrectEvent event = new EntityResurrectEvent((org.bukkit.entity.LivingEntity) this.getBukkitEntity(), handSlot);
+            EntityResurrectEvent event = new EntityResurrectEvent((org.bukkit.entity.LivingEntity) this.getBukkitEntity(), handSlot, true); // Leaves - can dont shrink
             event.setCancelled(itemstack == null);
             this.level().getCraftServer().getPluginManager().callEvent(event);
 
             if (!event.isCancelled()) {
-                if (!itemstack1.isEmpty() && itemstack != null) { // Paper - only reduce item if actual totem was found
+                if (!itemstack1.isEmpty() && itemstack != null && event.isShrink()) { // Paper - only reduce item if actual totem was found // Leaves - can dont shrink
                     itemstack1.shrink(1);
                 }
                 if (itemstack != null && this instanceof ServerPlayer) {
@@ -1965,6 +1974,22 @@ public abstract class LivingEntity extends Entity implements Attackable {
         return this.lastClimbablePos;
     }
 
+    // Leaves start - cache climbing check
+    private boolean cachedOnClimable = false;
+    private BlockPos lastClimbingPosition = null;
+
+    public boolean onClimableCached() {
+        if (!top.leavesmc.leaves.LeavesConfig.cacheClimbCheck) {
+            return this.onClimbable();
+        }
+        if (!this.blockPosition().equals(this.lastClimbingPosition)) {
+            this.cachedOnClimable = this.onClimbable();
+            this.lastClimbingPosition = this.blockPosition();
+        }
+        return this.cachedOnClimable;
+    }
+    // Leaves end - cache climbing check
+
     public boolean onClimbable() {
         if (this.isSpectator()) {
             return false;
@@ -3080,7 +3105,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
     @Nullable
     private Map<EquipmentSlot, ItemStack> collectEquipmentChanges() {
         Map<EquipmentSlot, ItemStack> map = null;
-        EquipmentSlot[] aenumitemslot = EquipmentSlot.values();
+        EquipmentSlot[] aenumitemslot = EquipmentSlot.VALUES; // Leaves - reduce array allocations
         int i = aenumitemslot.length;
 
         for (int j = 0; j < i; ++j) {
@@ -3651,7 +3676,13 @@ public abstract class LivingEntity extends Entity implements Attackable {
             Vec3 vec3d1 = new Vec3(entity.getX(), entity.getEyeY(), entity.getZ());
 
             // Paper - diff on change - used in CraftLivingEntity#hasLineOfSight(Location) and CraftWorld#lineOfSightExists
-            return vec3d1.distanceToSqr(vec3d) > 128D * 128D ? false : this.level().clip(new ClipContext(vec3d, vec3d1, ClipContext.Block.COLLIDER, ClipContext.Fluid.NONE, this)).getType() == HitResult.Type.MISS;
+            // Leaves start - strip raytracing
+            if (top.leavesmc.leaves.LeavesConfig.entityStripRaytracing) {
+                return vec3d1.distanceToSqr(vec3d) > 128D * 128D ? false : this.level().rayTraceDirect(vec3d, vec3d1, net.minecraft.world.phys.shapes.CollisionContext.of(this)) == net.minecraft.world.phys.BlockHitResult.Type.MISS;
+            } else {
+                return vec3d1.distanceToSqr(vec3d) > 128D * 128D ? false : this.level().clip(new ClipContext(vec3d, vec3d1, ClipContext.Block.COLLIDER, ClipContext.Fluid.NONE, this)).getType() == HitResult.Type.MISS; // Paper - use distanceToSqr
+            }
+            // Leaves end - strip raytracing
         }
     }
 
@@ -4451,3 +4482,4 @@ public abstract class LivingEntity extends Entity implements Attackable {
 
     }
 }
+
diff --git a/src/main/java/net/minecraft/world/entity/Mob.java b/src/main/java/net/minecraft/world/entity/Mob.java
index e2a25c29ec74147b3e66aa0b3deb85a8f6ee53a5..11abe44b4df0e5bf838ad3a888d3d110bf576c3d 100644
--- a/src/main/java/net/minecraft/world/entity/Mob.java
+++ b/src/main/java/net/minecraft/world/entity/Mob.java
@@ -218,11 +218,13 @@ public abstract class Mob extends LivingEntity implements Targeting {
         return this.lookControl;
     }
 
+    int inactiveTickDisableCounter = 0; // Leaves - throttle inactive goal selector ticking
     // Paper start
     @Override
     public void inactiveTick() {
         super.inactiveTick();
-        if (this.goalSelector.inactiveTick()) {
+        boolean isThrottled = top.leavesmc.leaves.LeavesConfig.throttleInactiveGoalSelectorTick && inactiveTickDisableCounter++ % 20 != 0; // Leaves - throttle inactive goal selector ticking
+        if (this.goalSelector.inactiveTick() && !isThrottled) { // Leaves - throttle inactive goal selector ticking
             this.goalSelector.tick();
         }
         if (this.targetSelector.inactiveTick()) {
@@ -1071,7 +1073,7 @@ public abstract class Mob extends LivingEntity implements Targeting {
     @Override
     protected void dropCustomDeathLoot(DamageSource source, int lootingMultiplier, boolean allowDrops) {
         super.dropCustomDeathLoot(source, lootingMultiplier, allowDrops);
-        EquipmentSlot[] aenumitemslot = EquipmentSlot.values();
+        EquipmentSlot[] aenumitemslot = EquipmentSlot.VALUES; // Leaves - reduce array allocations
         int j = aenumitemslot.length;
 
         for (int k = 0; k < j; ++k) {
@@ -1133,7 +1135,7 @@ public abstract class Mob extends LivingEntity implements Targeting {
             }
 
             boolean flag = true;
-            EquipmentSlot[] aenumitemslot = EquipmentSlot.values();
+            EquipmentSlot[] aenumitemslot = EquipmentSlot.VALUES; // Leaves - reduce array allocations
             int j = aenumitemslot.length;
 
             for (int k = 0; k < j; ++k) {
@@ -1220,7 +1222,7 @@ public abstract class Mob extends LivingEntity implements Targeting {
         float f = localDifficulty.getSpecialMultiplier();
 
         this.enchantSpawnedWeapon(random, f);
-        EquipmentSlot[] aenumitemslot = EquipmentSlot.values();
+        EquipmentSlot[] aenumitemslot = EquipmentSlot.VALUES; // Leaves - reduce array allocations
         int i = aenumitemslot.length;
 
         for (int j = 0; j < i; ++j) {
@@ -1439,7 +1441,7 @@ public abstract class Mob extends LivingEntity implements Targeting {
                 t0.setInvulnerable(this.isInvulnerable());
                 if (flag) {
                     t0.setCanPickUpLoot(this.canPickUpLoot());
-                    EquipmentSlot[] aenumitemslot = EquipmentSlot.values();
+                    EquipmentSlot[] aenumitemslot = EquipmentSlot.VALUES; // Leaves - reduce array allocations
                     int i = aenumitemslot.length;
 
                     for (int j = 0; j < i; ++j) {
@@ -1695,15 +1697,41 @@ public abstract class Mob extends LivingEntity implements Targeting {
 
     }
 
+    // Leaves start - optimize sun burn tick
+    private BlockPos cached_eye_blockpos;
+    private int cached_position_hashcode;
+    // Leaves end - optimize sun burn tick
+
     public boolean isSunBurnTick() {
         if (this.level().isDay() && !this.level().isClientSide) {
-            float f = this.getLightLevelDependentMagicValue();
-            BlockPos blockposition = BlockPos.containing(this.getX(), this.getEyeY(), this.getZ());
-            boolean flag = this.isInWaterRainOrBubble() || this.isInPowderSnow || this.wasInPowderSnow;
+            // Leaves start - optimize sun burn tick
+            if (!top.leavesmc.leaves.LeavesConfig.optimizeSunBurnTick) {
+                float f = this.getLightLevelDependentMagicValue();
+                BlockPos blockposition = BlockPos.containing(this.getX(), this.getEyeY(), this.getZ());
+                boolean flag = this.isInWaterRainOrBubble() || this.isInPowderSnow || this.wasInPowderSnow;
 
-            if (f > 0.5F && this.random.nextFloat() * 30.0F < (f - 0.4F) * 2.0F && !flag && this.level().canSeeSky(blockposition)) {
-                return true;
+                if (f > 0.5F && this.random.nextFloat() * 30.0F < (f - 0.4F) * 2.0F && !flag && this.level().canSeeSky(blockposition)) {
+                    return true;
+                }
+            } else {
+                int positionHashCode = this.position().hashCode();
+                if (this.cached_position_hashcode != positionHashCode) {
+                    this.cached_eye_blockpos = BlockPos.containing(this.getX(), this.getEyeY(), this.getZ());
+                    this.cached_position_hashcode = positionHashCode;
+                }
+
+                float f = this.getLightLevelDependentMagicValue(cached_eye_blockpos); // Pass BlockPos to getBrightness
+
+                // Check brightness first
+                if (f <= 0.5F) return false;
+                if (this.random.nextFloat() * 30.0F >= (f - 0.4F) * 2.0F) return false;
+                boolean flag = this.isInWaterRainOrBubble() || this.isInPowderSnow || this.wasInPowderSnow;
+
+                if (!flag && this.level().canSeeSky(this.cached_eye_blockpos)) {
+                    return true;
+                }
             }
+            // Leaves end - optimize sun burn tick
         }
 
         return false;
diff --git a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
index dd1102d5291ef6f18e82400a6d8a0a376cc071e9..c5b0ef5fa68e10987e75535fe18450930966ba24 100644
--- a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
+++ b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
@@ -20,12 +20,16 @@ import org.slf4j.Logger;
 
 public class AttributeMap {
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final Map<Attribute, AttributeInstance> attributes = Maps.newHashMap();
-    private final Set<AttributeInstance> dirtyAttributes = Sets.newHashSet();
+    // Leaves start - replace AI attributes with optimized collections
+    private final Map<Attribute, AttributeInstance> attributes = top.leavesmc.leaves.LeavesConfig.useOptimizedCollection ? new it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap<>(0) : Maps.newHashMap();
+    private final Set<AttributeInstance> dirtyAttributes = top.leavesmc.leaves.LeavesConfig.useOptimizedCollection ? new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>(0) : Sets.newHashSet();
+    // Leaves end - replace AI attributes with optimized collections
     private final AttributeSupplier supplier;
+    private final java.util.function.Function<Attribute, AttributeInstance> createInstance; // Leaves - reduce entity allocations
 
     public AttributeMap(AttributeSupplier defaultAttributes) {
         this.supplier = defaultAttributes;
+        this.createInstance = attribute -> this.supplier.createInstance(this::onAttributeModified, attribute);
     }
 
     private void onAttributeModified(AttributeInstance instance) {
@@ -47,9 +51,15 @@ public class AttributeMap {
 
     @Nullable
     public AttributeInstance getInstance(Attribute attribute) {
-        return this.attributes.computeIfAbsent(attribute, (attributex) -> {
-            return this.supplier.createInstance(this::onAttributeModified, attributex);
-        });
+        // Leaves start - cache lambda, as for some reason java allocates it anyways
+        if (top.leavesmc.leaves.LeavesConfig.reduceEntityAllocations) {
+            return this.attributes.computeIfAbsent(attribute, this.createInstance);
+        } else {
+            return this.attributes.computeIfAbsent(attribute, (attributex) -> {
+                return this.supplier.createInstance(this::onAttributeModified, attributex);
+            });
+        }
+        // Leaves end - cache lambda, as for some reason java allocates it anyways
     }
 
     @Nullable
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/AcquirePoi.java b/src/main/java/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
index d4c91e0a0c64fcb7f1145de3f30134cb1f1f8ee6..44fc394dbab7e05a3bd7cab493300a964a6c46a5 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
@@ -47,6 +47,11 @@ public class AcquirePoi {
                         return false;
                     } else {
                         mutableLong.setValue(time + 20L + (long)world.getRandom().nextInt(20));
+                        // Leaves start - wait an additional 10s to check again if they're stuck
+                        if (top.leavesmc.leaves.LeavesConfig.skipPOIFindingInVehicle && entity.getNavigation().isStuck())  {
+                            mutableLong.add(200L);
+                        }
+                        // Leaves end - wait an additional 10s to check again if they're stuck
                         PoiManager poiManager = world.getPoiManager();
                         long2ObjectMap.long2ObjectEntrySet().removeIf((entry) -> {
                             return !entry.getValue().isStillValid(time);
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
index b738ee2d3801fadfd09313f05ae24593e56b0ec6..2d1abb9518795875b3719efe91e60508c2c73163 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
@@ -28,7 +28,7 @@ public class GoalSelector {
         }
     };
     private final Map<Goal.Flag, WrappedGoal> lockedFlags = new EnumMap<>(Goal.Flag.class);
-    private final Set<WrappedGoal> availableGoals = Sets.newLinkedHashSet();
+    private final Set<WrappedGoal> availableGoals = top.leavesmc.leaves.LeavesConfig.useOptimizedCollection ? new it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet<>() : Sets.newLinkedHashSet(); // Leaves - replace AI goal set with optimized collection
     private final Supplier<ProfilerFiller> profiler;
     private final EnumSet<Goal.Flag> disabledFlags = EnumSet.noneOf(Goal.Flag.class); // Paper unused, but dummy to prevent plugins from crashing as hard. Theyll need to support paper in a special case if this is super important, but really doesn't seem like it would be.
     private final com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<net.minecraft.world.entity.ai.goal.Goal.Flag> goalTypes = new com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<>(Goal.Flag.class); // Paper - remove streams from pathfindergoalselector
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
index 34f319ad09276c6f68dde449c79351de0d7d86f5..bbca34e70b1ee88ac77b0d8e319eedbffae3effb 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
@@ -119,6 +119,7 @@ public abstract class MoveToBlockGoal extends Goal {
                 for(int m = 0; m <= l; m = m > 0 ? -m : 1 - m) {
                     for(int n = m < l && m > -l ? l : 0; n <= l; n = n > 0 ? -n : 1 - n) {
                         mutableBlockPos.setWithOffset(blockPos, m, k - 1, n);
+                        if (top.leavesmc.leaves.LeavesConfig.fixPaper6045 && !this.mob.level().hasChunkAt(mutableBlockPos)) continue; // Leaves - if this block isn't loaded, continue
                         if (this.mob.isWithinRestriction(mutableBlockPos) && this.isValidTarget(this.mob.level(), mutableBlockPos)) {
                             this.blockPos = mutableBlockPos;
                             setTargetPosition(mutableBlockPos.immutable()); // Paper
diff --git a/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java b/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java
index 097007c1c25ba55d9916fc820dd1d1149d81f6f4..67c0a46b098d631b862df80511990c396934200b 100644
--- a/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java
+++ b/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java
@@ -120,6 +120,16 @@ public class GossipContainer {
 
     public int getReputation(UUID target, Predicate<GossipType> gossipTypeFilter) {
         GossipContainer.EntityGossips entityGossips = this.gossips.get(target);
+        // Leaves start - sharedVillagerDiscounts
+        if (top.leavesmc.leaves.LeavesConfig.sharedVillagerDiscounts && gossipTypeFilter.test(GossipType.MAJOR_POSITIVE)) {
+            int otherRep = 0;
+            if (entityGossips != null) {
+                otherRep = entityGossips.weightedValue(v -> gossipTypeFilter.test(v) && !v.equals(GossipType.MAJOR_POSITIVE));
+            }
+            int majorPositiveRep = this.gossips.values().stream().mapToInt(a -> a.weightedValue(v -> v.equals(GossipType.MAJOR_POSITIVE))).sum();
+            return otherRep + Math.min(majorPositiveRep, GossipType.MAJOR_POSITIVE.max * GossipType.MAJOR_POSITIVE.weight);
+        }
+        // Leaves end - sharedVillagerDiscounts
         return entityGossips != null ? entityGossips.weightedValue(gossipTypeFilter) : 0;
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java
index cb1d91f9fe98f21c2afbe3894dfd9bca3bdd3ba6..ea89cf4a0746ecf1fdb1eae27560299b813d4374 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java
@@ -22,6 +22,15 @@ public class SecondaryPoiSensor extends Sensor<Villager> {
 
     @Override
     protected void doTick(ServerLevel world, Villager entity) {
+        // Leaves start - skip secondary POI sensor if absent
+        if (top.leavesmc.leaves.LeavesConfig.skipSecondaryPOISensorIfAbsent) {
+            var secondaryPoi = entity.getVillagerData().getProfession().secondaryPoi();
+            if (secondaryPoi.isEmpty()) {
+                entity.getBrain().eraseMemory(MemoryModuleType.SECONDARY_JOB_SITE);
+                return;
+            }
+        }
+        // Leaves end - skip secondary POI sensor if absent
         ResourceKey<Level> resourceKey = world.dimension();
         BlockPos blockPos = entity.blockPosition();
         List<GlobalPos> list = Lists.newArrayList();
diff --git a/src/main/java/net/minecraft/world/entity/ai/targeting/TargetingConditions.java b/src/main/java/net/minecraft/world/entity/ai/targeting/TargetingConditions.java
index 58422f00c7d64dbd1cf6d7211c9838875cbe7778..b39072cf38795e8f0d73f83b10d29fe19c507c54 100644
--- a/src/main/java/net/minecraft/world/entity/ai/targeting/TargetingConditions.java
+++ b/src/main/java/net/minecraft/world/entity/ai/targeting/TargetingConditions.java
@@ -75,9 +75,17 @@ public class TargetingConditions {
                 }
 
                 if (this.range > 0.0D) {
+                    // Leaves start - check range before getting visibility
+                    double f = baseEntity.distanceToSqr(targetEntity.getX(), targetEntity.getY(), targetEntity.getZ());
+                    if (top.leavesmc.leaves.LeavesConfig.entityTargetFindingOptimization) {
+                        double followRangeRaw = this.useFollowRange ? this.getFollowRange(baseEntity) : this.range;
+                        if (f > followRangeRaw * followRangeRaw) { // the actual follow range will always be this value or smaller, so if the distance is larger then it never will return true after getting invis
+                            return false;
+                        }
+                    }
                     double d = this.testInvisible ? targetEntity.getVisibilityPercent(baseEntity) : 1.0D;
                     double e = Math.max((this.useFollowRange ? this.getFollowRange(baseEntity) : this.range) * d, 2.0D); // Paper
-                    double f = baseEntity.distanceToSqr(targetEntity.getX(), targetEntity.getY(), targetEntity.getZ());
+                    // Leaves end - check range before getting visibility
                     if (f > e * e) {
                         return false;
                     }
diff --git a/src/main/java/net/minecraft/world/entity/ambient/Bat.java b/src/main/java/net/minecraft/world/entity/ambient/Bat.java
index 5beaa849a250ea005733250ad3edfa8382224667..f124d17106edc490e90376bbbaba6912f0579d16 100644
--- a/src/main/java/net/minecraft/world/entity/ambient/Bat.java
+++ b/src/main/java/net/minecraft/world/entity/ambient/Bat.java
@@ -237,13 +237,30 @@ public class Bat extends AmbientCreature {
         }
     }
 
+    // Leaves start - only check for spooky season once an hour
+    private static boolean isSpookySeason = false;
+    private static final int ONE_HOUR = 20 * 60 * 60;
+    private static int lastSpookyCheck = -ONE_HOUR;
     private static boolean isHalloween() {
-        LocalDate localdate = LocalDate.now();
-        int i = localdate.get(ChronoField.DAY_OF_MONTH);
-        int j = localdate.get(ChronoField.MONTH_OF_YEAR);
+        if (top.leavesmc.leaves.LeavesConfig.checkSpookySeasonOnceAnHour) {
+            if (net.minecraft.server.MinecraftServer.currentTick - lastSpookyCheck > ONE_HOUR) {
+                LocalDate localdate = LocalDate.now();
+                int i = localdate.get(ChronoField.DAY_OF_MONTH);
+                int j = localdate.get(ChronoField.MONTH_OF_YEAR);
+
+                isSpookySeason = j == 10 && i >= 20 || j == 11 && i <= 3;
+                lastSpookyCheck = net.minecraft.server.MinecraftServer.currentTick;
+            }
+            return isSpookySeason;
+        } else {
+            LocalDate localdate = LocalDate.now();
+            int i = localdate.get(ChronoField.DAY_OF_MONTH);
+            int j = localdate.get(ChronoField.MONTH_OF_YEAR);
 
-        return j == 10 && i >= 20 || j == 11 && i <= 3;
+            return j == 10 && i >= 20 || j == 11 && i <= 3;
+        }
     }
+    // Leaves end - only check for spooky season once an hour
 
     @Override
     protected float getStandingEyeHeight(Pose pose, EntityDimensions dimensions) {
diff --git a/src/main/java/net/minecraft/world/entity/animal/Bee.java b/src/main/java/net/minecraft/world/entity/animal/Bee.java
index 55026e1731e41b4e3e4c6a8fef5d96a32051a556..81a15ba8cc959311363bdfd9340833a9c0f84f77 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Bee.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Bee.java
@@ -1029,7 +1029,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
 
         BeeGoToHiveGoal() {
             super();
-            this.travellingTicks = Bee.this./* level(). */random.nextInt(10); // Paper - use entity random
+            this.travellingTicks = top.leavesmc.leaves.LeavesConfig.useVanillaRandom ? Bee.this.level().random.nextInt(10) : Bee.this.random.nextInt(10); // Paper - use entity random // Leaves - why no vanilla
             this.blacklistedTargets = Lists.newArrayList();
             this.setFlags(EnumSet.of(Goal.Flag.MOVE));
         }
diff --git a/src/main/java/net/minecraft/world/entity/animal/Squid.java b/src/main/java/net/minecraft/world/entity/animal/Squid.java
index f60c4cd0543fd5d50fa7e2c1a9e8381227adb540..8c9c694744951dc11b9f8828f27e4d4a2210a3bc 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Squid.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Squid.java
@@ -44,7 +44,7 @@ public class Squid extends WaterAnimal {
 
     public Squid(EntityType<? extends Squid> type, Level world) {
         super(type, world);
-        //this.random.setSeed((long)this.getId()); // Paper - we set the random to shared, do not clobber the seed
+        if (top.leavesmc.leaves.LeavesConfig.useVanillaRandom) this.random.setSeed(this.getId()); // Paper - we set the random to shared, do not clobber the seed // Leaves - vanilla plz
         this.tentacleSpeed = 1.0F / (this.random.nextFloat() + 1.0F) * 0.2F;
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/animal/frog/Tadpole.java b/src/main/java/net/minecraft/world/entity/animal/frog/Tadpole.java
index 4aeab90e778629c355189dfe79c39c4b21f5f5ac..fe8c9b7e7956837829b4fe3eb449b2c093f7cea3 100644
--- a/src/main/java/net/minecraft/world/entity/animal/frog/Tadpole.java
+++ b/src/main/java/net/minecraft/world/entity/animal/frog/Tadpole.java
@@ -253,7 +253,7 @@ public class Tadpole extends AbstractFish {
 
     }
 
-    private int getTicksLeftUntilAdult() {
+    public int getTicksLeftUntilAdult() { // Leaves - private -> public
         return Math.max(0, Tadpole.ticksToBeFrog - this.age);
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/animal/horse/AbstractHorse.java b/src/main/java/net/minecraft/world/entity/animal/horse/AbstractHorse.java
index 9b35a50eb99551f28d45fd5114e0401b4c54646e..21aa401966c13677826697f3e4ee9b4cf1b9d963 100644
--- a/src/main/java/net/minecraft/world/entity/animal/horse/AbstractHorse.java
+++ b/src/main/java/net/minecraft/world/entity/animal/horse/AbstractHorse.java
@@ -379,6 +379,11 @@ public abstract class AbstractHorse extends Animal implements ContainerListener,
 
     @Override
     public void containerChanged(Container sender) {
+        // Leaves start - pca
+        if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncEntityToClient(this);
+        }
+        // Leaves end - pca
         boolean flag = this.isSaddled();
 
         this.updateContainerEquipment();
diff --git a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java
index ffc5b68c4246a7111845230a75552bb15875a209..990cdebf1b9e64a5001c71411e64f68108aef47f 100644
--- a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java
+++ b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java
@@ -67,7 +67,7 @@ public class EndCrystal extends Entity {
                 // CraftBukkit end
             }
             // Paper start - Fix invulnerable end crystals
-            if (this.level().paperConfig().unsupportedSettings.fixInvulnerableEndCrystalExploit && this.generatedByDragonFight && this.isInvulnerable()) {
+            if (!top.leavesmc.leaves.LeavesConfig.mcTechnicalMode && this.level().paperConfig().unsupportedSettings.fixInvulnerableEndCrystalExploit && this.generatedByDragonFight && this.isInvulnerable()) { // Leaves - mc technical survival mode
                 if (!java.util.Objects.equals(((ServerLevel) this.level()).uuid, this.getOriginWorld())
                     || ((ServerLevel) this.level()).getDragonFight() == null
                     || ((ServerLevel) this.level()).getDragonFight().respawnStage == null
diff --git a/src/main/java/net/minecraft/world/entity/decoration/ArmorStand.java b/src/main/java/net/minecraft/world/entity/decoration/ArmorStand.java
index 5c6e060a54ffb13c37ff5711992e964bdd59643d..dc7171e32e132350b2d500986a6ba06b1fcb1d19 100644
--- a/src/main/java/net/minecraft/world/entity/decoration/ArmorStand.java
+++ b/src/main/java/net/minecraft/world/entity/decoration/ArmorStand.java
@@ -385,6 +385,12 @@ public class ArmorStand extends LivingEntity {
                         return InteractionResult.SUCCESS;
                     }
                 } else {
+                    // Leaves start - stick can change ArmorStand arm status
+                    if (top.leavesmc.leaves.LeavesConfig.stickChangeArmorStandArmStatus && itemstack.is(Items.STICK) && player.isShiftKeyDown()) {
+                        setShowArms(!isShowArms());
+                    }
+                    // Leaves end - stick can change ArmorStand arm status
+
                     if (this.isDisabled(enumitemslot)) {
                         return InteractionResult.FAIL;
                     }
diff --git a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
index 18eaccb39a4c81338a8cbebe3de03934913ac2a4..34c62ba8d659c3df37243c3abf4cdd705b3ddf8c 100644
--- a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
@@ -132,11 +132,7 @@ public class FallingBlockEntity extends Entity {
 
     @Override
     public void tick() {
-        // Paper start - fix sand duping
-        if (this.isRemoved()) {
-            return;
-        }
-        // Paper end - fix sand duping
+		// Leaves - fix gravity block duper
         if (this.blockState.isAir()) {
             this.discard();
         } else {
@@ -149,11 +145,7 @@ public class FallingBlockEntity extends Entity {
 
             this.move(MoverType.SELF, this.getDeltaMovement());
 
-            // Paper start - fix sand duping
-            if (this.isRemoved()) {
-                return;
-            }
-            // Paper end - fix sand duping
+			// Leaves - fix gravity block duper
 
             // Paper start - Configurable EntityFallingBlock height nerf
             if (this.level().paperConfig().fixes.fallingBlockHeightNerf.test(v -> this.getY() > v)) {
diff --git a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
index 52196431a6538872755344859a0454a0e50c3b6e..c72e73ee5878651f48a0513e03dc7903386d6eb5 100644
--- a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
@@ -14,10 +14,12 @@ import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.MoverType;
 import net.minecraft.world.entity.TraceableEntity;
+import net.minecraft.world.item.BlockItem;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.ShulkerBoxBlock;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.core.BlockPos;
@@ -33,6 +35,7 @@ import net.minecraft.sounds.SoundSource;
 import net.minecraft.stats.Stats;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.entity.Player;
+import org.bukkit.block.ShulkerBox;
 import org.bukkit.event.entity.EntityPickupItemEvent;
 import org.bukkit.event.player.PlayerPickupItemEvent;
 // CraftBukkit end
@@ -68,9 +71,22 @@ public class ItemEntity extends Entity implements TraceableEntity {
         // Paper start - don't use world random in entity constructor
         this(EntityType.ITEM, world);
         this.setPos(x, y, z);
-        this.setDeltaMovement(this.random.nextDouble() * 0.2D - 0.1D, 0.2D, this.random.nextDouble() * 0.2D - 0.1D);
+        // Leaves start - vanilla yes, paper no
+        if (top.leavesmc.leaves.LeavesConfig.useVanillaRandom) {
+            this.setDeltaMovement(world.random.nextDouble() * 0.2D - 0.1D, 0.2D, world.random.nextDouble() * 0.2D - 0.1D);
+        } else {
+            this.setDeltaMovement(this.random.nextDouble() * 0.2D - 0.1D, 0.2D, this.random.nextDouble() * 0.2D - 0.1D);
+        }
+        // Leaves end - vanilla yes, paper no
         this.setItem(stack);
         // Paper end
+        // Leaves start - stackable shulker boxes
+        if (top.leavesmc.leaves.LeavesConfig.shulkerBoxStackSize > 1) {
+            if (stack.getItem() instanceof BlockItem bi && bi.getBlock() instanceof ShulkerBoxBlock) {
+                top.leavesmc.leaves.util.ShulkerBoxUtils.cleanUpShulkerBoxTag(stack);
+            }
+        }
+        // Leaves end - stackable shulker boxes
     }
 
     public ItemEntity(Level world, double x, double y, double z, ItemStack stack, double velocityX, double velocityY, double velocityZ) {
@@ -270,10 +286,17 @@ public class ItemEntity extends Entity implements TraceableEntity {
                 if (entityitem.isMergable()) {
                     // Paper Start - Fix items merging through walls
                         if (this.level().paperConfig().fixes.fixItemsMergingThroughWalls) {
-                            net.minecraft.world.level.ClipContext rayTrace = new net.minecraft.world.level.ClipContext(this.position(), entityitem.position(),
-                                net.minecraft.world.level.ClipContext.Block.COLLIDER, net.minecraft.world.level.ClipContext.Fluid.NONE, this);
-                            net.minecraft.world.phys.BlockHitResult rayTraceResult = this.level().clip(rayTrace);
-                            if (rayTraceResult.getType() == net.minecraft.world.phys.HitResult.Type.BLOCK) continue;
+                            // Leaves start - use fast item merge raytracing
+                            if (!top.leavesmc.leaves.LeavesConfig.useFastItemMergeRaytracing) {
+                                net.minecraft.world.level.ClipContext rayTrace = new net.minecraft.world.level.ClipContext(this.position(), entityitem.position(),
+                                    net.minecraft.world.level.ClipContext.Block.COLLIDER, net.minecraft.world.level.ClipContext.Fluid.NONE, this);
+                                net.minecraft.world.phys.BlockHitResult rayTraceResult = this.level().clip(rayTrace);
+                                if (rayTraceResult.getType() == net.minecraft.world.phys.HitResult.Type.BLOCK) continue;
+                            } else {
+                                if (level().rayTraceDirect(this.position(), entityitem.position(), net.minecraft.world.phys.shapes.CollisionContext.of(this)) ==
+                                    net.minecraft.world.phys.HitResult.Type.BLOCK) continue;
+                            }
+                            // Leaves end - use fast item merge raytracing
                         }
                     // Paper End
                     this.tryToMerge(entityitem);
@@ -289,10 +312,49 @@ public class ItemEntity extends Entity implements TraceableEntity {
     private boolean isMergable() {
         ItemStack itemstack = this.getItem();
 
-        return this.isAlive() && this.pickupDelay != 32767 && this.age != -32768 && this.age < this.despawnRate && itemstack.getCount() < itemstack.getMaxStackSize(); // Paper - respect despawn rate in pickup check.
+        return this.isAlive() && this.pickupDelay != 32767 && this.age != -32768 && this.age < this.despawnRate && itemstack.getCount() < top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack); // Paper - respect despawn rate in pickup check. // Leaves - stackable shulker boxes
     }
 
+    // Leaves end - stackable shulker boxes
+    private boolean tryStackShulkerBoxes(ItemEntity other) {
+        ItemStack selfStack = this.getItem();
+        if (top.leavesmc.leaves.LeavesConfig.shulkerBoxStackSize == 1 || !(selfStack.getItem() instanceof BlockItem bi) || !(bi.getBlock() instanceof ShulkerBoxBlock)) {
+            return false;
+        }
+
+        ItemStack otherStack = other.getItem();
+        if (selfStack.getItem() == otherStack.getItem()
+            && !top.leavesmc.leaves.util.ShulkerBoxUtils.shulkerBoxHasItems(selfStack)
+            && !top.leavesmc.leaves.util.ShulkerBoxUtils.shulkerBoxHasItems(otherStack)
+            && Objects.equals(selfStack.getTag(), otherStack.getTag()) // empty block entity tags are cleaned up when spawning
+            && selfStack.getCount() != top.leavesmc.leaves.LeavesConfig.shulkerBoxStackSize) {
+            int amount = Math.min(otherStack.getCount(), top.leavesmc.leaves.LeavesConfig.shulkerBoxStackSize - selfStack.getCount());
+
+            selfStack.grow(amount);
+            this.setItem(selfStack);
+
+            this.pickupDelay = Math.max(other.pickupDelay, this.pickupDelay);
+            this.age = Math.min(other.getAge(), this.age);
+
+            otherStack.shrink(amount);
+            if (otherStack.isEmpty()) {
+                other.discard();
+            }
+            else {
+                other.setItem(otherStack);
+            }
+            return true;
+        }
+        return false;
+    }
+    // Leaves end - stackable shulker boxes
+
     private void tryToMerge(ItemEntity other) {
+        // Leaves start - stackable shulker boxes
+        if (tryStackShulkerBoxes(other)) {
+            return;
+        }
+        // Leaves end - stackable shulker boxes
         ItemStack itemstack = this.getItem();
         ItemStack itemstack1 = other.getItem();
 
diff --git a/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java b/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
index 4ce3e69970dd9eb251d0538a2d233ca30e9e5e47..e66b138370ceae2ea16c48a17d0a3d8209fe9b55 100644
--- a/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
+++ b/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
@@ -36,7 +36,7 @@ public class PrimedTnt extends Entity implements TraceableEntity {
     public PrimedTnt(Level world, double x, double y, double z, @Nullable LivingEntity igniter) {
         this(EntityType.TNT, world);
         this.setPos(x, y, z);
-        double d3 = this.random.nextDouble() * 6.2831854820251465D; // Paper - don't use world random in entity constructor
+        double d3 = (top.leavesmc.leaves.LeavesConfig.useVanillaRandom ? world.random.nextDouble() : this.random.nextDouble()) * 6.2831854820251465D; // Paper - don't use world random in entity constructor // Leaves - why?
 
         this.setDeltaMovement(-Math.sin(d3) * 0.02D, 0.20000000298023224D, -Math.cos(d3) * 0.02D);
         this.setFuse(80);
@@ -63,7 +63,7 @@ public class PrimedTnt extends Entity implements TraceableEntity {
 
     @Override
     public void tick() {
-        if (this.level().spigotConfig.maxTntTicksPerTick > 0 && ++this.level().spigotConfig.currentPrimedTnt > this.level().spigotConfig.maxTntTicksPerTick) { return; } // Spigot
+        if (this.level().spigotConfig.maxTntTicksPerTick > 0 && ++this.level().spigotConfig.currentPrimedTnt > (top.leavesmc.leaves.LeavesConfig.mcTechnicalMode ? 2000 : this.level().spigotConfig.maxTntTicksPerTick)) { return; } // Spigot // Leaves - mc technical survival mode
         if (!this.isNoGravity()) {
             this.setDeltaMovement(this.getDeltaMovement().add(0.0D, -0.04D, 0.0D));
         }
diff --git a/src/main/java/net/minecraft/world/entity/monster/EnderMan.java b/src/main/java/net/minecraft/world/entity/monster/EnderMan.java
index b62457313a1e30aad0c5313d608667b5d3811455..326eb5d31c2a6772e413b6ef51186929a34ff9d0 100644
--- a/src/main/java/net/minecraft/world/entity/monster/EnderMan.java
+++ b/src/main/java/net/minecraft/world/entity/monster/EnderMan.java
@@ -326,11 +326,28 @@ public class EnderMan extends Monster implements NeutralMob {
     private boolean teleport(double x, double y, double z) {
         BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos(x, y, z);
 
-        while (blockposition_mutableblockposition.getY() > this.level().getMinBuildHeight() && !this.level().getBlockState(blockposition_mutableblockposition).blocksMotion()) {
-            blockposition_mutableblockposition.move(Direction.DOWN);
+        // Leaves start - single chunk lookup
+        BlockState iblockdata;
+        if (top.leavesmc.leaves.LeavesConfig.reduceChuckLoadAndLookup) {
+            net.minecraft.world.level.chunk.LevelChunk chunk = this.level().getChunkIfLoaded(blockposition_mutableblockposition);
+            if (chunk == null) {
+                return false;
+            }
+
+            while (blockposition_mutableblockposition.getY() > this.level().getMinBuildHeight() && !chunk.getBlockState(blockposition_mutableblockposition).blocksMotion()) {
+                blockposition_mutableblockposition.move(Direction.DOWN);
+            }
+
+            iblockdata = chunk.getBlockState(blockposition_mutableblockposition);
+        } else {
+            while (blockposition_mutableblockposition.getY() > this.level().getMinBuildHeight() && !this.level().getBlockState(blockposition_mutableblockposition).blocksMotion()) {
+                blockposition_mutableblockposition.move(Direction.DOWN);
+            }
+
+            iblockdata = this.level().getBlockState(blockposition_mutableblockposition);
         }
+        // Leaves end - single chunk lookup
 
-        BlockState iblockdata = this.level().getBlockState(blockposition_mutableblockposition);
         boolean flag = iblockdata.blocksMotion();
         boolean flag1 = iblockdata.getFluidState().is(FluidTags.WATER);
 
@@ -462,7 +479,7 @@ public class EnderMan extends Monster implements NeutralMob {
 
     @Override
     public boolean requiresCustomPersistence() {
-        return super.requiresCustomPersistence() || this.getCarriedBlock() != null;
+        return super.requiresCustomPersistence() || (!top.leavesmc.leaves.LeavesConfig.despawnEndermanWithBlock && this.getCarriedBlock() != null); // Leaves - despawn enderman with block
     }
 
     private static class EndermanFreezeWhenLookedAt extends Goal {
diff --git a/src/main/java/net/minecraft/world/entity/monster/Phantom.java b/src/main/java/net/minecraft/world/entity/monster/Phantom.java
index 4a132c3eff6978e927bcd4df56b9ce0306af6d19..8f390c7201da00f7e1c5913f0d0642a2b5e943cb 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Phantom.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Phantom.java
@@ -36,6 +36,8 @@ import net.minecraft.world.entity.ai.goal.Goal;
 import net.minecraft.world.entity.ai.targeting.TargetingConditions;
 import net.minecraft.world.entity.animal.Cat;
 import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.ServerLevelAccessor;
 import net.minecraft.world.level.levelgen.Heightmap;
@@ -250,6 +252,20 @@ public class Phantom extends FlyingMob implements Enemy {
         return (double) this.getEyeHeight();
     }
 
+    // Leaves start - renewable elytra
+    @Override
+    protected void dropFromLootTable(DamageSource source, boolean causedByPlayer) {
+        super.dropFromLootTable(source, causedByPlayer);
+        if (top.leavesmc.leaves.LeavesConfig.renewableElytra > 0.0D) {
+            if (source.getEntity() instanceof Shulker && this.random.nextDouble() < top.leavesmc.leaves.LeavesConfig.renewableElytra) {
+                ItemStack item = new ItemStack(Items.ELYTRA);
+                item.setDamageValue(432);
+                this.spawnAtLocation(item);
+            }
+        }
+    }
+    // Leaves end - renewable elytra
+
     // Paper start
     java.util.UUID spawningEntity;
 
diff --git a/src/main/java/net/minecraft/world/entity/monster/ZombieVillager.java b/src/main/java/net/minecraft/world/entity/monster/ZombieVillager.java
index 25ed5571b24e590bc95056020d84496492b53298..89d7364bc645a8b9217e87780cdc0ced5318bc2a 100644
--- a/src/main/java/net/minecraft/world/entity/monster/ZombieVillager.java
+++ b/src/main/java/net/minecraft/world/entity/monster/ZombieVillager.java
@@ -234,7 +234,7 @@ public class ZombieVillager extends Zombie implements VillagerDataHolder {
             return;
         }
         // CraftBukkit end
-        EquipmentSlot[] aenumitemslot = EquipmentSlot.values();
+        EquipmentSlot[] aenumitemslot = EquipmentSlot.VALUES; // Leaves - reduce array allocations
         int i = aenumitemslot.length;
 
         for (int j = 0; j < i; ++j) {
diff --git a/src/main/java/net/minecraft/world/entity/npc/AbstractVillager.java b/src/main/java/net/minecraft/world/entity/npc/AbstractVillager.java
index 564908ce0a560c2190fb624e77d227d3b7031024..5304ee89ce843c9ca860d68091162a976daee0ea 100644
--- a/src/main/java/net/minecraft/world/entity/npc/AbstractVillager.java
+++ b/src/main/java/net/minecraft/world/entity/npc/AbstractVillager.java
@@ -65,6 +65,15 @@ public abstract class AbstractVillager extends AgeableMob implements InventoryCa
         super(type, world);
         this.setPathfindingMalus(BlockPathTypes.DANGER_FIRE, 16.0F);
         this.setPathfindingMalus(BlockPathTypes.DAMAGE_FIRE, -1.0F);
+        // Leaves start - pca
+        if (!this.level().isClientSide()) {
+            this.inventory.addListener(inventory -> {
+                if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+                    top.leavesmc.leaves.protocol.PcaSyncProtocol.syncEntityToClient(this);
+                }
+            });
+        }
+        // Leaves end - pca
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/npc/Villager.java b/src/main/java/net/minecraft/world/entity/npc/Villager.java
index e30d5ae3e2900f43d7cafde71b8196f26e872841..3e36b1f0d8f18de7afe7a1db6cf3a695b7d7a58c 100644
--- a/src/main/java/net/minecraft/world/entity/npc/Villager.java
+++ b/src/main/java/net/minecraft/world/entity/npc/Villager.java
@@ -1009,7 +1009,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     public void onReputationEventFrom(ReputationEventType interaction, Entity entity) {
         if (interaction == ReputationEventType.ZOMBIE_VILLAGER_CURED) {
             // Paper start - fix MC-181190
-            if (this.level().paperConfig().fixes.fixCuringZombieVillagerDiscountExploit) {
+            if (!top.leavesmc.leaves.LeavesConfig.mcTechnicalMode && this.level().paperConfig().fixes.fixCuringZombieVillagerDiscountExploit) { // Leaves - mc technical survival mode
                 final GossipContainer.EntityGossips playerReputation = this.getGossips().gossips.get(entity.getUUID());
                 if (playerReputation != null) {
                     playerReputation.remove(GossipType.MAJOR_POSITIVE);
@@ -1076,4 +1076,20 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
 
         return optional.isPresent() ? worldTime - (Long) optional.get() < 24000L : false;
     }
+
+    // Leaves start - fixes a memory leak when villagers get moved to another world
+    @Nullable
+    @Override
+    public Entity changeDimension(ServerLevel destination) {
+        if (top.leavesmc.leaves.LeavesConfig.villagersDontReleaseMemoryFix) {
+            this.releaseAllPois();
+            this.getBrain().eraseMemory(MemoryModuleType.HOME);
+            this.getBrain().eraseMemory(MemoryModuleType.JOB_SITE);
+            this.getBrain().eraseMemory(MemoryModuleType.POTENTIAL_JOB_SITE);
+            this.getBrain().eraseMemory(MemoryModuleType.MEETING_POINT);
+            this.refreshBrain(destination);
+        }
+        return super.changeDimension(destination);
+    }
+    // Leaves end - fixes a memory leak when villagers get moved to another world
 }
diff --git a/src/main/java/net/minecraft/world/entity/player/Inventory.java b/src/main/java/net/minecraft/world/entity/player/Inventory.java
index 395cecc385e4126a7534ac9aeb15cf323efab03e..15b3425fd5cebfc2ddcb0e39879f4f65c64f3317 100644
--- a/src/main/java/net/minecraft/world/entity/player/Inventory.java
+++ b/src/main/java/net/minecraft/world/entity/player/Inventory.java
@@ -114,7 +114,7 @@ public class Inventory implements Container, Nameable {
     }
 
     private boolean hasRemainingSpaceForItem(ItemStack existingStack, ItemStack stack) {
-        return !existingStack.isEmpty() && ItemStack.isSameItemSameTags(existingStack, stack) && existingStack.isStackable() && existingStack.getCount() < existingStack.getMaxStackSize() && existingStack.getCount() < this.getMaxStackSize();
+        return !existingStack.isEmpty() && ItemStack.isSameItemSameTags(existingStack, stack) && top.leavesmc.leaves.util.ShulkerBoxUtils.isStackable(existingStack) && existingStack.getCount() < top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(existingStack) && existingStack.getCount() < this.getMaxStackSize(); // Leaves - stackable shulker boxes
     }
 
     // CraftBukkit start - Watch method above! :D
@@ -283,9 +283,11 @@ public class Inventory implements Container, Nameable {
 
         int k = j;
 
-        if (j > itemstack1.getMaxStackSize() - itemstack1.getCount()) {
-            k = itemstack1.getMaxStackSize() - itemstack1.getCount();
+        // Leaves start - stackable shulker boxes
+        if (j > top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1) - itemstack1.getCount()) {
+            k = top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1) - itemstack1.getCount();
         }
+        // Leaves start - stackable shulker boxes
 
         if (k > this.getMaxStackSize() - itemstack1.getCount()) {
             k = this.getMaxStackSize() - itemstack1.getCount();
@@ -403,7 +405,7 @@ public class Inventory implements Container, Nameable {
                 }
 
                 if (i != -1) {
-                    int j = stack.getMaxStackSize() - this.getItem(i).getCount();
+                    int j = top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(stack) - this.getItem(i).getCount(); // Leaves - stackable shulker boxes
 
                     if (this.add(i, stack.split(j)) && notifiesClient && this.player instanceof ServerPlayer) {
                         ((ServerPlayer) this.player).connection.send(new ClientboundContainerSetSlotPacket(-2, 0, i, this.getItem(i)));
@@ -681,21 +683,35 @@ public class Inventory implements Container, Nameable {
     }
 
     public boolean contains(ItemStack stack) {
-        Iterator iterator = this.compartments.iterator();
+        // Leaves start - don't allocate iterators
+        if (top.leavesmc.leaves.LeavesConfig.removeInventoryContainsIterators) {
+            for (int i = 0; i < this.compartments.size(); i++) {
+                List<ItemStack> list = this.compartments.get(i);
+                for (int j = 0; j < list.size(); j++) {
+                    ItemStack itemstack1 = list.get(j);
+
+                    if (!itemstack1.isEmpty() && ItemStack.isSameItemSameTags(itemstack1, stack)) {
+                        return true;
+                    }
+                }
+            }
+        } else {
+            Iterator iterator = this.compartments.iterator();
 
-        while (iterator.hasNext()) {
-            List<ItemStack> list = (List) iterator.next();
-            Iterator iterator1 = list.iterator();
+            while (iterator.hasNext()) {
+                List<ItemStack> list = (List) iterator.next();
+                Iterator iterator1 = list.iterator();
 
-            while (iterator1.hasNext()) {
-                ItemStack itemstack1 = (ItemStack) iterator1.next();
+                while (iterator1.hasNext()) {
+                    ItemStack itemstack1 = (ItemStack) iterator1.next();
 
-                if (!itemstack1.isEmpty() && ItemStack.isSameItemSameTags(itemstack1, stack)) {
-                    return true;
+                    if (!itemstack1.isEmpty() && ItemStack.isSameItemSameTags(itemstack1, stack)) {
+                        return true;
+                    }
                 }
             }
         }
-
+        // Leaves end - don't allocate iterators
         return false;
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index 58152160d609d0e9d105153aeb166a56a7955603..25e00eaf8971da42ee26ce3f0e3ea17cfc082f1a 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -187,6 +187,7 @@ public abstract class Player extends LivingEntity {
     public boolean affectsSpawning = true;
     public net.kyori.adventure.util.TriState flyingFallDamage = net.kyori.adventure.util.TriState.NOT_SET;
     // Paper end
+    public boolean elytraAeronauticsNoChunk = false; // Leaves - Elytra aeronautics
 
     // CraftBukkit start
     public boolean fauxSleeping;
@@ -242,8 +243,8 @@ public abstract class Player extends LivingEntity {
 
     @Override
     public void tick() {
-        this.noPhysics = this.isSpectator();
-        if (this.isSpectator()) {
+        this.noPhysics = this.isCreativeFlyOrSpectator(); // Leaves - creative no clip
+        if (this.isCreativeFlyOrSpectator()) { // Leaves - creative no clip
             this.setOnGround(false);
         }
 
@@ -415,7 +416,7 @@ public abstract class Player extends LivingEntity {
 
             Pose entitypose1;
 
-            if (!this.isSpectator() && !this.isPassenger() && !this.canEnterPose(entitypose)) {
+            if (!this.isCreativeFlyOrSpectator() && !this.isPassenger() && !this.canEnterPose(entitypose)) { // Leaves - creative no clip
                 if (this.canEnterPose(Pose.CROUCHING)) {
                     entitypose1 = Pose.CROUCHING;
                 } else {
@@ -576,7 +577,7 @@ public abstract class Player extends LivingEntity {
         }
 
         this.bob += (f - this.bob) * 0.4F;
-        if (this.getHealth() > 0.0F && !this.isSpectator()) {
+        if (this.getHealth() > 0.0F && !this.isCreativeFlyOrSpectator()) { // Leaves - creative no clip
             AABB axisalignedbb;
 
             if (this.isPassenger() && !this.getVehicle().isRemoved()) {
@@ -2130,6 +2131,12 @@ public abstract class Player extends LivingEntity {
     @Override
     public abstract boolean isSpectator();
 
+    // Leaves start - creative no clip
+    public boolean isCreativeFlyOrSpectator() {
+        return isSpectator() || (top.leavesmc.leaves.LeavesConfig.creativeNoClip && isCreative() && getAbilities().flying);
+    }
+    // Leaves end - creative no clip
+
     @Override
     public boolean canBeHitByProjectile() {
         return !this.isSpectator() && super.canBeHitByProjectile();
diff --git a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
index b8c238287e0639b578170c6fec0d4db5a1a59fe7..d57e6c88524482b4d37930d0fd2e9f7911c6d3a0 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
@@ -61,7 +61,7 @@ public class FishingHook extends Projectile {
     public static final EntityDataAccessor<Integer> DATA_HOOKED_ENTITY = SynchedEntityData.defineId(FishingHook.class, EntityDataSerializers.INT);
     private static final EntityDataAccessor<Boolean> DATA_BITING = SynchedEntityData.defineId(FishingHook.class, EntityDataSerializers.BOOLEAN);
     private int life;
-    private int nibble;
+    public int nibble; // Leaves - private -> public
     public int timeUntilLured;
     private int timeUntilHooked;
     private float fishAngle;
diff --git a/src/main/java/net/minecraft/world/entity/projectile/Snowball.java b/src/main/java/net/minecraft/world/entity/projectile/Snowball.java
index 718e120c9768cf716b32d3d652f53f1dda925168..21f5c59e7e01ffefdb077d1aa9853935a8fa6b0f 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/Snowball.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/Snowball.java
@@ -3,6 +3,7 @@ package net.minecraft.world.entity.projectile;
 import net.minecraft.core.particles.ItemParticleOption;
 import net.minecraft.core.particles.ParticleOptions;
 import net.minecraft.core.particles.ParticleTypes;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.LivingEntity;
@@ -55,6 +56,12 @@ public class Snowball extends ThrowableItemProjectile {
         Entity entity = entityHitResult.getEntity();
         int i = entity instanceof Blaze ? 3 : 0;
         entity.hurt(this.damageSources().thrown(this, this.getOwner()), (float)i);
+        // Leaves start - make snowball can knockback player
+        if (top.leavesmc.leaves.LeavesConfig.snowballAndEggCanKnockback && entity instanceof ServerPlayer) {
+            entity.hurt(this.damageSources().thrown(this, this.getOwner()), 0.0000001F);
+            ((ServerPlayer) entity).knockback(0.4000000059604645D, this.getX() - entity.getX(), this.getZ() - entity.getZ(), this);
+        }
+        // Leaves end - make snowball can knockback player
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/projectile/ThrownEgg.java b/src/main/java/net/minecraft/world/entity/projectile/ThrownEgg.java
index 588e5ac6fc9b2d12be3bb80bc3fe50d81470c441..e79d994bb855626e740e23de564f73924a1f5098 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/ThrownEgg.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/ThrownEgg.java
@@ -45,7 +45,14 @@ public class ThrownEgg extends ThrowableItemProjectile {
     @Override
     protected void onHitEntity(EntityHitResult entityHitResult) {
         super.onHitEntity(entityHitResult);
+        Entity entity = entityHitResult.getEntity(); // Leaves - make egg can knockback player
         entityHitResult.getEntity().hurt(this.damageSources().thrown(this, this.getOwner()), 0.0F);
+        // Leaves start - make egg can knockback player
+        if (top.leavesmc.leaves.LeavesConfig.snowballAndEggCanKnockback && entity instanceof ServerPlayer) {
+            entity.hurt(this.damageSources().thrown(this, this.getOwner()), 0.0000001F);
+            ((ServerPlayer) entity).knockback(0.4000000059604645D, this.getX() - entity.getX(), this.getZ() - entity.getZ(), this);
+        }
+        // Leaves end - make egg can knockback player
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/raid/Raid.java b/src/main/java/net/minecraft/world/entity/raid/Raid.java
index f7399737548483905f3b5c08a03876b0da54b714..dc3aed4130b78e91382a6e973ae83ea4a0524f41 100644
--- a/src/main/java/net/minecraft/world/entity/raid/Raid.java
+++ b/src/main/java/net/minecraft/world/entity/raid/Raid.java
@@ -689,7 +689,14 @@ public class Raid {
         this.level.getRaids().setDirty();
     }
 
+    // Leaves start - cache ominous banner item
+    public static final ItemStack LEADER_BANNER = createLeaderBanner();
     public static ItemStack getLeaderBannerInstance() {
+        return top.leavesmc.leaves.LeavesConfig.cacheOminousBannerItem ? LEADER_BANNER.copy() : createLeaderBanner();
+    }
+    // Leaves end - cache ominous banner item
+
+    public static ItemStack createLeaderBanner() { // Leaves - cache ominous banner item
         ItemStack itemstack = new ItemStack(Items.WHITE_BANNER);
         CompoundTag nbttagcompound = new CompoundTag();
         ListTag nbttaglist = (new BannerPattern.Builder()).addPattern(BannerPatterns.RHOMBUS_MIDDLE, DyeColor.CYAN).addPattern(BannerPatterns.STRIPE_BOTTOM, DyeColor.LIGHT_GRAY).addPattern(BannerPatterns.STRIPE_CENTER, DyeColor.GRAY).addPattern(BannerPatterns.BORDER, DyeColor.LIGHT_GRAY).addPattern(BannerPatterns.STRIPE_MIDDLE, DyeColor.BLACK).addPattern(BannerPatterns.HALF_HORIZONTAL, DyeColor.LIGHT_GRAY).addPattern(BannerPatterns.CIRCLE_MIDDLE, DyeColor.LIGHT_GRAY).addPattern(BannerPatterns.BORDER, DyeColor.BLACK).toListTag();
diff --git a/src/main/java/net/minecraft/world/entity/raid/Raider.java b/src/main/java/net/minecraft/world/entity/raid/Raider.java
index 57fdcdaf54fd1c92a6e51a3a81789029096e5abe..f3029db1e2a16619def35f1bf7807dd1052d3036 100644
--- a/src/main/java/net/minecraft/world/entity/raid/Raider.java
+++ b/src/main/java/net/minecraft/world/entity/raid/Raider.java
@@ -47,7 +47,7 @@ public abstract class Raider extends PatrollingMonster {
 
     protected static final EntityDataAccessor<Boolean> IS_CELEBRATING = SynchedEntityData.defineId(Raider.class, EntityDataSerializers.BOOLEAN);
     static final Predicate<ItemEntity> ALLOWED_ITEMS = (entityitem) -> {
-        return !entityitem.hasPickUpDelay() && entityitem.isAlive() && ItemStack.matches(entityitem.getItem(), Raid.getLeaderBannerInstance());
+        return !entityitem.hasPickUpDelay() && entityitem.isAlive() && ItemStack.matches(entityitem.getItem(), top.leavesmc.leaves.LeavesConfig.cacheOminousBannerItem ? Raid.LEADER_BANNER : Raid.getLeaderBannerInstance()); // Leaves - cache ominous banner item
     };
     @Nullable
     protected Raid raid;
@@ -134,7 +134,7 @@ public abstract class Raider extends PatrollingMonster {
                 raid.removeFromRaid(this, false);
             }
 
-            if (this.isPatrolLeader() && raid == null && ((ServerLevel) this.level()).getRaidAt(this.blockPosition()) == null) {
+            if (this.isPatrolLeader() && (top.leavesmc.leaves.LeavesConfig.skipSelfRaidCheck || raid == null) && ((ServerLevel) this.level()).getRaidAt(this.blockPosition()) == null) { // Leaves - skip self raid check
                 ItemStack itemstack = this.getItemBySlot(EquipmentSlot.HEAD);
                 Player entityhuman = null;
 
@@ -149,7 +149,7 @@ public abstract class Raider extends PatrollingMonster {
                     }
                 }
 
-                if (!itemstack.isEmpty() && ItemStack.matches(itemstack, Raid.getLeaderBannerInstance()) && entityhuman != null) {
+                if (!itemstack.isEmpty() && ItemStack.matches(itemstack, top.leavesmc.leaves.LeavesConfig.cacheOminousBannerItem ? Raid.LEADER_BANNER : Raid.getLeaderBannerInstance()) && entityhuman != null) { // Leaves - cache ominous banner item
                     MobEffectInstance mobeffect = entityhuman.getEffect(MobEffects.BAD_OMEN);
                     byte b0 = 1;
                     int i;
@@ -244,7 +244,7 @@ public abstract class Raider extends PatrollingMonster {
         ItemStack itemstack = item.getItem();
         boolean flag = this.hasActiveRaid() && this.getCurrentRaid().getLeader(this.getWave()) != null;
 
-        if (this.hasActiveRaid() && !flag && ItemStack.matches(itemstack, Raid.getLeaderBannerInstance())) {
+        if (this.hasActiveRaid() && !flag && ItemStack.matches(itemstack, top.leavesmc.leaves.LeavesConfig.cacheOminousBannerItem ? Raid.LEADER_BANNER : Raid.getLeaderBannerInstance())) { // Leaves - cache ominous banner item
             // Paper start
             if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityPickupItemEvent(this, item, 0, false).isCancelled()) {
                 return;
@@ -322,7 +322,7 @@ public abstract class Raider extends PatrollingMonster {
             if (!this.mob.level().getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING) || !this.mob.canPickUpLoot()) return false; // Paper - respect game and entity rules for picking up items
             Raid raid = this.mob.getCurrentRaid();
 
-            if (this.mob.hasActiveRaid() && !this.mob.getCurrentRaid().isOver() && this.mob.canBeLeader() && !ItemStack.matches(this.mob.getItemBySlot(EquipmentSlot.HEAD), Raid.getLeaderBannerInstance())) {
+            if (this.mob.hasActiveRaid() && !this.mob.getCurrentRaid().isOver() && this.mob.canBeLeader() && !ItemStack.matches(this.mob.getItemBySlot(EquipmentSlot.HEAD), top.leavesmc.leaves.LeavesConfig.cacheOminousBannerItem ? Raid.LEADER_BANNER : Raid.getLeaderBannerInstance())) { // Leaves - cache ominous banner item
                 Raider entityraider = raid.getLeader(this.mob.getWave());
 
                 if (entityraider == null || !entityraider.isAlive()) {
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java b/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java
index 272095d7a09ab41227d741172735f66fd2798ce1..f6acbef804a50c58f4298ebeae4fdbebaf129e1c 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java
@@ -129,7 +129,13 @@ public abstract class AbstractMinecartContainer extends AbstractMinecart impleme
     }
 
     @Override
-    public void setChanged() {}
+    public void setChanged() {
+        // Leaves start - pca
+        if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncEntityToClient(this);
+        }
+        // Leaves end - pca
+    }
 
     @Override
     public boolean stillValid(Player player) {
diff --git a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
index 706b354ac9a1a6a4a1e61b2a109180d1dd22bbbd..4ab69a9962bf7642446d952bc6c70c92d716311b 100644
--- a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -30,8 +30,10 @@ import net.minecraft.world.entity.SlotAccess;
 import net.minecraft.world.entity.player.Inventory;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.flag.FeatureFlagSet;
+import net.minecraft.world.item.BlockItem;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.ShulkerBoxBlock;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import org.slf4j.Logger;
 
@@ -406,6 +408,8 @@ public abstract class AbstractContainerMenu {
         ItemStack itemstack1;
         int l;
 
+        if (!doClickCheck(slotIndex, button, actionType, player)) return; // Leaves - doClick check
+
         if (actionType == ClickType.QUICK_CRAFT) {
             int i1 = this.quickcraftStatus;
 
@@ -453,7 +457,7 @@ public abstract class AbstractContainerMenu {
 
                         if (slot1 != null && AbstractContainerMenu.canItemQuickReplace(slot1, itemstack2, true) && slot1.mayPlace(itemstack2) && (this.quickcraftType == 2 || itemstack2.getCount() >= this.quickcraftSlots.size()) && this.canDragTo(slot1)) {
                             int j1 = slot1.hasItem() ? slot1.getItem().getCount() : 0;
-                            int k1 = Math.min(itemstack1.getMaxStackSize(), slot1.getMaxStackSize(itemstack1));
+                            int k1 = Math.min(top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1), slot1.getMaxStackSize(itemstack1)); // Leaves - stackable shulker boxes                            int l1 = Math.min(AbstractContainerMenu.getQuickCraftPlaceCount(this.quickcraftSlots, this.quickcraftType, itemstack1) + j1, k1);
                             int l1 = Math.min(AbstractContainerMenu.getQuickCraftPlaceCount(this.quickcraftSlots, this.quickcraftType, itemstack1) + j1, k1);
 
                             l -= l1 - j1;
@@ -572,7 +576,7 @@ public abstract class AbstractContainerMenu {
                                     slot.setByPlayer(itemstack3);
                                 }
                             } else if (ItemStack.isSameItemSameTags(itemstack, itemstack3)) {
-                                Optional<ItemStack> optional1 = slot.tryRemove(itemstack.getCount(), itemstack3.getMaxStackSize() - itemstack3.getCount(), player);
+                                Optional<ItemStack> optional1 = slot.tryRemove(itemstack.getCount(), top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack3) - itemstack3.getCount(), player);
 
                                 optional1.ifPresent((itemstack4) -> {
                                     itemstack3.grow(itemstack4.getCount());
@@ -638,7 +642,7 @@ public abstract class AbstractContainerMenu {
                     slot2 = (Slot) this.slots.get(slotIndex);
                     if (slot2.hasItem()) {
                         itemstack1 = slot2.getItem();
-                        this.setCarried(itemstack1.copyWithCount(itemstack1.getMaxStackSize()));
+                        this.setCarried(itemstack1.copyWithCount(top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1))); // Leaves - stackable shulker boxes
                     }
                 } else if (actionType == ClickType.THROW && this.getCarried().isEmpty() && slotIndex >= 0) {
                     slot2 = (Slot) this.slots.get(slotIndex);
@@ -653,14 +657,14 @@ public abstract class AbstractContainerMenu {
                         j2 = button == 0 ? 1 : -1;
 
                         for (i2 = 0; i2 < 2; ++i2) {
-                            for (int k2 = l; k2 >= 0 && k2 < this.slots.size() && itemstack1.getCount() < itemstack1.getMaxStackSize(); k2 += j2) {
+                            for (int k2 = l; k2 >= 0 && k2 < this.slots.size() && itemstack1.getCount() < top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1); k2 += j2) { // Leaves - stackable shulker boxes
                                 Slot slot3 = (Slot) this.slots.get(k2);
 
                                 if (slot3.hasItem() && AbstractContainerMenu.canItemQuickReplace(slot3, itemstack1, true) && slot3.mayPickup(player) && this.canTakeItemForPickAll(itemstack1, slot3)) {
                                     ItemStack itemstack4 = slot3.getItem();
 
-                                    if (i2 != 0 || itemstack4.getCount() != itemstack4.getMaxStackSize()) {
-                                        ItemStack itemstack5 = slot3.safeTake(itemstack4.getCount(), itemstack1.getMaxStackSize() - itemstack1.getCount(), player);
+                                    if (i2 != 0 || itemstack4.getCount() != top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack4)) { // Leaves - stackable shulker boxes
+                                        ItemStack itemstack5 = slot3.safeTake(itemstack4.getCount(), top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1) - itemstack1.getCount(), player); // Leaves - stackable shulker boxes
 
                                         itemstack1.grow(itemstack5.getCount());
                                     }
@@ -674,6 +678,23 @@ public abstract class AbstractContainerMenu {
 
     }
 
+    // Leaves start - doClick check
+    private boolean doClickCheck(int slotIndex, int button, ClickType actionType, Player player) {
+        if (slotIndex < 0) {
+            return true;
+        }
+
+        Slot slot = getSlot(slotIndex);
+        ItemStack itemStack = slot.getItem();
+        if (itemStack.getTag() != null) {
+            if (itemStack.getTag().get("Leaves.Gui.Placeholder") != null) {
+                return !itemStack.getTag().getBoolean("Leaves.Gui.Placeholder");
+            }
+        }
+        return true;
+    }
+    // Leaves end - doClick check
+
     private boolean tryItemClickBehaviourOverride(Player player, ClickAction clickType, Slot slot, ItemStack stack, ItemStack cursorStack) {
         FeatureFlagSet featureflagset = player.level().enabledFeatures();
 
@@ -780,7 +801,7 @@ public abstract class AbstractContainerMenu {
         Slot slot;
         ItemStack itemstack1;
 
-        if (stack.isStackable()) {
+        if (top.leavesmc.leaves.util.ShulkerBoxUtils.isStackable(stack)) { // Leaves - stackable shulker boxes
             while (!stack.isEmpty()) {
                 if (fromLast) {
                     if (k < startIndex) {
@@ -800,16 +821,18 @@ public abstract class AbstractContainerMenu {
                 if (!itemstack1.isEmpty() && ItemStack.isSameItemSameTags(stack, itemstack1)) {
                     int l = itemstack1.getCount() + stack.getCount();
 
-                    if (l <= stack.getMaxStackSize()) {
+                    if (l <= top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(stack)) { // Leaves - stackable shulker boxes
                         stack.setCount(0);
                         itemstack1.setCount(l);
                         if (!isCheck) { // Paper - dont update if only a check
                         slot.setChanged();
                         } // Paper
                         flag1 = true;
-                    } else if (itemstack1.getCount() < stack.getMaxStackSize()) {
-                        stack.shrink(stack.getMaxStackSize() - itemstack1.getCount());
-                        itemstack1.setCount(stack.getMaxStackSize());
+                        // Leaves start - stackable shulker boxes
+                    } else if (itemstack1.getCount() < top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(stack)) {
+                        stack.shrink(top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(stack) - itemstack1.getCount());
+                        itemstack1.setCount(top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(stack));
+                        // Leaves end - stackable shulker boxes
                         if (!isCheck) { // Paper - dont update if only a check
                         slot.setChanged();
                         } // Paper
diff --git a/src/main/java/net/minecraft/world/inventory/AnvilMenu.java b/src/main/java/net/minecraft/world/inventory/AnvilMenu.java
index e0c3a4ba27e21c3692e601acd0af60873bcbb84c..b9fcf49ed88c62265d9aa8926c1228b96bf314b6 100644
--- a/src/main/java/net/minecraft/world/inventory/AnvilMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/AnvilMenu.java
@@ -293,7 +293,7 @@ public class AnvilMenu extends ItemCombinerMenu {
                 this.cost.set(this.maximumRepairCost - 1); // CraftBukkit
             }
 
-            if (this.cost.get() >= this.maximumRepairCost && !this.player.getAbilities().instabuild) { // CraftBukkit
+            if (this.cost.get() >= this.maximumRepairCost && (!top.leavesmc.leaves.LeavesConfig.avoidAnvilTooExpensive || this.cost.get() == DEFAULT_DENIED_COST) && !this.player.getAbilities().instabuild) { // CraftBukkit // Leaves - avoid anvil too expensive
                 itemstack1 = ItemStack.EMPTY;
             }
 
diff --git a/src/main/java/net/minecraft/world/inventory/Slot.java b/src/main/java/net/minecraft/world/inventory/Slot.java
index 92699f79f19b4dcd7d349976cedc0408836263a6..6c979ee6c7a12111fe4380bbb0abc285dc7c264b 100644
--- a/src/main/java/net/minecraft/world/inventory/Slot.java
+++ b/src/main/java/net/minecraft/world/inventory/Slot.java
@@ -73,7 +73,7 @@ public class Slot {
     }
 
     public int getMaxStackSize(ItemStack stack) {
-        return Math.min(this.getMaxStackSize(), stack.getMaxStackSize());
+        return Math.min(this.getMaxStackSize(), top.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(stack)); // Leaves - stackable shulker boxes
     }
 
     @Nullable
diff --git a/src/main/java/net/minecraft/world/item/BlockItem.java b/src/main/java/net/minecraft/world/item/BlockItem.java
index ebee8de2ed831755b6fd154f6cc77ac993839bb9..437ed8d4cba5e3393ac6370f6b8e364e4b7d9042 100644
--- a/src/main/java/net/minecraft/world/item/BlockItem.java
+++ b/src/main/java/net/minecraft/world/item/BlockItem.java
@@ -32,9 +32,12 @@ import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.Property;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.phys.shapes.CollisionContext;
+import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.event.block.BlockCanBuildEvent;
+import top.leavesmc.leaves.event.player.PlayerOperationLimitEvent;
 // CraftBukkit end
 
 public class BlockItem extends Item {
@@ -83,6 +86,20 @@ public class BlockItem extends Item {
                 final org.bukkit.block.BlockState oldBlockstate = blockstate != null ? blockstate : org.bukkit.craftbukkit.block.CraftBlockStates.getBlockState(blockactioncontext1.getLevel(), blockactioncontext1.getClickedPos()); // Paper
                 // CraftBukkit end
 
+                // Leaves start - player operation limiter
+                if (top.leavesmc.leaves.LeavesConfig.playerOperationLimiter && !context.getLevel().isClientSide()) {
+                    ServerPlayer player = (ServerPlayer) context.getPlayer();
+                    if (player != null && iblockdata != null) {
+                        player.addPlaceBlockCountPerTick();
+                        if (!player.allowOperation()) {
+                            if (blockstate != null) {
+                                MinecraftServer.getServer().server.getPluginManager().callEvent(new PlayerOperationLimitEvent(player.getBukkitEntity(), PlayerOperationLimitEvent.Operation.PLACE, blockstate.getBlock()));
+                            }
+                            return InteractionResult.FAIL;
+                        }
+                    }
+                }
+                // Leaves end - player operation limiter
                 if (iblockdata == null) {
                     return InteractionResult.FAIL;
                 } else if (!this.placeBlock(blockactioncontext1, iblockdata)) {
@@ -158,7 +175,7 @@ public class BlockItem extends Item {
 
     @Nullable
     protected BlockState getPlacementState(BlockPlaceContext context) {
-        BlockState iblockdata = this.getBlock().getStateForPlacement(context);
+        BlockState iblockdata = this.getBlock().getRealStateForPlacement(context); // Leaves - carpetAlternativeBlockPlacement
 
         return iblockdata != null && this.canPlace(context, iblockdata) ? iblockdata : null;
     }
diff --git a/src/main/java/net/minecraft/world/item/BowItem.java b/src/main/java/net/minecraft/world/item/BowItem.java
index 08d597db1a5345a343777a01427655e6bf2c926b..d4127e4b437960670d5c91179a726b433659b317 100644
--- a/src/main/java/net/minecraft/world/item/BowItem.java
+++ b/src/main/java/net/minecraft/world/item/BowItem.java
@@ -130,7 +130,7 @@ public class BowItem extends ProjectileWeaponItem implements Vanishable {
     @Override
     public InteractionResultHolder<ItemStack> use(Level world, Player user, InteractionHand hand) {
         ItemStack itemstack = user.getItemInHand(hand);
-        boolean flag = !user.getProjectile(itemstack).isEmpty();
+        boolean flag = !user.getProjectile(itemstack).isEmpty() || (top.leavesmc.leaves.LeavesConfig.bowInfinityFix && EnchantmentHelper.getItemEnchantmentLevel(Enchantments.INFINITY_ARROWS, itemstack) > 0);
 
         if (!user.getAbilities().instabuild && !flag) {
             return InteractionResultHolder.fail(itemstack);
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index 86304357ca687036cf2448f8cd7c639bdc309e25..0f4ec67c1660755f268c527a96cb8030e8830ec9 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -449,7 +449,7 @@ public final class ItemStack {
                         net.minecraft.world.level.block.state.BlockState block = world.getBlockState(newblockposition);
 
                         if (!(block.getBlock() instanceof BaseEntityBlock)) { // Containers get placed automatically
-                            block.getBlock().onPlace(block, world, newblockposition, oldBlock, true, context); // Paper - pass context
+                            if (!top.leavesmc.leaves.command.NoBlockUpdateCommand.isNoBlockUpdate()) block.getBlock().onPlace(block, world, newblockposition, oldBlock, true, context); // Paper - pass context // Leaves - no block update
                         }
 
                         world.notifyAndUpdatePhysics(newblockposition, null, oldBlock, block, world.getBlockState(newblockposition), updateFlag, 512); // send null chunk as chunk.k() returns false by this point
@@ -1015,7 +1015,7 @@ public final class ItemStack {
         int k;
 
         if (ItemStack.shouldShowInTooltip(i, ItemStack.TooltipPart.MODIFIERS)) {
-            EquipmentSlot[] aenumitemslot = EquipmentSlot.values();
+            EquipmentSlot[] aenumitemslot = EquipmentSlot.VALUES; // Leaves - reduce array allocations
 
             k = aenumitemslot.length;
 
diff --git a/src/main/java/net/minecraft/world/item/ShearsItem.java b/src/main/java/net/minecraft/world/item/ShearsItem.java
index a6ebb08a8f9681fd3a35de5d0e268f320e31ce1a..7c3c3a28a95c58caa83e283cdbb472b2499a8f7b 100644
--- a/src/main/java/net/minecraft/world/item/ShearsItem.java
+++ b/src/main/java/net/minecraft/world/item/ShearsItem.java
@@ -1,7 +1,9 @@
 package net.minecraft.world.item;
 
+import net.minecraft.Util;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.core.BlockPos;
+import net.minecraft.network.chat.Component;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
@@ -14,9 +16,19 @@ import net.minecraft.world.item.context.UseOnContext;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.ComparatorBlock;
+import net.minecraft.world.level.block.DispenserBlock;
 import net.minecraft.world.level.block.GrowingPlantHeadBlock;
+import net.minecraft.world.level.block.HopperBlock;
+import net.minecraft.world.level.block.ObserverBlock;
+import net.minecraft.world.level.block.RepeaterBlock;
+import net.minecraft.world.level.block.piston.PistonBaseBlock;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.gameevent.GameEvent;
+import net.minecraft.world.level.block.state.StateDefinition;
+import net.minecraft.world.level.block.state.properties.Property;
+
+import javax.annotation.Nullable;
 
 public class ShearsItem extends Item {
     public ShearsItem(Item.Properties settings) {
@@ -80,6 +92,59 @@ public class ShearsItem extends Item {
             }
         }
 
+        // Leaves start - shears wrench
+        if (top.leavesmc.leaves.LeavesConfig.redstoneShearsWrench && block instanceof ObserverBlock || block instanceof DispenserBlock ||
+            block instanceof PistonBaseBlock || block instanceof HopperBlock || block instanceof RepeaterBlock || block instanceof ComparatorBlock) {
+            StateDefinition<Block, BlockState> blockstatelist = block.getStateDefinition();
+            Property<?> iblockstate = blockstatelist.getProperty("facing");
+            Player player = context.getPlayer();
+
+            if (iblockstate == null || player == null) {
+                return InteractionResult.FAIL;
+            }
+
+            if (block instanceof PistonBaseBlock) {
+                if (getNameHelper(blockState, blockstatelist.getProperty("extended")).equals("true")) {
+                    return InteractionResult.FAIL;
+                }
+            }
+
+            if (block instanceof RepeaterBlock || block instanceof ComparatorBlock) {
+                if (getNameHelper(blockState, blockstatelist.getProperty("powered")).equals("true")) {
+                    return InteractionResult.FAIL;
+                }
+                if (block instanceof RepeaterBlock) {
+                    if (getNameHelper(blockState, blockstatelist.getProperty("locked")).equals("true")) {
+                        return InteractionResult.FAIL;
+                    }
+                }
+            }
+
+            BlockState iblockdata1 = ShearsItem.cycleState(blockState, iblockstate, player.isSecondaryUseActive());
+            level.setBlock(blockPos, iblockdata1, 18);
+            ShearsItem.message(player, Component.translatable("item.minecraft.debug_stick.update", iblockstate.getName(), ShearsItem.getNameHelper(iblockdata1, iblockstate)));
+            return InteractionResult.CONSUME_PARTIAL;
+        }
+        // Leaves end - shears wrench
+
         return super.useOn(context);
     }
+
+    // Leaves start - shears wrench
+    private static <T extends Comparable<T>> BlockState cycleState(BlockState state, Property<T> property, boolean inverse) {
+        return (BlockState) state.setValue(property, ShearsItem.getRelative(property.getPossibleValues(), state.getValue(property), inverse)); // CraftBukkit - decompile error
+    }
+
+    private static <T> T getRelative(Iterable<T> elements, @Nullable T current, boolean inverse) {
+        return inverse ? Util.findPreviousInIterable(elements, current) : Util.findNextInIterable(elements, current);
+    }
+
+    private static void message(Player player, Component message) {
+        ((ServerPlayer) player).sendSystemMessage(message, true);
+    }
+
+    private static <T extends Comparable<T>> String getNameHelper(BlockState state, Property<T> property) {
+        return property.getName(state.getValue(property));
+    }
+    // Leaves end - shears wrench
 }
diff --git a/src/main/java/net/minecraft/world/item/ShovelItem.java b/src/main/java/net/minecraft/world/item/ShovelItem.java
index 21212462e6b415e96536a27b2c009d1562f18946..b620a6fe52bd1f86ca24f79e1ebf8879aed33961 100644
--- a/src/main/java/net/minecraft/world/item/ShovelItem.java
+++ b/src/main/java/net/minecraft/world/item/ShovelItem.java
@@ -11,10 +11,12 @@ import net.minecraft.tags.BlockTags;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.context.UseOnContext;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.CampfireBlock;
+import net.minecraft.world.level.block.SnowLayerBlock;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.gameevent.GameEvent;
 
@@ -34,6 +36,22 @@ public class ShovelItem extends DiggerItem {
             return InteractionResult.PASS;
         } else {
             Player player = context.getPlayer();
+            // Leaves start - shaveSnowLayers
+            if (top.leavesmc.leaves.LeavesConfig.shaveSnowLayers && blockState.is(Blocks.SNOW)) {
+                int layers = blockState.getValue(SnowLayerBlock.LAYERS);
+                level.setBlock(blockPos, layers > 1 ? blockState.setValue(SnowLayerBlock.LAYERS, layers - 1) : Blocks.AIR.defaultBlockState(), 11);
+                Block.popResource(level, blockPos, new ItemStack(EnchantmentHelper.hasSilkTouch(context.getItemInHand()) ? Items.SNOW : Items.SNOWBALL));
+                level.playSound(player, blockPos, SoundEvents.SNOW_BREAK, SoundSource.BLOCKS, 1.0F, 1.0F);
+
+                if(player != null) {
+                    context.getItemInHand().hurtAndBreak(1, player, (p) -> {
+                        p.broadcastBreakEvent(context.getHand());
+                    });
+                }
+
+                return InteractionResult.SUCCESS;
+            }
+            // Leaves end -  shaveSnowLayers
             BlockState blockState2 = FLATTENABLES.get(blockState.getBlock());
             BlockState blockState3 = null;
             Runnable afterAction = null; // Paper
diff --git a/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java b/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java
index 39b8b3675ac58409e05fac07e07c8016c5280d81..928b1ece5b094dee8a5e37bfd3afd626cb1bd03a 100644
--- a/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java
+++ b/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java
@@ -34,7 +34,7 @@ public class StandingAndWallBlockItem extends BlockItem {
     @Nullable
     @Override
     protected BlockState getPlacementState(BlockPlaceContext context) {
-        BlockState iblockdata = this.wallBlock.getStateForPlacement(context);
+        BlockState iblockdata = this.wallBlock.getRealStateForPlacement(context); // Leaves - carpetAlternativeBlockPlacement
         BlockState iblockdata1 = null;
         Level world = context.getLevel();
         BlockPos blockposition = context.getClickedPos();
@@ -45,7 +45,7 @@ public class StandingAndWallBlockItem extends BlockItem {
             Direction enumdirection = aenumdirection[j];
 
             if (enumdirection != this.attachmentDirection.getOpposite()) {
-                BlockState iblockdata2 = enumdirection == this.attachmentDirection ? this.getBlock().getStateForPlacement(context) : iblockdata;
+                BlockState iblockdata2 = enumdirection == this.attachmentDirection ? this.getBlock().getRealStateForPlacement(context) : iblockdata; // Leaves - carpetAlternativeBlockPlacement
 
                 if (iblockdata2 != null && this.canPlace(world, iblockdata2, blockposition)) {
                     iblockdata1 = iblockdata2;
diff --git a/src/main/java/net/minecraft/world/item/TridentItem.java b/src/main/java/net/minecraft/world/item/TridentItem.java
index 8078f127ff4b6e0aafb5804b9c02e237f79445b5..801f066878d6ffe5dabe01d20513db9022b323ec 100644
--- a/src/main/java/net/minecraft/world/item/TridentItem.java
+++ b/src/main/java/net/minecraft/world/item/TridentItem.java
@@ -66,7 +66,7 @@ public class TridentItem extends Item implements Vanishable {
             if (j >= 10) {
                 int k = EnchantmentHelper.getRiptide(stack);
 
-                if (k <= 0 || entityhuman.isInWaterOrRain()) {
+                if (k <= 0 || entityhuman.isInWaterOrRain() || (top.leavesmc.leaves.LeavesConfig.lavaRiptide && entityhuman.isInLava())) { // Leaves - lava riptide
                     if (!world.isClientSide) {
                         // CraftBukkit - moved down
                         /*
@@ -162,7 +162,7 @@ public class TridentItem extends Item implements Vanishable {
 
         if (itemstack.getDamageValue() >= itemstack.getMaxDamage() - 1) {
             return InteractionResultHolder.fail(itemstack);
-        } else if (EnchantmentHelper.getRiptide(itemstack) > 0 && !user.isInWaterOrRain()) {
+        } else if (EnchantmentHelper.getRiptide(itemstack) > 0 && !user.isInWaterOrRain() && !(top.leavesmc.leaves.LeavesConfig.lavaRiptide && user.isInLava())) { // Leaves - lava riptide
             return InteractionResultHolder.fail(itemstack);
         } else {
             user.startUsingItem(hand);
diff --git a/src/main/java/net/minecraft/world/item/crafting/ShapedRecipe.java b/src/main/java/net/minecraft/world/item/crafting/ShapedRecipe.java
index 9c1285e31d947f92e0b00149e342e793898e0d7c..e45d14998e2379ced1d7da9c6583b04469b13798 100644
--- a/src/main/java/net/minecraft/world/item/crafting/ShapedRecipe.java
+++ b/src/main/java/net/minecraft/world/item/crafting/ShapedRecipe.java
@@ -29,6 +29,7 @@ import org.bukkit.craftbukkit.inventory.CraftRecipe;
 import org.bukkit.craftbukkit.inventory.CraftShapedRecipe;
 import org.bukkit.inventory.RecipeChoice;
 // CraftBukkit end
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public class ShapedRecipe implements CraftingRecipe {
 
@@ -262,7 +263,7 @@ public class ShapedRecipe implements CraftingRecipe {
         }
 
         if (pattern.length == l) {
-            return new String[0];
+            return ArrayConstants.emptyStringArray; // Leaves - reduce array allocations
         } else {
             String[] astring1 = new String[pattern.length - l - k];
 
diff --git a/src/main/java/net/minecraft/world/item/crafting/ShapelessRecipe.java b/src/main/java/net/minecraft/world/item/crafting/ShapelessRecipe.java
index 7f174bb89bf4d700a5ae1b65d8abd4f5b1e7b5ed..fef23722a5abb56c5f0a24a785a312c0378a0500 100644
--- a/src/main/java/net/minecraft/world/item/crafting/ShapelessRecipe.java
+++ b/src/main/java/net/minecraft/world/item/crafting/ShapelessRecipe.java
@@ -27,13 +27,21 @@ public class ShapelessRecipe implements CraftingRecipe {
     final CraftingBookCategory category;
     final ItemStack result;
     final NonNullList<Ingredient> ingredients;
+    private final boolean isBukkit; // Leaves
 
     public ShapelessRecipe(ResourceLocation id, String group, CraftingBookCategory category, ItemStack output, NonNullList<Ingredient> input) {
+        // Leaves start
+        this(id, group, category, output, input, false);
+    }
+
+    public ShapelessRecipe(ResourceLocation id, String group, CraftingBookCategory category, ItemStack output, NonNullList<Ingredient> input, boolean isBukkit) {
+        // Leaves end
         this.id = id;
         this.group = group;
         this.category = category;
         this.result = output;
         this.ingredients = input;
+        this.isBukkit = isBukkit; // Leaves
     }
 
     // CraftBukkit start
@@ -82,6 +90,28 @@ public class ShapelessRecipe implements CraftingRecipe {
     }
 
     public boolean matches(CraftingContainer inventory, Level world) {
+        // Leaves start - easy match
+        if (top.leavesmc.leaves.LeavesConfig.simplerVanillaShapelessRecipes && !this.isBukkit) {
+            java.util.List<Ingredient> ingredients = com.google.common.collect.Lists.newArrayList(this.ingredients.toArray(new Ingredient[0]));
+
+            inventory: for (int index = 0; index < inventory.getContainerSize(); index++) {
+                ItemStack itemStack = inventory.getItem(index);
+
+                if (!itemStack.isEmpty()) {
+                    for (int i = 0; i < ingredients.size(); i++) {
+                        if (ingredients.get(i).test(itemStack)) {
+                            ingredients.remove(i);
+                            continue inventory;
+                        }
+                    }
+                    return false;
+                }
+            }
+
+            return ingredients.isEmpty();
+        }
+        // Leaves end - easy match
+
         StackedContents autorecipestackmanager = new StackedContents();
         int i = 0;
 
diff --git a/src/main/java/net/minecraft/world/item/enchantment/ArrowInfiniteEnchantment.java b/src/main/java/net/minecraft/world/item/enchantment/ArrowInfiniteEnchantment.java
index 518d85a13c37a2f7d32ca0718323181048559986..881d661326cbca3c5340a33a990f122737a37ef3 100644
--- a/src/main/java/net/minecraft/world/item/enchantment/ArrowInfiniteEnchantment.java
+++ b/src/main/java/net/minecraft/world/item/enchantment/ArrowInfiniteEnchantment.java
@@ -19,6 +19,6 @@ public class ArrowInfiniteEnchantment extends Enchantment {
 
     @Override
     public boolean checkCompatibility(Enchantment other) {
-        return other instanceof MendingEnchantment ? false : super.checkCompatibility(other);
+        return (!top.leavesmc.leaves.LeavesConfig.mendingCompatibilityInfinity && other instanceof MendingEnchantment) ? false : super.checkCompatibility(other); // Leaves - mendingCompatibilityInfinity
     }
 }
diff --git a/src/main/java/net/minecraft/world/item/enchantment/Enchantments.java b/src/main/java/net/minecraft/world/item/enchantment/Enchantments.java
index 2bfbdaeb2b0d99dfd956cd5936403fe8b0eeae64..7ad1545631604aa55f6d4fbdcbaefe6dc647f35c 100644
--- a/src/main/java/net/minecraft/world/item/enchantment/Enchantments.java
+++ b/src/main/java/net/minecraft/world/item/enchantment/Enchantments.java
@@ -44,8 +44,10 @@ public class Enchantments {
     public static final Enchantment MULTISHOT = Enchantments.register("multishot", new MultiShotEnchantment(Enchantment.Rarity.RARE, new EquipmentSlot[]{EquipmentSlot.MAINHAND}));
     public static final Enchantment QUICK_CHARGE = Enchantments.register("quick_charge", new QuickChargeEnchantment(Enchantment.Rarity.UNCOMMON, new EquipmentSlot[]{EquipmentSlot.MAINHAND}));
     public static final Enchantment PIERCING = Enchantments.register("piercing", new ArrowPiercingEnchantment(Enchantment.Rarity.COMMON, new EquipmentSlot[]{EquipmentSlot.MAINHAND}));
-    public static final Enchantment MENDING = Enchantments.register("mending", new MendingEnchantment(Enchantment.Rarity.RARE, EquipmentSlot.values()));
-    public static final Enchantment VANISHING_CURSE = Enchantments.register("vanishing_curse", new VanishingCurseEnchantment(Enchantment.Rarity.VERY_RARE, EquipmentSlot.values()));
+    // Leaves start - reduce array allocations
+    public static final Enchantment MENDING = Enchantments.register("mending", new MendingEnchantment(Enchantment.Rarity.RARE, EquipmentSlot.VALUES));
+    public static final Enchantment VANISHING_CURSE = Enchantments.register("vanishing_curse", new VanishingCurseEnchantment(Enchantment.Rarity.VERY_RARE, EquipmentSlot.VALUES));
+    // Leaves end - reduce array allocations
 
     public Enchantments() {}
 
diff --git a/src/main/java/net/minecraft/world/level/BlockGetter.java b/src/main/java/net/minecraft/world/level/BlockGetter.java
index 0e8746759752b692668886370181aa5db1fd0bb0..f5e92bd13154d7c39670a7d5188f6621f4a6fde8 100644
--- a/src/main/java/net/minecraft/world/level/BlockGetter.java
+++ b/src/main/java/net/minecraft/world/level/BlockGetter.java
@@ -68,6 +68,16 @@ public interface BlockGetter extends LevelHeightAccessor {
         });
     }
 
+    // Leaves start - broken down variant of below rayTraceBlock, used by World#rayTraceDirect
+    default net.minecraft.world.phys.BlockHitResult.Type rayTraceBlockDirect(Vec3 vec3d, Vec3 vec3d1, BlockPos blockposition, BlockState iblockdata, net.minecraft.world.phys.shapes.CollisionContext voxelshapecoll) {
+        if (iblockdata.isAir()) return null; // Tuinity - optimise air cases
+        VoxelShape voxelshape = ClipContext.Block.COLLIDER.get(iblockdata, this, blockposition, voxelshapecoll);
+        net.minecraft.world.phys.BlockHitResult movingobjectpositionblock = this.clipWithInteractionOverride(vec3d, vec3d1, blockposition, voxelshape, iblockdata);
+
+        return movingobjectpositionblock == null ? null : movingobjectpositionblock.getType();
+    }
+    // Leaves end - broken down variant of below rayTraceBlock, used by World#rayTraceDirect
+
     // CraftBukkit start - moved block handling into separate method for use by Block#rayTrace
     default BlockHitResult clip(ClipContext raytrace1, BlockPos blockposition) {
             // Paper start - Prevent raytrace from loading chunks
diff --git a/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java b/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java
index 2f9f15d99f8b31e9f13f7f32378b2a9e09bcb5e5..623f6713a5294ba54baf6319b222a2f35940d458 100644
--- a/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java
+++ b/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java
@@ -15,9 +15,21 @@ public class EntityBasedExplosionDamageCalculator extends ExplosionDamageCalcula
 
     @Override
     public Optional<Float> getBlockExplosionResistance(Explosion explosion, BlockGetter world, BlockPos pos, BlockState blockState, FluidState fluidState) {
-        return super.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState).map((max) -> {
-            return this.source.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState, max);
-        });
+        if (!top.leavesmc.leaves.LeavesConfig.removeDamageLambda) {
+            return super.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState).map((max) -> {
+                return this.source.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState, max);
+            });
+        } else {
+            Optional<Float> optionalBlastResistance = super.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState);
+            if (optionalBlastResistance.isPresent()) {
+                float blastResistance = optionalBlastResistance.get();
+                float effectiveExplosionResistance = this.source.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState, blastResistance);
+                if (effectiveExplosionResistance != blastResistance) {
+                    return Optional.of(effectiveExplosionResistance);
+                }
+            }
+            return optionalBlastResistance;
+        }
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/GameRules.java b/src/main/java/net/minecraft/world/level/GameRules.java
index 6fa00d9239546aa82b9e92e25a33103868084c38..5d50d9d2700a8943105301ef0ac467e49ce86a02 100644
--- a/src/main/java/net/minecraft/world/level/GameRules.java
+++ b/src/main/java/net/minecraft/world/level/GameRules.java
@@ -127,7 +127,7 @@ public class GameRules {
     }
 
     private GameRules(Map<GameRules.Key<?>, GameRules.Value<?>> rules) {
-        this.rules = rules;
+        this.rules = top.leavesmc.leaves.LeavesConfig.useOptimizedCollection ? new it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap<>(rules) : rules; // Leaves - replace game rules map with optimized collection
 
         // Paper start
         int arraySize = rules.keySet().stream().mapToInt(key -> key.gameRuleIndex).max().orElse(-1) + 1;
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index f39ab10c5b0b8d86b579a5b683491204c51db70b..772300d2cb8174ea79cacfda90e64bc0581b603a 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -74,6 +74,7 @@ import net.minecraft.world.level.lighting.LevelLightEngine;
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.level.redstone.CollectingNeighborUpdater;
+import net.minecraft.world.level.redstone.InstantNeighborUpdater;
 import net.minecraft.world.level.redstone.NeighborUpdater;
 import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
 import net.minecraft.world.level.storage.LevelData;
@@ -103,6 +104,7 @@ import org.bukkit.entity.SpawnCategory;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.world.GenericGameEvent;
 // CraftBukkit end
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
 
@@ -176,6 +178,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     // Paper end
 
     public final com.destroystokyo.paper.antixray.ChunkPacketBlockController chunkPacketBlockController; // Paper - Anti-Xray
+	public final top.leavesmc.leaves.LeavesConfig.WorldConfig leavesConfig; // Leaves - World Config
     public final co.aikar.timings.WorldTimingsHandler timings; // Paper
     public static BlockPos lastPhysicsProblem; // Spigot
     private org.spigotmc.TickLimiter entityLimiter;
@@ -273,9 +276,12 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
 
     public abstract ResourceKey<LevelStem> getTypeKey();
 
+    protected final io.papermc.paper.util.math.ThreadUnsafeRandom randomTickRandom = new io.papermc.paper.util.math.ThreadUnsafeRandom(java.util.concurrent.ThreadLocalRandom.current().nextLong()); // Leaves - move thread unsafe random initialization
+
     protected Level(WritableLevelData worlddatamutable, ResourceKey<Level> resourcekey, RegistryAccess iregistrycustom, Holder<DimensionType> holder, Supplier<ProfilerFiller> supplier, boolean flag, boolean flag1, long i, int j, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider, org.bukkit.World.Environment env, java.util.function.Function<org.spigotmc.SpigotWorldConfig, io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator, java.util.concurrent.Executor executor) { // Paper - Async-Anti-Xray - Pass executor
         this.spigotConfig = new org.spigotmc.SpigotWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) worlddatamutable).getLevelName()); // Spigot
         this.paperConfig = paperWorldConfigCreator.apply(this.spigotConfig); // Paper
+		this.leavesConfig = new top.leavesmc.leaves.LeavesConfig.WorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData)worlddatamutable).getLevelName()); // Leaves - World Config
         this.generator = gen;
         this.world = new CraftWorld((ServerLevel) this, gen, biomeProvider, env);
 
@@ -316,7 +322,13 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         this.thread = Thread.currentThread();
         this.biomeManager = new BiomeManager(this, i);
         this.isDebug = flag1;
-        this.neighborUpdater = new CollectingNeighborUpdater(this, j);
+        // Leaves start - instantBlockUpdaterReintroduced
+        if (top.leavesmc.leaves.LeavesConfig.instantBlockUpdaterReintroduced) {
+            this.neighborUpdater = new InstantNeighborUpdater(this);
+        } else {
+            this.neighborUpdater = new CollectingNeighborUpdater(this, j);
+        }
+        // Leaves end - instantBlockUpdaterReintroduced
         this.registryAccess = iregistrycustom;
         this.damageSources = new DamageSources(iregistrycustom);
         // CraftBukkit start
@@ -362,6 +374,12 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         this.chunkPacketBlockController = this.paperConfig().anticheat.antiXray.enabled ? new com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray(this, executor) : com.destroystokyo.paper.antixray.ChunkPacketBlockController.NO_OPERATION_INSTANCE; // Paper - Anti-Xray
     }
 
+    // Leaves start - thread unsafe random get
+    public net.minecraft.util.RandomSource getThreadUnsafeRandom() {
+        return randomTickRandom;
+    }
+    // Leaves end - thread unsafe random get
+
     // Paper start
     // ret true if no collision
     public final boolean checkEntityCollision(BlockState data, Entity source, net.minecraft.world.phys.shapes.CollisionContext voxelshapedcollision,
@@ -412,6 +430,91 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         return null;
     }
 
+    // Leaves start - broken down method of raytracing for EntityLiving#hasLineOfSight, replaces IBlockAccess#rayTrace(RayTrace)
+    public net.minecraft.world.phys.BlockHitResult.Type rayTraceDirect(net.minecraft.world.phys.Vec3 vec3d, net.minecraft.world.phys.Vec3 vec3d1, net.minecraft.world.phys.shapes.CollisionContext voxelshapecoll) {
+        // most of this code comes from IBlockAccess#a(RayTrace, BiFunction, Function), but removes the needless functions
+        if (vec3d.equals(vec3d1)) {
+            return net.minecraft.world.phys.BlockHitResult.Type.MISS;
+        }
+
+        double endX = Mth.lerp(-1.0E-7D, vec3d1.x, vec3d.x);
+        double endY = Mth.lerp(-1.0E-7D, vec3d1.y, vec3d.y);
+        double endZ = Mth.lerp(-1.0E-7D, vec3d1.z, vec3d.z);
+
+        double startX = Mth.lerp(-1.0E-7D, vec3d.x, vec3d1.x);
+        double startY = Mth.lerp(-1.0E-7D, vec3d.y, vec3d1.y);
+        double startZ = Mth.lerp(-1.0E-7D, vec3d.z, vec3d1.z);
+
+        int currentX = Mth.floor(startX);
+        int currentY = Mth.floor(startY);
+        int currentZ = Mth.floor(startZ);
+
+        BlockPos.MutableBlockPos currentBlock = new BlockPos.MutableBlockPos(currentX, currentY, currentZ);
+
+        LevelChunk chunk = this.getChunkIfLoaded(currentBlock);
+        if (chunk == null) {
+            return net.minecraft.world.phys.BlockHitResult.Type.MISS;
+        }
+
+        net.minecraft.world.phys.BlockHitResult.Type initialCheck = this.rayTraceBlockDirect(vec3d, vec3d1, currentBlock, chunk.getBlockState(currentBlock), voxelshapecoll);
+
+        if (initialCheck != null) {
+            return initialCheck;
+        }
+
+        double diffX = endX - startX;
+        double diffY = endY - startY;
+        double diffZ = endZ - startZ;
+
+        int xDirection = Mth.sign(diffX);
+        int yDirection = Mth.sign(diffY);
+        int zDirection = Mth.sign(diffZ);
+
+        double normalizedX = xDirection == 0 ? Double.MAX_VALUE : (double) xDirection / diffX;
+        double normalizedY = yDirection == 0 ? Double.MAX_VALUE : (double) yDirection / diffY;
+        double normalizedZ = zDirection == 0 ? Double.MAX_VALUE : (double) zDirection / diffZ;
+
+        double normalizedXDirection = normalizedX * (xDirection > 0 ? 1.0D - Mth.frac(startX) : Mth.frac(startX));
+        double normalizedYDirection = normalizedY * (yDirection > 0 ? 1.0D - Mth.frac(startY) : Mth.frac(startY));
+        double normalizedZDirection = normalizedZ * (zDirection > 0 ? 1.0D - Mth.frac(startZ) : Mth.frac(startZ));
+
+        net.minecraft.world.phys.BlockHitResult.Type result;
+
+        do {
+            if (normalizedXDirection > 1.0D && normalizedYDirection > 1.0D && normalizedZDirection > 1.0D) {
+                return net.minecraft.world.phys.BlockHitResult.Type.MISS;
+            }
+
+            if (normalizedXDirection < normalizedYDirection) {
+                if (normalizedXDirection < normalizedZDirection) {
+                    currentX += xDirection;
+                    normalizedXDirection += normalizedX;
+                } else {
+                    currentZ += zDirection;
+                    normalizedZDirection += normalizedZ;
+                }
+            } else if (normalizedYDirection < normalizedZDirection) {
+                currentY += yDirection;
+                normalizedYDirection += normalizedY;
+            } else {
+                currentZ += zDirection;
+                normalizedZDirection += normalizedZ;
+            }
+
+            currentBlock.set(currentX, currentY, currentZ);
+            if (chunk.getPos().x != currentBlock.getX() >> 4 || chunk.getPos().z != currentBlock.getZ() >> 4) {
+                chunk = this.getChunkIfLoaded(currentBlock);
+                if (chunk == null) {
+                    return net.minecraft.world.phys.BlockHitResult.Type.MISS;
+                }
+            }
+            result = this.rayTraceBlockDirect(vec3d, vec3d1, currentBlock, chunk.getBlockState(currentBlock), voxelshapecoll);
+        } while (result == null);
+
+        return result;
+    }
+    // Leaves end - broken down method of raytracing for EntityLiving#hasLineOfSight, replaces IBlockAccess#rayTrace(RayTrace)
+
     public boolean isInWorldBounds(BlockPos pos) {
         return pos.isInsideBuildHeightAndWorldBoundsHorizontal(this); // Paper - use better/optimized check
     }
@@ -1380,6 +1483,11 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     }
 
     public ProfilerFiller getProfiler() {
+        // Leaves start - disable method profiler
+        if (top.leavesmc.leaves.LeavesConfig.disableMethodProfiler) {
+            return net.minecraft.util.profiling.InactiveProfiler.INSTANCE;
+        }
+        // Leaves end - disable method profiler
         return (ProfilerFiller) this.profiler.get();
     }
 
@@ -1424,7 +1532,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public org.bukkit.entity.Entity[] getChunkEntities(int chunkX, int chunkZ) {
         io.papermc.paper.world.ChunkEntitySlices slices = ((ServerLevel)this).getEntityLookup().getChunk(chunkX, chunkZ);
         if (slices == null) {
-            return new org.bukkit.entity.Entity[0];
+            return ArrayConstants.emptyBukkitEntityArray; // Leaves - reduce array allocations
         }
         return slices.getChunkEntities();
     }
diff --git a/src/main/java/net/minecraft/world/level/LocalMobCapCalculator.java b/src/main/java/net/minecraft/world/level/LocalMobCapCalculator.java
index 84c766e09898cfc07d6e07e80f4b9aa318050a62..a42098cc027ed3c1ec75542b800520514f87608a 100644
--- a/src/main/java/net/minecraft/world/level/LocalMobCapCalculator.java
+++ b/src/main/java/net/minecraft/world/level/LocalMobCapCalculator.java
@@ -48,15 +48,28 @@ public class LocalMobCapCalculator {
 
     static class MobCounts {
         private final Object2IntMap<MobCategory> counts = new Object2IntOpenHashMap<>(MobCategory.values().length);
+        public final int[] arrCounts = new int[MobCategory.values().length]; // Leaves - store mob counts in an array
 
         public void add(MobCategory spawnGroup) {
-            this.counts.computeInt(spawnGroup, (group, density) -> {
-                return density == null ? 1 : density + 1;
-            });
+            // Leaves start - store mob counts in an array
+            if (!top.leavesmc.leaves.LeavesConfig.storeMobCountsInArray) {
+                this.counts.computeInt(spawnGroup, (group, density) -> {
+                    return density == null ? 1 : density + 1;
+                });
+            } else {
+                this.arrCounts[spawnGroup.ordinal()]++;
+            }
+            // Leaves end - store mob counts in an array
         }
 
         public boolean canSpawn(MobCategory spawnGroup) {
-            return this.counts.getOrDefault(spawnGroup, 0) < spawnGroup.getMaxInstancesPerChunk();
+            // Leaves start - store mob counts in an array
+            if (!top.leavesmc.leaves.LeavesConfig.storeMobCountsInArray) {
+                return this.counts.getOrDefault(spawnGroup, 0) < spawnGroup.getMaxInstancesPerChunk();
+            } else {
+                return this.arrCounts[spawnGroup.ordinal()] < spawnGroup.getMaxInstancesPerChunk();
+            }
+            // Leaves end - store mob counts in an array
         }
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/NaturalSpawner.java b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
index 089dd93d4cd4c1f72e63c4944b3b82c1e2ba732d..9a5b31a3a8614ca2ff2d5bdb64dddccd70b22c3f 100644
--- a/src/main/java/net/minecraft/world/level/NaturalSpawner.java
+++ b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
@@ -40,6 +40,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.level.levelgen.structure.BuiltinStructures;
 import net.minecraft.world.level.levelgen.structure.Structure;
@@ -95,7 +96,7 @@ public final class NaturalSpawner {
 
             if (enumcreaturetype != MobCategory.MISC) {
                 // Paper start - Only count natural spawns
-                if (!entity.level().paperConfig().entities.spawning.countAllMobsForSpawning &&
+                if (!top.leavesmc.leaves.LeavesConfig.mcTechnicalMode && !entity.level().paperConfig().entities.spawning.countAllMobsForSpawning && // Leaves - mc technical survival mode
                     !(entity.spawnReason == org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.NATURAL ||
                         entity.spawnReason == org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.CHUNK_GEN)) {
                     continue;
@@ -208,6 +209,19 @@ public final class NaturalSpawner {
     }
     public static int spawnCategoryForChunk(MobCategory group, ServerLevel world, LevelChunk chunk, NaturalSpawner.SpawnPredicate checker, NaturalSpawner.AfterSpawnCallback runner, int maxSpawns, Consumer<Entity> trackEntity) {
         // Paper end - add parameters and int ret type
+        // Leaves start - ignore lc
+        if (top.leavesmc.leaves.LeavesConfig.ignoreLC) {
+            int spawnN = 0;
+            for (int i = chunk.getMinBuildHeight(); i < chunk.getMaxBuildHeight(); i += 16) {
+                LevelChunkSection section = chunk.getSections()[chunk.getSectionIndex(i)];
+                if (section != null && !section.hasOnlyAir()) {
+                    BlockPos pos = getRandomPosInChunk(world, chunk).offset(0, i, 0);
+                    spawnN += spawnCategoryForPosition(group, world, chunk, pos, checker, runner, maxSpawns, trackEntity);
+                }
+            }
+            return spawnN;
+        }
+        // Leaves stop - ignore lc
         BlockPos blockposition = NaturalSpawner.getRandomPosWithin(world, chunk);
 
         if (blockposition.getY() >= world.getMinBuildHeight() + 1) {
@@ -216,6 +230,16 @@ public final class NaturalSpawner {
         return 0; // Paper
     }
 
+    // Leaves start - ignore lc
+    private static BlockPos getRandomPosInChunk(Level world, LevelChunk chunk) {
+        ChunkPos chunkPos = chunk.getPos();
+        int x = chunkPos.getMinBlockX() + world.random.nextInt(16);
+        int z = chunkPos.getMinBlockZ() + world.random.nextInt(16);
+        int y = world.random.nextInt(16) + 1;
+        return new BlockPos(x, y, z);
+    }
+    // Leaves stop - ignore lc
+
     @VisibleForDebug
     public static void spawnCategoryForPosition(MobCategory group, ServerLevel world, BlockPos pos) {
         NaturalSpawner.spawnCategoryForPosition(group, world, world.getChunk(pos), pos, (entitytypes, blockposition1, ichunkaccess) -> {
@@ -419,12 +443,21 @@ public final class NaturalSpawner {
 
     private static BlockPos getRandomPosWithin(Level world, LevelChunk chunk) {
         ChunkPos chunkcoordintpair = chunk.getPos();
-        int i = chunkcoordintpair.getMinBlockX() + world.random.nextInt(16);
-        int j = chunkcoordintpair.getMinBlockZ() + world.random.nextInt(16);
-        int k = chunk.getHeight(Heightmap.Types.WORLD_SURFACE, i, j) + 1;
-        int l = Mth.randomBetweenInclusive(world.random, world.getMinBuildHeight(), k);
-
-        return new BlockPos(i, l, j);
+        // Leaves start - use thread unsafe random
+        if (top.leavesmc.leaves.LeavesConfig.useMoreThreadUnsafeRandom) {
+            int i = chunkcoordintpair.getMinBlockX() + world.getThreadUnsafeRandom().nextInt(16);
+            int j = chunkcoordintpair.getMinBlockZ() + world.getThreadUnsafeRandom().nextInt(16);
+            int k = chunk.getHeight(Heightmap.Types.WORLD_SURFACE, i, j) + 1;
+            int l = Mth.randomBetweenInclusive(world.getThreadUnsafeRandom(), world.getMinBuildHeight(), k);
+            return new BlockPos(i, l, j);
+        } else {
+            int i = chunkcoordintpair.getMinBlockX() + world.random.nextInt(16);
+            int j = chunkcoordintpair.getMinBlockZ() + world.random.nextInt(16);
+            int k = chunk.getHeight(Heightmap.Types.WORLD_SURFACE, i, j) + 1;
+            int l = Mth.randomBetweenInclusive(world.random, world.getMinBuildHeight(), k);
+            return new BlockPos(i, l, j);
+        }
+        // Leaves end - use thread unsafe random
     }
 
     public static boolean isValidEmptySpawnBlock(BlockGetter blockView, BlockPos pos, BlockState state, FluidState fluidState, EntityType<?> entityType) {
diff --git a/src/main/java/net/minecraft/world/level/biome/Biome.java b/src/main/java/net/minecraft/world/level/biome/Biome.java
index 65012a12e1430956ef55ced56773e6354ac26444..fe43432da26a3570c993b5592b7b8020331bdb74 100644
--- a/src/main/java/net/minecraft/world/level/biome/Biome.java
+++ b/src/main/java/net/minecraft/world/level/biome/Biome.java
@@ -66,23 +66,37 @@ public final class Biome {
     private final BiomeGenerationSettings generationSettings;
     private final MobSpawnSettings mobSettings;
     private final BiomeSpecialEffects specialEffects;
-    private final ThreadLocal<Long2FloatLinkedOpenHashMap> temperatureCache = ThreadLocal.withInitial(() -> {
-        return Util.make(() -> {
-            Long2FloatLinkedOpenHashMap long2FloatLinkedOpenHashMap = new Long2FloatLinkedOpenHashMap(1024, 0.25F) {
-                protected void rehash(int i) {
-                }
-            };
-            long2FloatLinkedOpenHashMap.defaultReturnValue(Float.NaN);
-            return long2FloatLinkedOpenHashMap;
-        });
-    });
+    // Leaves start - use our cache
+    private final ThreadLocal<Long2FloatLinkedOpenHashMap> temperatureCache;
+    private final ThreadLocal<top.leavesmc.leaves.structs.Long2FloatAgingCache> temperatureAgingCache;
 
     Biome(Biome.ClimateSettings weather, BiomeSpecialEffects effects, BiomeGenerationSettings generationSettings, MobSpawnSettings spawnSettings) {
         this.climateSettings = weather;
         this.generationSettings = generationSettings;
         this.mobSettings = spawnSettings;
         this.specialEffects = effects;
+        if (top.leavesmc.leaves.LeavesConfig.biomeTemperaturesUseAgingCache) {
+            temperatureCache = null;
+            temperatureAgingCache = ThreadLocal.withInitial(() -> {
+                return Util.make(() -> {
+                    return new top.leavesmc.leaves.structs.Long2FloatAgingCache(TEMPERATURE_CACHE_SIZE);
+                });
+            });
+        } else {
+            temperatureCache = ThreadLocal.withInitial(() -> {
+                return Util.make(() -> {
+                    Long2FloatLinkedOpenHashMap long2FloatLinkedOpenHashMap = new Long2FloatLinkedOpenHashMap(1024, 0.25F) {
+                        protected void rehash(int i) {
+                        }
+                    };
+                    long2FloatLinkedOpenHashMap.defaultReturnValue(Float.NaN);
+                    return long2FloatLinkedOpenHashMap;
+                });
+            });
+            temperatureAgingCache = null;
+        }
     }
+    // Leaves end - use our cache
 
     public int getSkyColor() {
         return this.specialEffects.getSkyColor();
@@ -118,19 +132,33 @@ public final class Biome {
     @Deprecated
     public float getTemperature(BlockPos blockPos) {
         long l = blockPos.asLong();
-        Long2FloatLinkedOpenHashMap long2FloatLinkedOpenHashMap = this.temperatureCache.get();
-        float f = long2FloatLinkedOpenHashMap.get(l);
-        if (!Float.isNaN(f)) {
-            return f;
-        } else {
-            float g = this.getHeightAdjustedTemperature(blockPos);
-            if (long2FloatLinkedOpenHashMap.size() == 1024) {
-                long2FloatLinkedOpenHashMap.removeFirstFloat();
+        // Leaves start - use our cache
+        if (top.leavesmc.leaves.LeavesConfig.biomeTemperaturesUseAgingCache) {
+            top.leavesmc.leaves.structs.Long2FloatAgingCache cache = this.temperatureAgingCache.get();
+            float f = cache.getValue(l);
+            if (!Float.isNaN(f)) {
+                return f;
+            } else {
+                float g = this.getHeightAdjustedTemperature(blockPos);
+                cache.putValue(l, g);
+                return g;
             }
+        } else {
+            Long2FloatLinkedOpenHashMap long2FloatLinkedOpenHashMap = this.temperatureCache.get();
+            float f = long2FloatLinkedOpenHashMap.get(l);
+            if (!Float.isNaN(f)) {
+                return f;
+            } else {
+                float g = this.getHeightAdjustedTemperature(blockPos);
+                if (long2FloatLinkedOpenHashMap.size() == 1024) {
+                    long2FloatLinkedOpenHashMap.removeFirstFloat();
+                }
 
-            long2FloatLinkedOpenHashMap.put(l, g);
-            return g;
+                long2FloatLinkedOpenHashMap.put(l, g);
+                return g;
+            }
         }
+        // Leaves end - use our cache
     }
 
     public boolean shouldFreeze(LevelReader world, BlockPos blockPos) {
diff --git a/src/main/java/net/minecraft/world/level/block/AbstractCauldronBlock.java b/src/main/java/net/minecraft/world/level/block/AbstractCauldronBlock.java
index 47468086c1cae252aa99c55b0065f225357dee62..bca757ea05403fe46f5bf0dfa75561b8b124622d 100644
--- a/src/main/java/net/minecraft/world/level/block/AbstractCauldronBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/AbstractCauldronBlock.java
@@ -9,6 +9,7 @@ import net.minecraft.world.InteractionHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.BlockItem;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.BlockGetter;
@@ -51,9 +52,27 @@ public abstract class AbstractCauldronBlock extends Block {
     public InteractionResult use(BlockState state, Level world, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hit) {
         ItemStack itemStack = player.getItemInHand(hand);
         CauldronInteraction cauldronInteraction = this.interactions.get(itemStack.getItem());
-        return cauldronInteraction.interact(state, world, pos, player, hand, itemStack);
+        return wrapInteractor(cauldronInteraction, state, world, pos, player, hand, itemStack); // Leaves - stackable shulker boxes
     }
 
+    // Leaves start - stackable shulker boxes
+    private InteractionResult wrapInteractor(CauldronInteraction cauldronBehavior, BlockState blockState, Level world, BlockPos blockPos, Player playerEntity, InteractionHand hand, ItemStack itemStack) {
+        int count = -1;
+        if (top.leavesmc.leaves.LeavesConfig.shulkerBoxStackSize > 1 && itemStack.getItem() instanceof BlockItem bi &&
+            bi.getBlock() instanceof ShulkerBoxBlock) {
+            count = itemStack.getCount();
+        }
+        InteractionResult result = cauldronBehavior.interact(blockState, world, blockPos, playerEntity, hand, itemStack);
+        if (count > 0 && result.consumesAction()) {
+            ItemStack current = playerEntity.getItemInHand(hand);
+            if (current.getItem() instanceof BlockItem bi && bi.getBlock() instanceof ShulkerBoxBlock) {
+                current.setCount(count);
+            }
+        }
+        return result;
+    }
+    // Leaves end - stackable shulker boxes
+
     @Override
     public VoxelShape getShape(BlockState state, BlockGetter world, BlockPos pos, CollisionContext context) {
         return SHAPE;
diff --git a/src/main/java/net/minecraft/world/level/block/BambooStalkBlock.java b/src/main/java/net/minecraft/world/level/block/BambooStalkBlock.java
index a5d391af2c6b733d653188f4aeeec2afffd96adf..be27ca377ab9317391b0e7af494f17d71333c10c 100644
--- a/src/main/java/net/minecraft/world/level/block/BambooStalkBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/BambooStalkBlock.java
@@ -115,8 +115,11 @@ public class BambooStalkBlock extends Block implements BonemealableBlock {
     public void tick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
         if (!state.canSurvive(world, pos)) {
             world.destroyBlock(pos, true);
+            // Leaves start - zero tick plants
+        } else if (top.leavesmc.leaves.LeavesConfig.zeroTickPlants) {
+            this.randomTick(state, world, pos, random);
+            // Leaves end - zero tick plants
         }
-
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index 9522e646529f3d849471931b4b3c0d133e7fcfc5..b87ce8e774e1030de8986067a308505c735a494d 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -61,6 +61,7 @@ import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 import org.slf4j.Logger;
+import top.leavesmc.leaves.lithium.common.util.collections.Object2BooleanCacheTable;
 
 public class Block extends BlockBehaviour implements ItemLike {
 
@@ -72,6 +73,12 @@ public class Block extends BlockBehaviour implements ItemLike {
             return !Shapes.joinIsNotEmpty(Shapes.block(), voxelshape, BooleanOp.NOT_SAME);
         }
     });
+    // Leaves start - replace shape full block cache with hashtable
+    private static final Object2BooleanCacheTable<VoxelShape> LITHIUM_SHAPE_FULL_BLOCK_CACHE = new Object2BooleanCacheTable<>(
+        1536,
+        shape -> !Shapes.joinIsNotEmpty(Shapes.block(), shape, BooleanOp.NOT_SAME)
+    );
+    // Leaves end - replace shape full block cache with hashtable
     public static final int UPDATE_NEIGHBORS = 1;
     public static final int UPDATE_CLIENTS = 2;
     public static final int UPDATE_INVISIBLE = 4;
@@ -277,7 +284,13 @@ public class Block extends BlockBehaviour implements ItemLike {
     }
 
     public static boolean isShapeFullBlock(VoxelShape shape) {
-        return (Boolean) Block.SHAPE_FULL_BLOCK_CACHE.getUnchecked(shape);
+        // Leaves start - replace shape full block cache with hashtable
+        if (!top.leavesmc.leaves.LeavesConfig.useOptimizedCollection) {
+            return (Boolean) Block.SHAPE_FULL_BLOCK_CACHE.getUnchecked(shape);
+        } else {
+            return Block.LITHIUM_SHAPE_FULL_BLOCK_CACHE.get(shape);
+        }
+        // Leaves end - replace shape full block cache with hashtable
     }
 
     public boolean propagatesSkylightDown(BlockState state, BlockGetter world, BlockPos pos) {
@@ -411,6 +424,19 @@ public class Block extends BlockBehaviour implements ItemLike {
 
     public void stepOn(Level world, BlockPos pos, BlockState state, Entity entity) {}
 
+    // Leaves start - carpetAlternativeBlockPlacement
+    @Nullable
+    public BlockState getRealStateForPlacement(BlockPlaceContext ctx) {
+        if (top.leavesmc.leaves.LeavesConfig.carpetAlternativeBlockPlacement) {
+            BlockState tryState = top.leavesmc.leaves.protocol.CarpetAlternativeBlockPlacement.alternativeBlockPlacement(this, ctx);
+            if (tryState != null) {
+                return tryState;
+            }
+        }
+        return getStateForPlacement(ctx);
+    }
+    // Leaves end - carpetAlternativeBlockPlacement
+
     @Nullable
     public BlockState getStateForPlacement(BlockPlaceContext ctx) {
         return this.defaultBlockState();
@@ -585,16 +611,29 @@ public class Block extends BlockBehaviour implements ItemLike {
     }
     // Spigot end
 
+    // Leaves start - reset push reaction
+    public net.minecraft.world.level.material.PushReaction getResetPushReaction() {
+        return null;
+    }
+    // Leaves end - reset push reaction
+
     public static final class BlockStatePairKey {
 
         private final BlockState first;
         private final BlockState second;
         private final Direction direction;
+        private final int hash; // Leaves - cache BlockStatePairKey hash
 
         public BlockStatePairKey(BlockState self, BlockState other, Direction facing) {
             this.first = self;
             this.second = other;
             this.direction = facing;
+            // Leaves start - cache BlockStatePairKey hash
+            int hash = this.first.hashCode();
+            hash = 31 * hash + this.second.hashCode();
+            hash = 31 * hash + this.direction.hashCode();
+            this.hash = hash;
+            // Leaves end - cache BlockStatePairKey hash
         }
 
         public boolean equals(Object object) {
@@ -610,11 +649,17 @@ public class Block extends BlockBehaviour implements ItemLike {
         }
 
         public int hashCode() {
-            int i = this.first.hashCode();
+            // Leaves start - cache BlockStatePairKey hash
+            if (!top.leavesmc.leaves.LeavesConfig.cacheBlockStatePairKeyHash) {
+                int i = this.first.hashCode();
 
-            i = 31 * i + this.second.hashCode();
-            i = 31 * i + this.direction.hashCode();
-            return i;
+                i = 31 * i + this.second.hashCode();
+                i = 31 * i + this.direction.hashCode();
+                return i;
+            } else {
+                return this.hash;
+            }
+            // Leaves end - cache BlockStatePairKey hash
         }
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/block/BuddingAmethystBlock.java b/src/main/java/net/minecraft/world/level/block/BuddingAmethystBlock.java
index 2548244c089dff583c8c424dcaa5504caedf3f10..e53624d9f2372fceab44bd1c881a6f3cf5862b8c 100644
--- a/src/main/java/net/minecraft/world/level/block/BuddingAmethystBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/BuddingAmethystBlock.java
@@ -53,4 +53,11 @@ public class BuddingAmethystBlock extends AmethystBlock {
     public static boolean canClusterGrowAtState(BlockState state) {
         return state.isAir() || state.is(Blocks.WATER) && state.getFluidState().getAmount() == 8;
     }
+
+    // Leaves start - budding amethyst can push by piston
+    @Override
+    public net.minecraft.world.level.material.PushReaction getResetPushReaction() {
+        return top.leavesmc.leaves.LeavesConfig.buddingAmethystCanPushByPiston ? net.minecraft.world.level.material.PushReaction.PUSH_ONLY : null;
+    }
+    // Leaves end - budding amethyst can push by piston
 }
diff --git a/src/main/java/net/minecraft/world/level/block/CactusBlock.java b/src/main/java/net/minecraft/world/level/block/CactusBlock.java
index 0003fb51ae3a6575575e10b4c86719f3061e2577..12e251428260c6e05e9a48c71493aaf2bd2b486b 100644
--- a/src/main/java/net/minecraft/world/level/block/CactusBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/CactusBlock.java
@@ -39,8 +39,11 @@ public class CactusBlock extends Block {
     public void tick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
         if (!state.canSurvive(world, pos)) {
             world.destroyBlock(pos, true);
+            // Leaves start - zero tick plants
+        } else if (top.leavesmc.leaves.LeavesConfig.zeroTickPlants) {
+            this.randomTick(state, world, pos, random);
+            // Leaves end - zero tick plants
         }
-
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/ChorusFlowerBlock.java b/src/main/java/net/minecraft/world/level/block/ChorusFlowerBlock.java
index f19a1ea64d26723d738b007c5102fe44b963bfb6..199a41f7c16dca7b70951c52e9535cfcd5fdf224 100644
--- a/src/main/java/net/minecraft/world/level/block/ChorusFlowerBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/ChorusFlowerBlock.java
@@ -35,8 +35,11 @@ public class ChorusFlowerBlock extends Block {
     public void tick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
         if (!state.canSurvive(world, pos)) {
             world.destroyBlock(pos, true);
+            // Leaves start - zero tick plants
+        } else if (top.leavesmc.leaves.LeavesConfig.zeroTickPlants) {
+            this.randomTick(state, world, pos, random);
+            // Leaves end - zero tick plants
         }
-
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/ComposterBlock.java b/src/main/java/net/minecraft/world/level/block/ComposterBlock.java
index 10d3912ef043eefdf89105332e29b0d2bf4a5539..3bc33b552743be03c6b895e0d217152a65454807 100644
--- a/src/main/java/net/minecraft/world/level/block/ComposterBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/ComposterBlock.java
@@ -43,6 +43,7 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 import org.bukkit.craftbukkit.inventory.CraftBlockInventoryHolder;
 import org.bukkit.craftbukkit.util.DummyGeneratorAccess;
 // CraftBukkit end
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public class ComposterBlock extends Block implements WorldlyContainerHolder {
 
@@ -415,7 +416,7 @@ public class ComposterBlock extends Block implements WorldlyContainerHolder {
 
         @Override
         public int[] getSlotsForFace(Direction side) {
-            return side == Direction.DOWN ? new int[]{0} : new int[0];
+            return side == Direction.DOWN ? ArrayConstants.zeroSingletonIntArray : ArrayConstants.emptyIntArray; // Leaves - reduce array allocations
         }
 
         @Override
@@ -464,7 +465,7 @@ public class ComposterBlock extends Block implements WorldlyContainerHolder {
 
         @Override
         public int[] getSlotsForFace(Direction side) {
-            return side == Direction.UP ? new int[]{0} : new int[0];
+            return side == Direction.UP ? ArrayConstants.zeroSingletonIntArray : ArrayConstants.emptyIntArray; // Leaves - reduce array allocations
         }
 
         @Override
@@ -506,7 +507,7 @@ public class ComposterBlock extends Block implements WorldlyContainerHolder {
 
         @Override
         public int[] getSlotsForFace(Direction side) {
-            return new int[0];
+            return ArrayConstants.emptyIntArray; // Leaves - reduce array allocations
         }
 
         @Override
diff --git a/src/main/java/net/minecraft/world/level/block/EndPortalBlock.java b/src/main/java/net/minecraft/world/level/block/EndPortalBlock.java
index 41d7cff39fc37955877668337689b4b26cd8c7cf..5e0e8afa553a8dcd87dfc10a595ba10c2b3da7df 100644
--- a/src/main/java/net/minecraft/world/level/block/EndPortalBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/EndPortalBlock.java
@@ -53,12 +53,19 @@ public class EndPortalBlock extends BaseEntityBlock {
                 // return; // CraftBukkit - always fire event in case plugins wish to change it
             }
 
-            // Paper start - move all of this logic into portal tick
-            entity.portalWorld = ((ServerLevel)world);
-            entity.portalBlock = pos.immutable();
-            // Paper end - move all of this logic into portal tick
-        }
+            // Leaves start - fix gravity block duper
+            // CraftBukkit start - Entity in portal
+            EntityPortalEnterEvent event = new EntityPortalEnterEvent(entity.getBukkitEntity(), new org.bukkit.Location(world.getWorld(), pos.getX(), pos.getY(), pos.getZ()));
+            world.getCraftServer().getPluginManager().callEvent(event);
 
+            if (entity instanceof ServerPlayer) {
+                ((ServerPlayer) entity).changeDimension(worldserver, PlayerTeleportEvent.TeleportCause.END_PORTAL);
+                return;
+            }
+            // CraftBukkit end
+            entity.changeDimension(worldserver);
+            // Leaves end - fix gravity block duper
+        }
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/FarmBlock.java b/src/main/java/net/minecraft/world/level/block/FarmBlock.java
index 5946f06f63b5694034bd027984a4925b0831d439..c66428ed5e0557b0e2bcc2cfd9bfbe992d85bf72 100644
--- a/src/main/java/net/minecraft/world/level/block/FarmBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/FarmBlock.java
@@ -102,6 +102,13 @@ public class FarmBlock extends Block {
     public void fallOn(Level world, BlockState state, BlockPos pos, Entity entity, float fallDistance) {
         super.fallOn(world, state, pos, entity, fallDistance); // CraftBukkit - moved here as game rules / events shouldn't affect fall damage.
         if (!world.isClientSide && world.random.nextFloat() < fallDistance - 0.5F && entity instanceof LivingEntity && (entity instanceof Player || world.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)) && entity.getBbWidth() * entity.getBbWidth() * entity.getBbHeight() > 0.512F) {
+            // Leaves start - noFeatherFallingTrample
+            if (top.leavesmc.leaves.LeavesConfig.noFeatherFallingTrample) {
+                if (net.minecraft.world.item.enchantment.EnchantmentHelper.getEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.FALL_PROTECTION, (LivingEntity) entity) > 0) {
+                    return;
+                }
+            }
+            // Leaves end - noFeatherFallingTrample
             // CraftBukkit start - Interact soil
             org.bukkit.event.Cancellable cancellable;
             if (entity instanceof Player) {
diff --git a/src/main/java/net/minecraft/world/level/block/FireBlock.java b/src/main/java/net/minecraft/world/level/block/FireBlock.java
index 4002e0fffb60556e7af1aeff71b4be244f02b0f5..8fc696d806aa3f4af313f145397ec497e186def2 100644
--- a/src/main/java/net/minecraft/world/level/block/FireBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/FireBlock.java
@@ -214,6 +214,7 @@ public class FireBlock extends BaseFireBlock {
                 this.trySpread(world, pos.south(), 300 + k, random, i, pos);
                 // CraftBukkit end
                 BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
+                Object2IntOpenHashMap<BlockPos> blockPositionIgniteCache = new Object2IntOpenHashMap<>(); // Leaves - cache ignite odds
 
                 for (int l = -1; l <= 1; ++l) {
                     for (int i1 = -1; i1 <= 1; ++i1) {
@@ -226,7 +227,7 @@ public class FireBlock extends BaseFireBlock {
                                 }
 
                                 blockposition_mutableblockposition.setWithOffset(pos, l, j1, i1);
-                                int l1 = this.getIgniteOdds(world, blockposition_mutableblockposition);
+                                int l1 = this.getIgniteOdds(world, blockposition_mutableblockposition, top.leavesmc.leaves.LeavesConfig.cacheIgniteOdds ? blockPositionIgniteCache : null); // Leaves - cache ignite odds
 
                                 if (l1 > 0) {
                                     int i2 = (l1 + 40 + world.getDifficulty().getId() * 7) / (i + 30);
@@ -338,6 +339,11 @@ public class FireBlock extends BaseFireBlock {
     }
 
     private int getIgniteOdds(LevelReader world, BlockPos pos) {
+        // Leaves start - cache ignite odds
+        return getIgniteOdds(world, pos, null);
+    }
+
+    private int getIgniteOdds(LevelReader world, BlockPos pos, Object2IntOpenHashMap<BlockPos> cache) {
         if (!world.isEmptyBlock(pos)) {
             return 0;
         } else {
@@ -346,10 +352,20 @@ public class FireBlock extends BaseFireBlock {
             int j = aenumdirection.length;
 
             for (int k = 0; k < j; ++k) {
-                Direction enumdirection = aenumdirection[k];
-                BlockState iblockdata = world.getBlockState(pos.relative(enumdirection));
-
-                i = Math.max(this.getIgniteOdds(iblockdata), i);
+                if (cache != null) {
+                    int finalK = k;
+                    i = Math.max(cache.computeIfAbsent(pos, key -> {
+                        Direction enumdirection = aenumdirection[finalK];
+                        BlockState iblockdata = world.getBlockState(pos.relative(enumdirection));
+                        return this.getIgniteOdds(iblockdata);
+                    }), i);
+                } else {
+                    Direction enumdirection = aenumdirection[k];
+                    BlockState iblockdata = world.getBlockState(pos.relative(enumdirection));
+
+                    i = Math.max(this.getIgniteOdds(iblockdata), i);
+                }
+                // Leaves end - cache ignite odds
             }
 
             return i;
diff --git a/src/main/java/net/minecraft/world/level/block/GrowingPlantHeadBlock.java b/src/main/java/net/minecraft/world/level/block/GrowingPlantHeadBlock.java
index 3a1aa4e2405090ccebefb7f5944f36462929e221..ee7d8790cb9fcbcb2f444b569a14dd352e5c3749 100644
--- a/src/main/java/net/minecraft/world/level/block/GrowingPlantHeadBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/GrowingPlantHeadBlock.java
@@ -138,4 +138,15 @@ public abstract class GrowingPlantHeadBlock extends GrowingPlantBlock implements
     protected GrowingPlantHeadBlock getHeadBlock() {
         return this;
     }
+
+    // Leaves start - zero tick plants
+    @Override
+    public void tick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
+        if (!state.canSurvive(world, pos)) {
+            world.destroyBlock(pos, true);
+        } else if (top.leavesmc.leaves.LeavesConfig.zeroTickPlants) {
+            this.randomTick(state, world, pos, random);
+        }
+    }
+    // Leaves end - zero tick plants
 }
diff --git a/src/main/java/net/minecraft/world/level/block/HopperBlock.java b/src/main/java/net/minecraft/world/level/block/HopperBlock.java
index c8e7e82dd81d9faf8f06612291c40f541304eb82..f4e36bf88b1b6f044a1bb8f1785d57e52b6c8963 100644
--- a/src/main/java/net/minecraft/world/level/block/HopperBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/HopperBlock.java
@@ -123,7 +123,7 @@ public class HopperBlock extends BaseEntityBlock {
     @Override
     public void onPlace(BlockState state, Level world, BlockPos pos, BlockState oldState, boolean notify) {
         if (!oldState.is(state.getBlock())) {
-            this.checkPoweredState(world, pos, state, 2);
+            this.checkPoweredState(world, pos, state, 2, true); // Leaves - special check
         }
     }
 
@@ -147,13 +147,18 @@ public class HopperBlock extends BaseEntityBlock {
         this.checkPoweredState(world, pos, state, 4);
     }
 
+    // Leaves start - special check
     private void checkPoweredState(Level world, BlockPos pos, BlockState state, int flags) {
+        checkPoweredState(world, pos, state, flags, false);
+    }
+
+    private void checkPoweredState(Level world, BlockPos pos, BlockState state, int flags, boolean isPlace) {
         boolean bl = !world.hasNeighborSignal(pos);
         if (bl != state.getValue(ENABLED)) {
-            world.setBlock(pos, state.setValue(ENABLED, Boolean.valueOf(bl)), flags);
+            world.setBlock(pos, state.setValue(ENABLED, Boolean.valueOf(bl)), flags, isPlace ? 0 : 512);
         }
-
     }
+    // Leaves end - special check
 
     @Override
     public void onRemove(BlockState state, Level world, BlockPos pos, BlockState newState, boolean moved) {
diff --git a/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java b/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java
index 70544dac18381ab3fa8ddfa7d276a4ef03f9b191..57fbbc2b6293c3b81aad8a263139e5537a0fc8ac 100644
--- a/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java
@@ -226,7 +226,7 @@ public class RedStoneWireBlock extends Block {
         BlockState iblockdata = world.getBlockState(blockposition1);
 
         if (flag) {
-            boolean flag1 = iblockdata.getBlock() instanceof TrapDoorBlock || this.canSurviveOn(world, blockposition1, iblockdata);
+            boolean flag1 = (!top.leavesmc.leaves.LeavesConfig.redstoneDontCantOnTrapDoor && iblockdata.getBlock() instanceof TrapDoorBlock) || this.canSurviveOn(world, blockposition1, iblockdata); // Leaves - behavior to 1.19
 
             if (flag1 && RedStoneWireBlock.shouldConnectTo(world.getBlockState(blockposition1.above()))) {
                 if (iblockdata.isFaceSturdy(world, blockposition1, direction.getOpposite())) {
diff --git a/src/main/java/net/minecraft/world/level/block/ShulkerBoxBlock.java b/src/main/java/net/minecraft/world/level/block/ShulkerBoxBlock.java
index b51155ad12515b2d0dd0f202580b9f455c114d9a..49a4a19fd5292552e91799203108084ff4c1fa29 100644
--- a/src/main/java/net/minecraft/world/level/block/ShulkerBoxBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/ShulkerBoxBlock.java
@@ -253,7 +253,17 @@ public class ShulkerBoxBlock extends BaseEntityBlock {
 
     @Override
     public int getAnalogOutputSignal(BlockState state, Level world, BlockPos pos) {
-        return AbstractContainerMenu.getRedstoneSignalFromContainer((Container)world.getBlockEntity(pos));
+        // Leaves start - fix update suppression crash
+        if (top.leavesmc.leaves.LeavesConfig.updateSuppressionCrashFix) {
+            try {
+                return AbstractContainerMenu.getRedstoneSignalFromContainer((Container)world.getBlockEntity(pos));
+            } catch (ClassCastException ex) {
+                throw new top.leavesmc.leaves.util.UpdateSuppressionException(null, pos);
+            }
+        } else {
+            return AbstractContainerMenu.getRedstoneSignalFromContainer((Container)world.getBlockEntity(pos));
+        }
+        // Leaves end - fix update suppression crash
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/SignBlock.java b/src/main/java/net/minecraft/world/level/block/SignBlock.java
index e20c24c86db023ad269f15fe04963608e3fb3fe5..d2455f798a00580ebbb45e85ad2a6dcd7671207e 100644
--- a/src/main/java/net/minecraft/world/level/block/SignBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/SignBlock.java
@@ -96,6 +96,22 @@ public abstract class SignBlock extends BaseEntityBlock implements SimpleWaterlo
                     return InteractionResult.SUCCESS;
                 } else if (bl3) {
                     return InteractionResult.SUCCESS;
+                    // Leaves start - signContainerPassthrough
+                } else if (top.leavesmc.leaves.LeavesConfig.containerPassthrough) {
+                    if (item == net.minecraft.world.item.Items.AIR && player.isShiftKeyDown()) {
+                        if (!this.otherPlayerIsEditingSign(player, signBlockEntity) && player.mayBuild() && this.hasEditableText(player, signBlockEntity, bl2)) {
+                            this.openTextEdit(player, signBlockEntity, bl2);
+                            return InteractionResult.SUCCESS;
+                        }
+                    }
+
+                    BlockPos pos1 = pos.relative(hit.getDirection().getOpposite());
+                    if (world.getBlockEntity(pos1) instanceof net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity) {
+                        BlockState state1 = world.getBlockState(pos1);
+                        return state1.use(world, player, hand, hit.withPosition(pos1));
+                    }
+                    return InteractionResult.PASS;
+                    // Leaves end - signContainerPassthrough
                 } else if (!this.otherPlayerIsEditingSign(player, signBlockEntity) && player.mayBuild() && this.hasEditableText(player, signBlockEntity, bl2)) {
                     this.openTextEdit(player, signBlockEntity, bl2, io.papermc.paper.event.player.PlayerOpenSignEvent.Cause.INTERACT); // Paper
                     return InteractionResult.SUCCESS;
diff --git a/src/main/java/net/minecraft/world/level/block/SugarCaneBlock.java b/src/main/java/net/minecraft/world/level/block/SugarCaneBlock.java
index c3f500580d257e1397f2eb7c47b063a6fe6bb405..34de88e9677deb7b81b314d48c4880cce451d6a6 100644
--- a/src/main/java/net/minecraft/world/level/block/SugarCaneBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/SugarCaneBlock.java
@@ -39,8 +39,11 @@ public class SugarCaneBlock extends Block {
     public void tick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
         if (!state.canSurvive(world, pos)) {
             world.destroyBlock(pos, true);
+            // Leaves start - zero tick plants
+        } else if (top.leavesmc.leaves.LeavesConfig.zeroTickPlants) {
+            this.randomTick(state, world, pos, random);
+            // Leaves end - zero tick plants
         }
-
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/TrapDoorBlock.java b/src/main/java/net/minecraft/world/level/block/TrapDoorBlock.java
index b9e3c9cd709d42bced85436720ccc7b9c7e49552..90f193caf333d39e9494f1596d49b4a592e56e4c 100644
--- a/src/main/java/net/minecraft/world/level/block/TrapDoorBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/TrapDoorBlock.java
@@ -124,26 +124,7 @@ public class TrapDoorBlock extends HorizontalDirectionalBlock implements SimpleW
                     flag1 = eventRedstone.getNewCurrent() > 0;
                 }
                 // CraftBukkit end
-                boolean open = (Boolean) state.getValue(TrapDoorBlock.OPEN) != flag1; // Paper - break redstone on trapdoors early
-                // Paper start - break redstone on trapdoors early
-                // note: this must run before any state for this block/its neighborus are written to the world
-                // we allow the redstone event to fire so that plugins can block
-                if (flag1 && open) { // if we are now powered and it caused the trap door to open
-                    // in this case, first check for the redstone on top first
-                    BlockPos abovePos = pos.above();
-                    BlockState above = world.getBlockState(abovePos);
-                    if (above.getBlock() instanceof RedStoneWireBlock) {
-                        world.setBlock(abovePos, Blocks.AIR.defaultBlockState(), Block.UPDATE_CLIENTS | Block.UPDATE_NEIGHBORS);
-                        Block.popResource(world, abovePos, new net.minecraft.world.item.ItemStack(net.minecraft.world.item.Items.REDSTONE));
-                        // now check that this didn't change our state
-                        if (world.getBlockState(pos) != state) {
-                            // our state was changed, so we cannot propagate this update
-                            return;
-                        }
-                    }
-                }
-                // Paper end - break redstone on trapdoors early
-                if (open) { // Paper - break redstone on trapdoors early
+                if ((Boolean) state.getValue(TrapDoorBlock.OPEN) != flag1) { // Leaves - it is feature, not bug!
                     state = (BlockState) state.setValue(TrapDoorBlock.OPEN, flag1);
                     this.playSound((Player) null, world, pos, flag1);
                 }
diff --git a/src/main/java/net/minecraft/world/level/block/TripWireHookBlock.java b/src/main/java/net/minecraft/world/level/block/TripWireHookBlock.java
index 004dce26ff073f1de52a84cd425c4f60fdab5e50..22d42186973e8f0bf664c5fae261c40af2836173 100644
--- a/src/main/java/net/minecraft/world/level/block/TripWireHookBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/TripWireHookBlock.java
@@ -147,7 +147,7 @@ public class TripWireHookBlock extends Block {
                 boolean flag7 = (Boolean) iblockdata2.getValue(TripWireBlock.POWERED);
 
                 flag5 |= flag6 && flag7;
-                if (k != i || !tripWireBeingRemoved || !flag6) // Paper - don't update the tripwire again if being removed and not disarmed
+                if (k != i || true || !flag6) // Paper - don't update the tripwire again if being removed and not disarmed // Leaves - no! always update it
                 aiblockdata[k] = iblockdata2;
                 if (k == i) {
                     world.scheduleTick(pos, (Block) this, 10);
diff --git a/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
index 448fa4f4f200430d6ce3051763c7ceb697696146..bbb316b82fa1b1c8e968e9a1c90d47b7612bc2b1 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
@@ -58,6 +58,7 @@ import org.bukkit.event.inventory.FurnaceSmeltEvent;
 import org.bukkit.event.inventory.FurnaceStartSmeltEvent;
 import org.bukkit.inventory.CookingRecipe;
 // CraftBukkit end
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntity implements WorldlyContainer, RecipeHolder, StackedContentsCompatible {
 
@@ -65,7 +66,7 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
     protected static final int SLOT_FUEL = 1;
     protected static final int SLOT_RESULT = 2;
     public static final int DATA_LIT_TIME = 0;
-    private static final int[] SLOTS_FOR_UP = new int[]{0};
+    private static final int[] SLOTS_FOR_UP = ArrayConstants.zeroSingletonIntArray; // Leaves - reduce array allocations
     private static final int[] SLOTS_FOR_DOWN = new int[]{2, 1};
     private static final int[] SLOTS_FOR_SIDES = new int[]{1};
     public static final int DATA_LIT_DURATION = 1;
@@ -569,6 +570,16 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
 
     }
 
+    // Leaves start - pca
+    @Override
+    public void setChanged() {
+        super.setChanged();
+        if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+    }
+    // Leaves end - pca
+
     @Override
     public boolean stillValid(net.minecraft.world.entity.player.Player player) {
         return Container.stillValidBlockEntity(this, player);
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BarrelBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BarrelBlockEntity.java
index 416aa989ebb18a8741cc9d605a1180ab830f6643..213bc3c11ff4ed9bc761e8153aa669d1e2301960 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BarrelBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BarrelBlockEntity.java
@@ -131,6 +131,16 @@ public class BarrelBlockEntity extends RandomizableContainerBlockEntity {
         this.items = list;
     }
 
+    // Leaves start - pca
+    @Override
+    public void setChanged() {
+        super.setChanged();
+        if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+    }
+    // Leaves end - pca
+
     @Override
     protected Component getDefaultName() {
         return Component.translatable("container.barrel");
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java
index 41c9f074203915c31c1ae7a160ce509c13383f84..4c9e84dcd154a4306659ef41ab40127ea8452835 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java
@@ -4,6 +4,7 @@ import com.google.common.collect.Lists;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Objects;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -127,6 +128,11 @@ public class BeehiveBlockEntity extends BlockEntity {
             super.setChanged();
         }
 
+        // Leaves start - pca
+        if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+        // Leaves end - pca
         return list;
     }
 
@@ -188,6 +194,12 @@ public class BeehiveBlockEntity extends BlockEntity {
                 this.level.gameEvent(GameEvent.BLOCK_CHANGE, blockposition, GameEvent.Context.of(entity, this.getBlockState()));
             }
 
+            // Leaves start - pca
+            if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+                top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+            }
+            // Leaves end - pca
+
             entity.discard();
             super.setChanged();
         }
@@ -334,6 +346,11 @@ public class BeehiveBlockEntity extends BlockEntity {
                 if (BeehiveBlockEntity.releaseOccupant(world, pos, state, tileentitybeehive_hivebee, (List) null, tileentitybeehive_releasestatus, flowerPos)) {
                     flag = true;
                     iterator.remove();
+                    // Leaves start - pca
+                    if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+                        top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(Objects.requireNonNull(world.getBlockEntity(pos)));
+                    }
+                    // Leaves end - pca
                     // CraftBukkit start
                 } else {
                     tileentitybeehive_hivebee.exitTickCounter = tileentitybeehive_hivebee.minOccupationTicks / 2; // Not strictly Vanilla behaviour in cases where bees cannot spawn but still reasonable // Paper - use exitTickCounter to keep actual bee life
@@ -385,6 +402,11 @@ public class BeehiveBlockEntity extends BlockEntity {
             this.maxBees = nbt.getInt("Bukkit.MaxEntities");
         }
         // CraftBukkit end
+        // Leaves start - pca
+        if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+        // Leaves end - pca
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BrewingStandBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BrewingStandBlockEntity.java
index c57efcb9a79337ec791e4e8f6671612f0a82b441..218fbc794b086c2c3c04a3d183a0d43dcb74c4c2 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BrewingStandBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BrewingStandBlockEntity.java
@@ -334,6 +334,16 @@ public class BrewingStandBlockEntity extends BaseContainerBlockEntity implements
 
     }
 
+    // Leaves start - pca
+    @Override
+    public void setChanged() {
+        super.setChanged();
+        if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+    }
+    // Leaves end - pca
+
     @Override
     public boolean stillValid(Player player) {
         return Container.stillValidBlockEntity(this, player);
diff --git a/src/main/java/net/minecraft/world/level/block/entity/ChestBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/ChestBlockEntity.java
index a71414397bd45ee7bcacfeef0041d80dfa25f114..1d6c7a04b8246a60d80325e1615e50573b17a6bb 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/ChestBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/ChestBlockEntity.java
@@ -190,6 +190,16 @@ public class ChestBlockEntity extends RandomizableContainerBlockEntity implement
         this.items = list;
     }
 
+    // Leaves start - pca
+    @Override
+    public void setChanged() {
+        super.setChanged();
+        if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+    }
+    // Leaves end - pca
+
     @Override
     public float getOpenNess(float tickDelta) {
         return this.chestLidController.getOpenness(tickDelta);
diff --git a/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java
index 9b2c162c362fcf6093a3bf6da715ae8f18176c82..84b877a712a883b868b139d29da7e09c9552a1e5 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java
@@ -23,6 +23,16 @@ public class ComparatorBlockEntity extends BlockEntity {
         this.output = nbt.getInt("OutputSignal");
     }
 
+    // Leaves start - pca
+    @Override
+    public void setChanged() {
+        super.setChanged();
+        if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+    }
+    // Leaves end - pca
+
     public int getOutputSignal() {
         return this.output;
     }
diff --git a/src/main/java/net/minecraft/world/level/block/entity/DispenserBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/DispenserBlockEntity.java
index 881379681c39230a00b3a1f11cd87498984396c7..e01eb2025458cf311348c58a1530854053af78f4 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/DispenserBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/DispenserBlockEntity.java
@@ -92,6 +92,16 @@ public class DispenserBlockEntity extends RandomizableContainerBlockEntity {
         return -1;
     }
 
+    // Leaves start - pca
+    @Override
+    public void setChanged() {
+        super.setChanged();
+        if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+    }
+    // Leaves end - pca
+
     @Override
     protected Component getDefaultName() {
         return Component.translatable("container.dispenser");
diff --git a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
index b11f51762ca289d99eaa49e66e31e58595bcea4e..24d2b8a28bad8f33d5b27197fd80f7bb75926545 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
@@ -129,6 +129,16 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
 
     }
 
+    // Leaves start - pca
+    @Override
+    public void setChanged() {
+        super.setChanged();
+        if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+    }
+    // Leaves end - pca
+
     @Override
     protected Component getDefaultName() {
         return Component.translatable("container.hopper");
@@ -169,6 +179,11 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
                 if (flag) {
                     blockEntity.setCooldown(world.spigotConfig.hopperTransfer); // Spigot
                     setChanged(world, pos, state);
+                    // Leaves start - pca
+                    if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+                        top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(blockEntity);
+                    }
+                    // Leaves end - pca
                     return true;
                 }
             }
diff --git a/src/main/java/net/minecraft/world/level/block/entity/RandomizableContainerBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/RandomizableContainerBlockEntity.java
index 081691f9710ff1115e4308f79ed49fbc38941193..b9f4e2df35a12f6aebd7ef9fca94dd456a34682b 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/RandomizableContainerBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/RandomizableContainerBlockEntity.java
@@ -70,6 +70,7 @@ public abstract class RandomizableContainerBlockEntity extends BaseContainerBloc
     }
 
     public void unpackLootTable(@Nullable Player player) {
+        if (top.leavesmc.leaves.LeavesConfig.dontTriggerLootableRefreshNonPlayer && player == null) return; // Leaves - don't trigger lootable refresh for non-player interaction
         if (this.lootableData.shouldReplenish(player) && this.level.getServer() != null) { // Paper
             LootTable lootTable = this.level.getServer().getLootData().getLootTable(this.lootTable);
             if (player instanceof ServerPlayer) {
diff --git a/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java
index b7686fd63b7c5d88c3a12ec4ee9bc01a17f997e0..118a5b4c0a5268d52c69b0cfd061dbccfacf81b4 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java
@@ -151,7 +151,7 @@ public class ShulkerBoxBlockEntity extends RandomizableContainerBlockEntity impl
                 for (int i = 0; i < list.size(); ++i) {
                     Entity entity = (Entity) list.get(i);
 
-                    if (entity.getPistonPushReaction() != PushReaction.IGNORE) {
+                    if (entity.getPistonPushReaction() != PushReaction.IGNORE  && !(entity instanceof Player player && player.isCreativeFlyOrSpectator())) { // Leaves - creative no clip
                         entity.move(MoverType.SHULKER_BOX, new Vec3((axisalignedbb.getXsize() + 0.01D) * (double) enumdirection.getStepX(), (axisalignedbb.getYsize() + 0.01D) * (double) enumdirection.getStepY(), (axisalignedbb.getZsize() + 0.01D) * (double) enumdirection.getStepZ()));
                     }
                 }
@@ -259,6 +259,16 @@ public class ShulkerBoxBlockEntity extends RandomizableContainerBlockEntity impl
         this.itemStacks = list;
     }
 
+    // Leaves start - pca
+    @Override
+    public void setChanged() {
+        super.setChanged();
+        if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+    }
+    // Leaves end - pca
+
     @Override
     public int[] getSlotsForFace(Direction side) {
         return ShulkerBoxBlockEntity.SLOTS;
diff --git a/src/main/java/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java
index d9baa85962236c42219cf09d4f3129be93ff069c..c1bd06fbc2c5683888f7264c35c25feb31b00d67 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java
@@ -19,6 +19,7 @@ import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntitySelector;
+import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.entity.projectile.ThrownEnderpearl;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.ChunkPos;
@@ -128,7 +129,7 @@ public class TheEndGatewayBlockEntity extends TheEndPortalBlockEntity {
     }
 
     public static boolean canEntityTeleport(Entity entity) {
-        return EntitySelector.NO_SPECTATORS.test(entity) && !entity.getRootVehicle().isOnPortalCooldown();
+        return EntitySelector.NO_SPECTATORS.test(entity) && !entity.getRootVehicle().isOnPortalCooldown() && !(entity instanceof Player player && player.isCreativeFlyOrSpectator()); // Leaves - creative no clip
     }
 
     public boolean isSpawning() {
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
index 58d1f76544d7a8d196f75438579266664e5d7404..63b512283b2f5a96a78fe55d68e7373250367cdb 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -92,6 +92,11 @@ public class PistonBaseBlock extends DirectionalBlock {
     @Override
     public void setPlacedBy(Level world, BlockPos pos, BlockState state, LivingEntity placer, ItemStack itemStack) {
         if (!world.isClientSide) {
+            // Leaves start - break bedrock list
+            if (placer instanceof Player player) {
+                top.leavesmc.leaves.util.BreakBedrockList.onPlayerPlacePiston(world, player, pos);
+            }
+            // Leaves end - break bedrock list
             this.checkIfExtend(world, pos, state);
         }
 
@@ -277,13 +282,24 @@ public class PistonBaseBlock extends DirectionalBlock {
                             }
                         }
                         // Paper end
-                        world.removeBlock(pos.relative(enumdirection), false);
+                        // Leaves start - break bedrock list
+                        BlockPos pos1 = pos.relative(enumdirection);
+                        if (world.getBlockState(pos1).getBlock() == Blocks.BEDROCK) {
+                            top.leavesmc.leaves.util.BreakBedrockList.onPistonBreakBedrock(world, pos1);
+                        }
+                        world.removeBlock(pos1, false);
+                        // Leaves end - break bedrock list
                     }
                 }
             } else {
                 // Paper start - fix headless pistons breaking blocks
                 BlockPos headPos = pos.relative(enumdirection);
                 if (io.papermc.paper.configuration.GlobalConfiguration.get().unsupportedSettings.allowPermanentBlockBreakExploits || world.getBlockState(headPos) == Blocks.PISTON_HEAD.defaultBlockState().setValue(FACING, enumdirection)) { // double check to make sure we're not a headless piston.
+                    // Leaves start - break bedrock list
+                    if (world.getBlockState(headPos).getBlock() == Blocks.BEDROCK) {
+                        top.leavesmc.leaves.util.BreakBedrockList.onPistonBreakBedrock(world, headPos);
+                    }
+                    // Leaves end - break bedrock list
                     world.removeBlock(headPos, false);
                 } else {
                     ((ServerLevel)world).getChunkSource().blockChanged(headPos); // ... fix client desync
diff --git a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
index de4c1e4701236e7d5ec77339c51ad6a9d8288bb6..5757457fc46aa4a785e559a140ebf0da40ef7405 100644
--- a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
+++ b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
@@ -1042,7 +1042,7 @@ public abstract class BlockBehaviour implements FeatureElement {
         }
 
         public PushReaction getPistonPushReaction() {
-            return !this.isDestroyable() ? PushReaction.BLOCK : this.pushReaction; // Paper
+            return !this.isDestroyable() ? PushReaction.BLOCK : this.getBlock().getResetPushReaction() == null ? this.pushReaction : this.getBlock().getResetPushReaction(); // Paper // Leaves - can reset
         }
 
         public boolean isSolidRender(BlockGetter world, BlockPos pos) {
diff --git a/src/main/java/net/minecraft/world/level/block/state/pattern/BlockPattern.java b/src/main/java/net/minecraft/world/level/block/state/pattern/BlockPattern.java
index d0a047fd8849e9210dc9424325561f5a1b9998df..b665410788aa7c889dc214c2a97a9c29080b6001 100644
--- a/src/main/java/net/minecraft/world/level/block/state/pattern/BlockPattern.java
+++ b/src/main/java/net/minecraft/world/level/block/state/pattern/BlockPattern.java
@@ -60,7 +60,7 @@ public class BlockPattern {
     }
 
     @Nullable
-    private BlockPattern.BlockPatternMatch matches(BlockPos frontTopLeft, Direction forwards, Direction up, LoadingCache<BlockPos, BlockInWorld> cache) {
+    public BlockPattern.BlockPatternMatch matches(BlockPos frontTopLeft, Direction forwards, Direction up, LoadingCache<BlockPos, BlockInWorld> cache) { // Leaves - private -> public
         for(int i = 0; i < this.width; ++i) {
             for(int j = 0; j < this.height; ++j) {
                 for(int k = 0; k < this.depth; ++k) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 4ff0d2fc9fd76e92e64abd69f2c9e299aa08ac32..2c3ca05644bc97d505e8ca92e7a5f48670fd8b66 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -85,6 +85,18 @@ public class LevelChunk extends ChunkAccess {
     private final LevelChunkTicks<Block> blockTicks;
     private final LevelChunkTicks<Fluid> fluidTicks;
 
+    // Leaves start - instead of using a random every time the chunk is ticked, define when lightning strikes preemptively
+    private int lightningTick;
+    // shouldDoLightning compiles down to 29 bytes, which with the default of 35 byte inlining should guarantee an inline
+    public final boolean shouldDoLightning(net.minecraft.util.RandomSource random) {
+        if (this.lightningTick-- <= 0) {
+            this.lightningTick = random.nextInt(this.level.spigotConfig.thunderChance) << 1;
+            return true;
+        }
+        return false;
+    }
+    // Leaves end - instead of using a random every time the chunk is ticked, define when lightning strikes preemptively
+
     public LevelChunk(Level world, ChunkPos pos) {
         this(world, pos, UpgradeData.EMPTY, new LevelChunkTicks<>(), new LevelChunkTicks<>(), 0L, (LevelChunkSection[]) null, (LevelChunk.PostLoadProcessor) null, (BlendingData) null);
     }
@@ -112,6 +124,12 @@ public class LevelChunk extends ChunkAccess {
         this.postLoad = entityLoader;
         this.blockTicks = blockTickScheduler;
         this.fluidTicks = fluidTickScheduler;
+        
+        // Leaves start - initialize lightning tick
+        if (top.leavesmc.leaves.LeavesConfig.optimizeChunkTicking) {
+            this.lightningTick = this.level.getThreadUnsafeRandom().nextInt(100000) << 1;
+        }
+        // Leaves end - initialize lightning tick
     }
 
     // CraftBukkit start
@@ -1011,6 +1029,11 @@ public class LevelChunk extends ChunkAccess {
 
     public void setLoaded(boolean loadedToWorld) {
         this.loaded = loadedToWorld;
+        // Leaves start - bbor
+        if (loaded) {
+            top.leavesmc.leaves.protocol.BBORProtocol.onChunkLoaded(this);
+        }
+        // Leaves end - bbor
     }
 
     public Level getLevel() {
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
index d4477b0dda6a1ef7bd8323c0d11b636bd071d18e..3b7fcf532761362d2f657f58962d7bd2a6f35e94 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
@@ -25,6 +25,7 @@ public class LevelChunkSection {
     public final PalettedContainer<BlockState> states;
     // CraftBukkit start - read/write
     private PalettedContainer<Holder<Biome>> biomes;
+    public short fluidStateCount; // Leaves
     public final com.destroystokyo.paper.util.maplist.IBlockDataList tickingList = new com.destroystokyo.paper.util.maplist.IBlockDataList(); // Paper
 
     public LevelChunkSection(PalettedContainer<BlockState> datapaletteblock, PalettedContainer<Holder<Biome>> palettedcontainerro) {
@@ -190,6 +191,7 @@ public class LevelChunkSection {
 
         if (!fluid.isEmpty()) {
             --this.tickingFluidCount;
+            --this.fluidStateCount; // Leaves
         }
 
         if (!state.isAir()) {
@@ -204,6 +206,7 @@ public class LevelChunkSection {
 
         if (!fluid1.isEmpty()) {
             ++this.tickingFluidCount;
+            --this.fluidStateCount; // Leaves
         }
 
         this.updateKnownBlockInfo(x | (z << 4) | (y << 8), iblockdata1, state); // Paper
@@ -249,6 +252,7 @@ public class LevelChunkSection {
                 if (fluid.isRandomlyTicking()) {
                     this.tickingFluidCount = (short) (this.tickingFluidCount + 1);
                 }
+                this.fluidStateCount++; // Leaves
             }
 
         });
diff --git a/src/main/java/net/minecraft/world/level/chunk/PaletteResize.java b/src/main/java/net/minecraft/world/level/chunk/PaletteResize.java
index acae3eb30e0689048937f479dc3070f0688abdad..029b62acf1d9f8479ab64a55c12f00ba467249e3 100644
--- a/src/main/java/net/minecraft/world/level/chunk/PaletteResize.java
+++ b/src/main/java/net/minecraft/world/level/chunk/PaletteResize.java
@@ -1,5 +1,5 @@
 package net.minecraft.world.level.chunk;
 
-interface PaletteResize<T> {
+public interface PaletteResize<T> { // Leaves - package -> public
     int onResize(int newBits, T object);
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
index 7f5547dc31aa53b2863f4c09f598fa88e7fe2afd..f4bec4aba89a69a89c11c99d3291e2e86a7f4ea1 100644
--- a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
@@ -22,8 +22,25 @@ import net.minecraft.util.Mth;
 import net.minecraft.util.SimpleBitStorage;
 import net.minecraft.util.ThreadingDetector;
 import net.minecraft.util.ZeroBitStorage;
+import top.leavesmc.leaves.lithium.common.world.chunk.LithiumHashPalette;
 
 public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainerRO<T> {
+
+    // Leaves start - faster chunk serialization
+    private static final ThreadLocal<short[]> CACHED_ARRAY_4096 = ThreadLocal.withInitial(() -> new short[4096]);
+    private static final ThreadLocal<short[]> CACHED_ARRAY_64 = ThreadLocal.withInitial(() -> new short[64]);
+    private Optional<LongStream> asOptional(long[] data) {
+        return Optional.of(Arrays.stream(data));
+    }
+    private short[] getOrCreate(int size) {
+        return switch (size) {
+            case 64 -> CACHED_ARRAY_64.get();
+            case 4096 -> CACHED_ARRAY_4096.get();
+            default -> new short[size];
+        };
+    }
+    // Leaves end - faster chunk serialization
+
     private static final int MIN_PALETTE_BITS = 0;
     private final PaletteResize<T> dummyPaletteResize = (newSize, added) -> {
         return 0;
@@ -301,30 +318,78 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
     public synchronized PalettedContainerRO.PackedData<T> pack(IdMap<T> idList, PalettedContainer.Strategy paletteProvider) { // Paper - synchronize
         this.acquire();
 
-        PalettedContainerRO.PackedData var12;
-        try {
-            HashMapPalette<T> hashMapPalette = new HashMapPalette<>(idList, this.data.storage.getBits(), this.dummyPaletteResize);
-            int i = paletteProvider.size();
-            int[] is = new int[i];
-            this.data.storage.unpack(is);
-            swapPalette(is, (id) -> {
-                return hashMapPalette.idFor(this.data.palette.valueFor(id));
-            });
-            int j = paletteProvider.calculateBitsForSerialization(idList, hashMapPalette.getSize());
-            Optional<LongStream> optional;
-            if (j != 0) {
-                SimpleBitStorage simpleBitStorage = new SimpleBitStorage(j, i, is);
-                optional = Optional.of(Arrays.stream(simpleBitStorage.getRaw()));
-            } else {
-                optional = Optional.empty();
+        // Leaves start - faster chunk serialization
+        if (!top.leavesmc.leaves.LeavesConfig.fasterChunkSerialization) {
+            PalettedContainerRO.PackedData var12;
+            try {
+                HashMapPalette<T> hashMapPalette = new HashMapPalette<>(idList, this.data.storage.getBits(), this.dummyPaletteResize);
+                int i = paletteProvider.size();
+                int[] is = new int[i];
+                this.data.storage.unpack(is);
+                swapPalette(is, (id) -> {
+                    return hashMapPalette.idFor(this.data.palette.valueFor(id));
+                });
+                int j = paletteProvider.calculateBitsForSerialization(idList, hashMapPalette.getSize());
+                Optional<LongStream> optional;
+                if (j != 0) {
+                    SimpleBitStorage simpleBitStorage = new SimpleBitStorage(j, i, is);
+                    optional = Optional.of(Arrays.stream(simpleBitStorage.getRaw()));
+                } else {
+                    optional = Optional.empty();
+                }
+
+                var12 = new PalettedContainerRO.PackedData<>(hashMapPalette.getEntries(), optional);
+            } finally {
+                this.release();
             }
 
-            var12 = new PalettedContainerRO.PackedData<>(hashMapPalette.getEntries(), optional);
-        } finally {
-            this.release();
-        }
+            return var12;
+        } else {
+            Optional<LongStream> data = Optional.empty();
+            List<T> elements = null;
+            try {
+                // The palette that will be serialized
+                LithiumHashPalette<T> hashPalette = null;
+
+                final Palette<T> palette = this.data.palette();
+                final BitStorage storage = this.data.storage();
+                if (storage instanceof ZeroBitStorage || palette.getSize() == 1) {
+                    // If the palette only contains one entry, don't attempt to repack it.
+                    elements = List.of(palette.valueFor(0));
+                } else if (palette instanceof LithiumHashPalette<T> lithiumHashPalette) {
+                    hashPalette = lithiumHashPalette;
+                }
 
-        return var12;
+                if (elements == null) {
+                    LithiumHashPalette<T> compactedPalette = new LithiumHashPalette<>(idList, storage.getBits(), this.dummyPaletteResize);
+                    short[] array = this.getOrCreate(paletteProvider.size());
+
+                    storage.compact(this.data.palette(), compactedPalette, array);
+
+                    // If the palette didn't change during compaction, do a simple copy of the data array
+                    if (hashPalette != null && hashPalette.getSize() == compactedPalette.getSize() && storage.getBits() == paletteProvider.calculateBitsForSerialization(idList, hashPalette.getSize())) { // paletteSize can de-sync from palette - see https://github.com/CaffeineMC/lithium-fabric/issues/279
+                        data = this.asOptional(storage.getRaw().clone());
+                        elements = hashPalette.getElements();
+                    } else {
+                        int bits = paletteProvider.calculateBitsForSerialization(idList, compactedPalette.getSize());
+                        if (bits != 0) {
+                            // Re-pack the integer array as the palette has changed size
+                            SimpleBitStorage copy = new SimpleBitStorage(bits, array.length);
+                            for (int i = 0; i < array.length; ++i) {
+                                copy.set(i, array[i]);
+                            }
+                            // We don't need to clone the data array as we are the sole owner of it
+                            data = this.asOptional(copy.getRaw());
+                        }
+                    }
+                    elements = compactedPalette.getElements();
+                }
+            } finally {
+                this.release();
+            }
+            return new PalettedContainerRO.PackedData<>(elements, data);
+        }
+        // Leaves end - faster chunk serialization
     }
 
     private static <T> void swapPalette(int[] is, IntUnaryOperator applier) {
@@ -364,17 +429,47 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
 
     @Override
     public void count(PalettedContainer.CountConsumer<T> counter) {
-        if (this.data.palette.getSize() == 1) {
-            counter.accept(this.data.palette.valueFor(0), this.data.storage.getSize());
+        // Leaves start - faster chunk serialization
+        if (!top.leavesmc.leaves.LeavesConfig.fasterChunkSerialization) {
+            if (this.data.palette.getSize() == 1) {
+                counter.accept(this.data.palette.valueFor(0), this.data.storage.getSize());
+            } else {
+                Int2IntOpenHashMap int2IntOpenHashMap = new Int2IntOpenHashMap();
+                this.data.storage.getAll((key) -> {
+                    int2IntOpenHashMap.addTo(key, 1);
+                });
+                int2IntOpenHashMap.int2IntEntrySet().forEach((entry) -> {
+                    counter.accept(this.data.palette.valueFor(entry.getIntKey()), entry.getIntValue());
+                });
+            }
         } else {
-            Int2IntOpenHashMap int2IntOpenHashMap = new Int2IntOpenHashMap();
-            this.data.storage.getAll((key) -> {
-                int2IntOpenHashMap.addTo(key, 1);
-            });
-            int2IntOpenHashMap.int2IntEntrySet().forEach((entry) -> {
-                counter.accept(this.data.palette.valueFor(entry.getIntKey()), entry.getIntValue());
-            });
+            int len = this.data.palette().getSize();
+
+            // Do not allocate huge arrays if we're using a large palette
+            if (len > 4096) {
+                if (this.data.palette.getSize() == 1) {
+                    counter.accept(this.data.palette.valueFor(0), this.data.storage.getSize());
+                } else {
+                    Int2IntOpenHashMap int2IntOpenHashMap = new Int2IntOpenHashMap();
+                    this.data.storage.getAll((key) -> {
+                        int2IntOpenHashMap.addTo(key, 1);
+                    });
+                    int2IntOpenHashMap.int2IntEntrySet().forEach((entry) -> {
+                        counter.accept(this.data.palette.valueFor(entry.getIntKey()), entry.getIntValue());
+                    });
+                }
+            }
+
+            short[] counts = new short[len];
+            this.data.storage().getAll(i -> counts[i]++);
+            for (int i = 0; i < counts.length; i++) {
+                T obj = this.data.palette().valueFor(i);
+                if (obj != null) {
+                    counter.accept(obj, counts[i]);
+                }
+            }
         }
+        // Leaves end - faster chunk serialization
     }
 
     static record Configuration<T>(Palette.Factory factory, int bits) {
diff --git a/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java b/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java
index e2cd77d9de9709aa50f4b6febabe21bfcf94dc5d..d6f2e8875464a0fbf53546424ed65f5e8d73b0e4 100644
--- a/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java
+++ b/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java
@@ -43,6 +43,7 @@ import net.minecraft.world.entity.boss.enderdragon.phases.EnderDragonPhase;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.TheEndGatewayBlockEntity;
 import net.minecraft.world.level.block.entity.TheEndPortalBlockEntity;
 import net.minecraft.world.level.block.state.pattern.BlockInWorld;
 import net.minecraft.world.level.block.state.pattern.BlockPattern;
@@ -258,8 +259,67 @@ public class EndDragonFight {
         return false;
     }
 
+    // Leaves start - optimizedDragonRespawn
+    private int cachePortalChunkIteratorX = -8;
+    private int cachePortalChunkIteratorZ = -8;
+    private int cachePortalOriginIteratorY = -1;
+
     @Nullable
     public BlockPattern.BlockPatternMatch findExitPortal() {
+        if (top.leavesmc.leaves.LeavesConfig.optimizedDragonRespawn) {
+            int i, j;
+            for (i = cachePortalChunkIteratorX; i <= 8; ++i) {
+                for (j = cachePortalChunkIteratorZ; j <= 8; ++j) {
+                    LevelChunk worldChunk = this.level.getChunk(i, j);
+                    for (BlockEntity blockEntity : worldChunk.getBlockEntities().values()) {
+                        if (blockEntity instanceof TheEndGatewayBlockEntity) {
+                            continue;
+                        }
+                        if (blockEntity instanceof TheEndPortalBlockEntity) {
+                            BlockPattern.BlockPatternMatch blockPatternMatch = this.exitPortalPattern.find(this.level, blockEntity.getBlockPos());
+                            if (blockPatternMatch != null) {
+                                BlockPos blockPos = blockPatternMatch.getBlock(3, 3, 3).getPos();
+                                if (this.portalLocation == null) {
+                                    this.portalLocation = blockPos;
+                                }
+                                //No need to judge whether optimizing option is open
+                                cachePortalChunkIteratorX = i;
+                                cachePortalChunkIteratorZ = j;
+                                return blockPatternMatch;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (this.needsStateScanning || this.portalLocation == null) {
+                if (cachePortalOriginIteratorY != -1) {
+                    i = cachePortalOriginIteratorY;
+                } else {
+                    i = this.level.getHeightmapPos(Heightmap.Types.MOTION_BLOCKING, EndPodiumFeature.getLocation(BlockPos.ZERO)).getY();
+                }
+                boolean notFirstSearch = false;
+                for (j = i; j >= 0; --j) {
+                    BlockPattern.BlockPatternMatch result2 = null;
+                    if (notFirstSearch) {
+                        result2 = top.leavesmc.leaves.util.BlockPatternHelper.partialSearchAround(this.exitPortalPattern, this.level, new BlockPos(EndPodiumFeature.getLocation(BlockPos.ZERO).getY(), j, EndPodiumFeature.getLocation(BlockPos.ZERO).getZ()));
+                    } else {
+                        result2 = this.exitPortalPattern.find(this.level, new BlockPos(EndPodiumFeature.getLocation(BlockPos.ZERO).getX(), j, EndPodiumFeature.getLocation(BlockPos.ZERO).getZ()));
+                    }
+                    if (result2 != null) {
+                        if (this.portalLocation == null) {
+                            this.portalLocation = result2.getBlock(3, 3, 3).getPos();
+                        }
+                        cachePortalOriginIteratorY = j;
+                        return result2;
+                    }
+                    notFirstSearch = true;
+                }
+            }
+
+            return null;
+        }
+    // Leaves end - optimizedDragonRespawn
         ChunkPos chunkPos = new ChunkPos(this.origin);
 
         for(int i = -8 + chunkPos.x; i <= 8 + chunkPos.x; ++i) {
@@ -513,6 +573,11 @@ public class EndDragonFight {
     }
 
     private void respawnDragon(List<EndCrystal> crystals) {
+        // Leaves - start optimizedDragonRespawn
+        cachePortalChunkIteratorX = -8;
+        cachePortalChunkIteratorZ = -8;
+        cachePortalOriginIteratorY = -1;
+        // Leaves - end optimizedDragonRespawn
         if (this.dragonKilled && this.respawnStage == null) {
             for(BlockPattern.BlockPatternMatch blockPatternMatch = this.findExitPortal(); blockPatternMatch != null; blockPatternMatch = this.findExitPortal()) {
                 for(int i = 0; i < this.exitPortalPattern.getWidth(); ++i) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
index 58609a0911c4e32b6f80f050cd3d23f70ad75b1b..3524296ec3b3495b65f83d84005499d218a59254 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
@@ -62,12 +62,17 @@ public final class NoiseBasedChunkGenerator extends ChunkGenerator {
     private static final BlockState AIR = Blocks.AIR.defaultBlockState();
     public final Holder<NoiseGeneratorSettings> settings;
     private final Supplier<Aquifer.FluidPicker> globalFluidPicker;
+    private int cachedSeaLevel; // Leaves - cache world generator sea level
 
     public NoiseBasedChunkGenerator(BiomeSource biomeSource, Holder<NoiseGeneratorSettings> settings) {
         super(biomeSource);
         this.settings = settings;
         this.globalFluidPicker = Suppliers.memoize(() -> {
-            return NoiseBasedChunkGenerator.createFluidPicker((NoiseGeneratorSettings) settings.value());
+            // Leaves start - cache world generator sea level
+            var fluidPicker = NoiseBasedChunkGenerator.createFluidPicker((NoiseGeneratorSettings) settings.value());
+            this.cachedSeaLevel = settings.value().seaLevel();
+            return fluidPicker;
+            // Leaves end - cache world generator sea level
         });
     }
 
@@ -394,7 +399,13 @@ public final class NoiseBasedChunkGenerator extends ChunkGenerator {
 
     @Override
     public int getSeaLevel() {
-        return ((NoiseGeneratorSettings) this.settings.value()).seaLevel();
+        // Leaves start - cache world generator sea level
+        if (!top.leavesmc.leaves.LeavesConfig.cacheWorldGeneratorSeaLevel) {
+            return ((NoiseGeneratorSettings) this.settings.value()).seaLevel();
+        } else {
+            return cachedSeaLevel;
+        }
+        // Leaves end - cache world generator sea level
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java b/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java
index fb84d703b4461343d50510d7c9be32fc1f09ed22..0e025df446d0243275c13bca7efd7a0bae1dc35b 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java
@@ -11,6 +11,27 @@ public final class ImprovedNoise {
     public final double yo;
     public final double zo;
 
+    // Leaves start - optimize noise generation
+    private static final double[] FLAT_SIMPLEX_GRAD = new double[]{
+        1, 1, 0, 0,
+        -1, 1, 0, 0,
+        1, -1, 0, 0,
+        -1, -1, 0, 0,
+        1, 0, 1, 0,
+        -1, 0, 1, 0,
+        1, 0, -1, 0,
+        -1, 0, -1, 0,
+        0, 1, 1, 0,
+        0, -1, 1, 0,
+        0, 1, -1, 0,
+        0, -1, -1, 0,
+        1, 1, 0, 0,
+        0, -1, 1, 0,
+        -1, 1, 0, 0,
+        0, -1, -1, 0,
+    };
+    // Leaves end - optimize noise generation
+
     public ImprovedNoise(RandomSource random) {
         this.xo = random.nextDouble() * 256.0D;
         this.yo = random.nextDouble() * 256.0D;
@@ -43,9 +64,20 @@ public final class ImprovedNoise {
         int i = Mth.floor(d);
         int j = Mth.floor(e);
         int k = Mth.floor(f);
-        double g = d - (double)i;
-        double h = e - (double)j;
-        double l = f - (double)k;
+        // Leaves start - optimize noise generation
+        double g;
+        double h;
+        double l;
+        if (!top.leavesmc.leaves.LeavesConfig.optimizeNoiseGeneration) {
+            g = d - (double)i;
+            h = e - (double)j;
+            l = f - (double)k;
+        } else {
+            g = d - i;
+            h = e - j;
+            l = f - k;
+        }
+        // Leaves end - optimize noise generation
         double o;
         if (yScale != 0.0D) {
             double m;
@@ -55,12 +87,24 @@ public final class ImprovedNoise {
                 m = h;
             }
 
-            o = (double)Mth.floor(m / yScale + (double)1.0E-7F) * yScale;
+            // Leaves start - optimize noise generation
+            if (!top.leavesmc.leaves.LeavesConfig.optimizeNoiseGeneration) {
+                o = (double)Mth.floor(m / yScale + (double)1.0E-7F) * yScale;
+            } else {
+                o = Math.floor(m / yScale + (double)1.0E-7F) * yScale;
+            }
+            // Leaves end - optimize noise generation
         } else {
             o = 0.0D;
         }
 
-        return this.sampleAndLerp(i, j, k, g, h - o, l, h);
+        // Leaves start - optimize noise generation
+        if (!top.leavesmc.leaves.LeavesConfig.optimizeNoiseGeneration) {
+            return this.sampleAndLerp(i, j, k, g, h - o, l, h);
+        } else {
+            return this.sampleAndLerp((int) i, (int) j, (int) k, g, h - o, l, h);
+        }
+        // Leaves end - optimize noise generation
     }
 
     public double noiseWithDerivative(double x, double y, double z, double[] ds) {
@@ -70,10 +114,19 @@ public final class ImprovedNoise {
         int i = Mth.floor(d);
         int j = Mth.floor(e);
         int k = Mth.floor(f);
-        double g = d - (double)i;
-        double h = e - (double)j;
-        double l = f - (double)k;
-        return this.sampleWithDerivative(i, j, k, g, h, l, ds);
+        // Leaves start - optimize noise generation
+        if (!top.leavesmc.leaves.LeavesConfig.optimizeNoiseGeneration) {
+            double g = d - (double)i;
+            double h = e - (double)j;
+            double l = f - (double)k;
+            return this.sampleWithDerivative(i, j, k, g, h, l, ds);
+        } else {
+            double g = d - i;
+            double h = e - j;
+            double l = f - k;
+            return this.sampleWithDerivative((int) i, (int) j, (int) k, g, h, l, ds);
+        }
+        // Leaves end - optimize noise generation
     }
 
     private static double gradDot(int hash, double x, double y, double z) {
@@ -85,24 +138,90 @@ public final class ImprovedNoise {
     }
 
     private double sampleAndLerp(int sectionX, int sectionY, int sectionZ, double localX, double localY, double localZ, double fadeLocalY) {
-        int i = this.p(sectionX);
-        int j = this.p(sectionX + 1);
-        int k = this.p(i + sectionY);
-        int l = this.p(i + sectionY + 1);
-        int m = this.p(j + sectionY);
-        int n = this.p(j + sectionY + 1);
-        double d = gradDot(this.p(k + sectionZ), localX, localY, localZ);
-        double e = gradDot(this.p(m + sectionZ), localX - 1.0D, localY, localZ);
-        double f = gradDot(this.p(l + sectionZ), localX, localY - 1.0D, localZ);
-        double g = gradDot(this.p(n + sectionZ), localX - 1.0D, localY - 1.0D, localZ);
-        double h = gradDot(this.p(k + sectionZ + 1), localX, localY, localZ - 1.0D);
-        double o = gradDot(this.p(m + sectionZ + 1), localX - 1.0D, localY, localZ - 1.0D);
-        double p = gradDot(this.p(l + sectionZ + 1), localX, localY - 1.0D, localZ - 1.0D);
-        double q = gradDot(this.p(n + sectionZ + 1), localX - 1.0D, localY - 1.0D, localZ - 1.0D);
-        double r = Mth.smoothstep(localX);
-        double s = Mth.smoothstep(fadeLocalY);
-        double t = Mth.smoothstep(localZ);
-        return Mth.lerp3(r, s, t, d, e, f, g, h, o, p, q);
+        // Leaves start - optimize noise generation
+        if (!top.leavesmc.leaves.LeavesConfig.optimizeNoiseGeneration) {
+            int i = this.p(sectionX);
+            int j = this.p(sectionX + 1);
+            int k = this.p(i + sectionY);
+            int l = this.p(i + sectionY + 1);
+            int m = this.p(j + sectionY);
+            int n = this.p(j + sectionY + 1);
+            double d = gradDot(this.p(k + sectionZ), localX, localY, localZ);
+            double e = gradDot(this.p(m + sectionZ), localX - 1.0D, localY, localZ);
+            double f = gradDot(this.p(l + sectionZ), localX, localY - 1.0D, localZ);
+            double g = gradDot(this.p(n + sectionZ), localX - 1.0D, localY - 1.0D, localZ);
+            double h = gradDot(this.p(k + sectionZ + 1), localX, localY, localZ - 1.0D);
+            double o = gradDot(this.p(m + sectionZ + 1), localX - 1.0D, localY, localZ - 1.0D);
+            double p = gradDot(this.p(l + sectionZ + 1), localX, localY - 1.0D, localZ - 1.0D);
+            double q = gradDot(this.p(n + sectionZ + 1), localX - 1.0D, localY - 1.0D, localZ - 1.0D);
+            double r = Mth.smoothstep(localX);
+            double s = Mth.smoothstep(fadeLocalY);
+            double t = Mth.smoothstep(localZ);
+            return Mth.lerp3(r, s, t, d, e, f, g, h, o, p, q);
+        } else {
+            final int var0 = sectionX & 0xFF;
+            final int var1 = (sectionX + 1) & 0xFF;
+            final int var2 = this.p[var0] & 0xFF;
+            final int var3 = this.p[var1] & 0xFF;
+            final int var4 = (var2 + sectionY) & 0xFF;
+            final int var5 = (var3 + sectionY) & 0xFF;
+            final int var6 = (var2 + sectionY + 1) & 0xFF;
+            final int var7 = (var3 + sectionY + 1) & 0xFF;
+            final int var8 = this.p[var4] & 0xFF;
+            final int var9 = this.p[var5] & 0xFF;
+            final int var10 = this.p[var6] & 0xFF;
+            final int var11 = this.p[var7] & 0xFF;
+
+            final int var12 = (var8 + sectionZ) & 0xFF;
+            final int var13 = (var9 + sectionZ) & 0xFF;
+            final int var14 = (var10 + sectionZ) & 0xFF;
+            final int var15 = (var11 + sectionZ) & 0xFF;
+            final int var16 = (var8 + sectionZ + 1) & 0xFF;
+            final int var17 = (var9 + sectionZ + 1) & 0xFF;
+            final int var18 = (var10 + sectionZ + 1) & 0xFF;
+            final int var19 = (var11 + sectionZ + 1) & 0xFF;
+            final int var20 = (this.p[var12] & 15) << 2;
+            final int var21 = (this.p[var13] & 15) << 2;
+            final int var22 = (this.p[var14] & 15) << 2;
+            final int var23 = (this.p[var15] & 15) << 2;
+            final int var24 = (this.p[var16] & 15) << 2;
+            final int var25 = (this.p[var17] & 15) << 2;
+            final int var26 = (this.p[var18] & 15) << 2;
+            final int var27 = (this.p[var19] & 15) << 2;
+            final double var60 = localX - 1.0;
+            final double var61 = localY - 1.0;
+            final double var62 = localZ - 1.0;
+            final double var87 = FLAT_SIMPLEX_GRAD[(var20) | 0] * localX + FLAT_SIMPLEX_GRAD[(var20) | 1] * localY + FLAT_SIMPLEX_GRAD[(var20) | 2] * localZ;
+            final double var88 = FLAT_SIMPLEX_GRAD[(var21) | 0] * var60 + FLAT_SIMPLEX_GRAD[(var21) | 1] * localY + FLAT_SIMPLEX_GRAD[(var21) | 2] * localZ;
+            final double var89 = FLAT_SIMPLEX_GRAD[(var22) | 0] * localX + FLAT_SIMPLEX_GRAD[(var22) | 1] * var61 + FLAT_SIMPLEX_GRAD[(var22) | 2] * localZ;
+            final double var90 = FLAT_SIMPLEX_GRAD[(var23) | 0] * var60 + FLAT_SIMPLEX_GRAD[(var23) | 1] * var61 + FLAT_SIMPLEX_GRAD[(var23) | 2] * localZ;
+            final double var91 = FLAT_SIMPLEX_GRAD[(var24) | 0] * localX + FLAT_SIMPLEX_GRAD[(var24) | 1] * localY + FLAT_SIMPLEX_GRAD[(var24) | 2] * var62;
+            final double var92 = FLAT_SIMPLEX_GRAD[(var25) | 0] * var60 + FLAT_SIMPLEX_GRAD[(var25) | 1] * localY + FLAT_SIMPLEX_GRAD[(var25) | 2] * var62;
+            final double var93 = FLAT_SIMPLEX_GRAD[(var26) | 0] * localX + FLAT_SIMPLEX_GRAD[(var26) | 1] * var61 + FLAT_SIMPLEX_GRAD[(var26) | 2] * var62;
+            final double var94 = FLAT_SIMPLEX_GRAD[(var27) | 0] * var60 + FLAT_SIMPLEX_GRAD[(var27) | 1] * var61 + FLAT_SIMPLEX_GRAD[(var27) | 2] * var62;
+
+            final double var95 = localX * 6.0 - 15.0;
+            final double var96 = fadeLocalY * 6.0 - 15.0;
+            final double var97 = localZ * 6.0 - 15.0;
+            final double var98 = localX * var95 + 10.0;
+            final double var99 = fadeLocalY * var96 + 10.0;
+            final double var100 = localZ * var97 + 10.0;
+            final double var101 = localX * localX * localX * var98;
+            final double var102 = fadeLocalY * fadeLocalY * fadeLocalY * var99;
+            final double var103 = localZ * localZ * localZ * var100;
+
+            final double var113 = var87 + var101 * (var88 - var87);
+            final double var114 = var93 + var101 * (var94 - var93);
+            final double var115 = var91 + var101 * (var92 - var91);
+            final double var116 = var89 + var101 * (var90 - var89);
+            final double var117 = var114 - var115;
+            final double var118 = var102 * (var116 - var113);
+            final double var119 = var102 * var117;
+            final double var120 = var113 + var118;
+            final double var121 = var115 + var119;
+            return var120 + (var103 * (var121 - var120));
+        }
+        // Leaves end - optimize noise generation
     }
 
     private double sampleWithDerivative(int sectionX, int sectionY, int sectionZ, double localX, double localY, double localZ, double[] ds) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java b/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java
index 97ef7288ea935f3d17c5b7a9eba642143c786c2b..c71dc320b055c5b1981561894617be05dae35653 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java
@@ -26,6 +26,10 @@ public class PerlinNoise {
     private final double lowestFreqValueFactor;
     private final double lowestFreqInputFactor;
     private final double maxValue;
+    // Leaves start - optimize noise generation
+    private final int octaveSamplersCount;
+    private final double [] amplitudesArray;
+    // Leaves end - optimize noise generation
 
     /** @deprecated */
     @Deprecated
@@ -131,6 +135,10 @@ public class PerlinNoise {
         this.lowestFreqInputFactor = Math.pow(2.0D, (double)(-j));
         this.lowestFreqValueFactor = Math.pow(2.0D, (double)(i - 1)) / (Math.pow(2.0D, (double)i) - 1.0D);
         this.maxValue = this.edgeValue(2.0D);
+        // Leaves start - optimize noise generation
+        this.octaveSamplersCount = this.noiseLevels.length;
+        this.amplitudesArray = this.amplitudes.toDoubleArray();
+        // Leaves end - optimize noise generation
     }
 
     protected double maxValue() {
@@ -142,7 +150,30 @@ public class PerlinNoise {
     }
 
     public double getValue(double x, double y, double z) {
-        return this.getValue(x, y, z, 0.0D, 0.0D, false);
+        // Leaves start - optimize noise generation
+        if (!top.leavesmc.leaves.LeavesConfig.optimizeNoiseGeneration) {
+            return this.getValue(x, y, z, 0.0D, 0.0D, false);
+        } else {
+            double d = 0.0;
+            double e = this.lowestFreqInputFactor;
+            double f = this.lowestFreqValueFactor;
+
+            for(int i = 0; i < this.octaveSamplersCount; ++i) {
+                ImprovedNoise perlinNoiseSampler = this.noiseLevels[i];
+                if (perlinNoiseSampler != null) {
+                    @SuppressWarnings("deprecation")
+                    double g = perlinNoiseSampler.noise(
+                        wrap(x * e), wrap(y * e), wrap(z * e), 0.0, 0.0
+                    );
+                    d += this.amplitudesArray[i] * g * f;
+                }
+
+                e *= 2.0;
+                f /= 2.0;
+            }
+            return d;
+        }
+        // Leaves end - optimize noise generation
     }
 
     /** @deprecated */
diff --git a/src/main/java/net/minecraft/world/level/material/FlowingFluid.java b/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
index 5502ad143fd2575f1346334b5b4fe7846628f54e..c50fd02935870b0f660544efe3d05ea177a0102e 100644
--- a/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
+++ b/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
@@ -52,6 +52,11 @@ public abstract class FlowingFluid extends Fluid {
         object2bytelinkedopenhashmap.defaultReturnValue((byte) 127);
         return object2bytelinkedopenhashmap;
     });
+    // Leaves start - use our own cache
+    private static final ThreadLocal<top.leavesmc.leaves.structs.FluidDirectionCache<Block.BlockStatePairKey>> localFluidDirectionCache = ThreadLocal.withInitial(() -> {
+        return new top.leavesmc.leaves.structs.FluidDirectionCache<>(2048);
+    });
+    // Leaves end - use our own cache
     private final Map<FluidState, VoxelShape> shapes = Maps.newIdentityHashMap();
 
     public FlowingFluid() {}
@@ -240,40 +245,70 @@ public abstract class FlowingFluid extends Fluid {
     }
 
     private boolean canPassThroughWall(Direction face, BlockGetter world, BlockPos pos, BlockState state, BlockPos fromPos, BlockState fromState) {
-        Object2ByteLinkedOpenHashMap object2bytelinkedopenhashmap;
+        // Leaves start - cache
+        if (!top.leavesmc.leaves.LeavesConfig.improveFluidDirectionCaching) {
+            Object2ByteLinkedOpenHashMap object2bytelinkedopenhashmap;
+
+            if (!state.getBlock().hasDynamicShape() && !fromState.getBlock().hasDynamicShape()) {
+                object2bytelinkedopenhashmap = (Object2ByteLinkedOpenHashMap) FlowingFluid.OCCLUSION_CACHE.get();
+            } else {
+                object2bytelinkedopenhashmap = null;
+            }
 
-        if (!state.getBlock().hasDynamicShape() && !fromState.getBlock().hasDynamicShape()) {
-            object2bytelinkedopenhashmap = (Object2ByteLinkedOpenHashMap) FlowingFluid.OCCLUSION_CACHE.get();
-        } else {
-            object2bytelinkedopenhashmap = null;
-        }
+            Block.BlockStatePairKey block_a;
+
+            if (object2bytelinkedopenhashmap != null) {
+                block_a = new Block.BlockStatePairKey(state, fromState, face);
+                byte b0 = object2bytelinkedopenhashmap.getAndMoveToFirst(block_a);
+
+                if (b0 != 127) {
+                    return b0 != 0;
+                }
+            } else {
+                block_a = null;
+            }
 
-        Block.BlockStatePairKey block_a;
+            VoxelShape voxelshape = state.getCollisionShape(world, pos);
+            VoxelShape voxelshape1 = fromState.getCollisionShape(world, fromPos);
+            boolean flag = !Shapes.mergedFaceOccludes(voxelshape, voxelshape1, face);
 
-        if (object2bytelinkedopenhashmap != null) {
-            block_a = new Block.BlockStatePairKey(state, fromState, face);
-            byte b0 = object2bytelinkedopenhashmap.getAndMoveToFirst(block_a);
+            if (object2bytelinkedopenhashmap != null) {
+                if (object2bytelinkedopenhashmap.size() == 200) {
+                    object2bytelinkedopenhashmap.removeLastByte();
+                }
 
-            if (b0 != 127) {
-                return b0 != 0;
+                object2bytelinkedopenhashmap.putAndMoveToFirst(block_a, (byte) (flag ? 1 : 0));
             }
+
+            return flag;
         } else {
-            block_a = null;
-        }
+            top.leavesmc.leaves.structs.FluidDirectionCache<Block.BlockStatePairKey> cache = null;
+            if (!state.getBlock().hasDynamicShape() && !fromState.getBlock().hasDynamicShape()) {
+                cache = localFluidDirectionCache.get();
+            }
 
-        VoxelShape voxelshape = state.getCollisionShape(world, pos);
-        VoxelShape voxelshape1 = fromState.getCollisionShape(world, fromPos);
-        boolean flag = !Shapes.mergedFaceOccludes(voxelshape, voxelshape1, face);
+            Block.BlockStatePairKey block_a;
+            if (cache != null) {
+                block_a = new Block.BlockStatePairKey(state, fromState, face);
+                Boolean flag = cache.getValue(block_a);
+                if (flag != null) {
+                    return flag;
+                }
+            } else {
+                block_a = null;
+            }
 
-        if (object2bytelinkedopenhashmap != null) {
-            if (object2bytelinkedopenhashmap.size() == 200) {
-                object2bytelinkedopenhashmap.removeLastByte();
+            VoxelShape voxelshape = state.getCollisionShape(world, pos);
+            VoxelShape voxelshape1 = fromState.getCollisionShape(world, fromPos);
+            boolean flag = !Shapes.mergedFaceOccludes(voxelshape, voxelshape1, face);
+
+            if (cache != null) {
+                cache.putValue(block_a, flag);
             }
 
-            object2bytelinkedopenhashmap.putAndMoveToFirst(block_a, (byte) (flag ? 1 : 0));
+            return flag;
         }
-
-        return flag;
+        // Leaves start - cache
     }
 
     public abstract Fluid getFlowing();
@@ -467,6 +502,7 @@ public abstract class FlowingFluid extends Fluid {
 
     @Override
     public void tick(Level world, BlockPos pos, FluidState state) {
+        if (top.leavesmc.leaves.command.NoBlockUpdateCommand.isNoBlockUpdate()) return; // Leaves - no block update
         if (!state.isSource()) {
             FluidState fluid1 = this.getNewLiquid(world, pos, world.getBlockState(pos));
             int i = this.getSpreadDelay(world, pos, state, fluid1);
diff --git a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
index ec81be70cd6f92bbf9011395cb361f0ce54c5ad0..cc12f8575b21c973842b14998af1d92c9c217911 100644
--- a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
+++ b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
@@ -46,6 +46,7 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     }
 
     private void addAndRun(BlockPos pos, CollectingNeighborUpdater.NeighborUpdates entry) {
+        if (top.leavesmc.leaves.command.NoBlockUpdateCommand.isNoBlockUpdate()) return; // Leaves - no block update
         boolean bl = this.count > 0;
         boolean bl2 = this.maxChainedNeighborUpdates >= 0 && this.count >= this.maxChainedNeighborUpdates;
         ++this.count;
diff --git a/src/main/java/net/minecraft/world/level/redstone/InstantNeighborUpdater.java b/src/main/java/net/minecraft/world/level/redstone/InstantNeighborUpdater.java
index 2708251ebc1995e71fb0e5dca9e158a3005f8a8a..e28351b379677fec356b6efec2d882ee20e7bd48 100644
--- a/src/main/java/net/minecraft/world/level/redstone/InstantNeighborUpdater.java
+++ b/src/main/java/net/minecraft/world/level/redstone/InstantNeighborUpdater.java
@@ -15,17 +15,20 @@ public class InstantNeighborUpdater implements NeighborUpdater {
 
     @Override
     public void shapeUpdate(Direction direction, BlockState neighborState, BlockPos pos, BlockPos neighborPos, int flags, int maxUpdateDepth) {
+        if (top.leavesmc.leaves.command.NoBlockUpdateCommand.isNoBlockUpdate()) return; // Leaves - no block update
         NeighborUpdater.executeShapeUpdate(this.level, direction, neighborState, pos, neighborPos, flags, maxUpdateDepth - 1);
     }
 
     @Override
     public void neighborChanged(BlockPos pos, Block sourceBlock, BlockPos sourcePos) {
+        if (top.leavesmc.leaves.command.NoBlockUpdateCommand.isNoBlockUpdate()) return; // Leaves - no block update
         BlockState blockState = this.level.getBlockState(pos);
         this.neighborChanged(blockState, pos, sourceBlock, sourcePos, false);
     }
 
     @Override
     public void neighborChanged(BlockState state, BlockPos pos, Block sourceBlock, BlockPos sourcePos, boolean notify) {
+        if (top.leavesmc.leaves.command.NoBlockUpdateCommand.isNoBlockUpdate()) return; // Leaves - no block update
         NeighborUpdater.executeUpdate(this.level, state, pos, sourceBlock, sourcePos, notify);
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/redstone/NeighborUpdater.java b/src/main/java/net/minecraft/world/level/redstone/NeighborUpdater.java
index 19faa8f5f891c1ffbed0af8391dee8202433c447..2ef9510ee382dfcc25a213684c0acdbc352811df 100644
--- a/src/main/java/net/minecraft/world/level/redstone/NeighborUpdater.java
+++ b/src/main/java/net/minecraft/world/level/redstone/NeighborUpdater.java
@@ -66,9 +66,17 @@ public interface NeighborUpdater {
             state.neighborChanged(world, pos, sourceBlock, sourcePos, notify);
             // Spigot Start
         } catch (StackOverflowError ex) {
+            // Leaves start - fix update suppression crash
+            if (top.leavesmc.leaves.LeavesConfig.updateSuppressionCrashFix) {
+                throw new top.leavesmc.leaves.util.UpdateSuppressionException(pos, sourcePos);
+            }
             world.lastPhysicsProblem = new BlockPos(pos);
             // Spigot End
         } catch (Throwable throwable) {
+            if (top.leavesmc.leaves.LeavesConfig.updateSuppressionCrashFix) {
+                throw new top.leavesmc.leaves.util.UpdateSuppressionException(pos, sourcePos);
+            }
+            // Leaves end - fix update suppression crash
             CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception while updating neighbours");
             CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Block being updated");
 
diff --git a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
index 36af81f0957d17e170d229059c66f4eb4539dfeb..487d09aaadd9cf1b239cf9773fa71cbff6e6a77e 100644
--- a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
+++ b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
@@ -9,7 +9,6 @@ import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtIo;
 import net.minecraft.nbt.NbtUtils;
 import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.world.entity.player.Player;
 import org.slf4j.Logger;
 
@@ -18,6 +17,7 @@ import java.io.FileInputStream;
 import java.io.InputStream;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 // CraftBukkit end
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public class PlayerDataStorage {
 
@@ -119,7 +119,7 @@ public class PlayerDataStorage {
         String[] astring = this.playerDir.list();
 
         if (astring == null) {
-            astring = new String[0];
+            astring = ArrayConstants.emptyStringArray; // Leaves - reduce array allocations
         }
 
         for (int i = 0; i < astring.length; ++i) {
diff --git a/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java b/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
index a544db042c8d2ecec8d323770552c4f10ca758a6..81d18ce2ee4342b466c6623bcad7840c929eb79d 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
@@ -3,21 +3,31 @@ package net.minecraft.world.phys.shapes;
 import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
 
 public class CubePointRange extends AbstractDoubleList {
+    private final int size; // Leaves - replace parts by size in CubePointRange
     private final int parts;
+    private final double scale; // Leaves - replace division by multiplication in CubePointRange
 
     CubePointRange(int sectionCount) {
         if (sectionCount <= 0) {
             throw new IllegalArgumentException("Need at least 1 part");
         } else {
             this.parts = sectionCount;
+            this.size = sectionCount + 1;
         }
+        this.scale = 1.0D / sectionCount; // Leaves - replace division by multiplication in CubePointRange
     }
 
     public double getDouble(int i) {
-        return (double)i / (double)this.parts;
+        // Leaves start - replace division by multiplication in CubePointRange
+        if (!top.leavesmc.leaves.LeavesConfig.optimizedCubePointRange) {
+            return (double)i / (double)this.parts;
+        } else {
+            return i * this.scale;
+        }
+        // Leaves start - replace division by multiplication in CubePointRange
     }
 
     public int size() {
-        return this.parts + 1;
+        return !top.leavesmc.leaves.LeavesConfig.optimizedCubePointRange ? this.parts + 1 : size; // Leaves - replace parts by size in CubePointRange
     }
 }
diff --git a/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java b/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java
index 68e89dbd79171627046e89699057964e44c40e7d..3d260c355e374402e10baaa4f1a1d24f9c391ff5 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java
@@ -5,13 +5,28 @@ import net.minecraft.core.Direction;
 import net.minecraft.util.Mth;
 
 public final class CubeVoxelShape extends VoxelShape {
+
+    private DoubleList[] list = null; // Leaves - cache CubeVoxelShape shape array
+
     protected CubeVoxelShape(DiscreteVoxelShape voxels) {
         super(voxels);
     }
 
     @Override
     protected DoubleList getCoords(Direction.Axis axis) {
-        return new CubePointRange(this.shape.getSize(axis));
+        // Leaves start - cache CubeVoxelShape shape array
+        if (!top.leavesmc.leaves.LeavesConfig.cacheCubeVoxelShapeShapeArray) {
+            return new CubePointRange(this.shape.getSize(axis));
+        } else {
+            if (this.list == null) {
+                this.list = new DoubleList[Direction.Axis.VALUES.length];
+                for (Direction.Axis existingAxis : Direction.Axis.VALUES) {
+                    this.list[existingAxis.ordinal()] = new CubePointRange(this.shape.getSize(axis));
+                }
+            }
+            return this.list[axis.ordinal()];
+        }
+        // Leaves end - cache CubeVoxelShape shape array
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftEquipmentSlot.java b/src/main/java/org/bukkit/craftbukkit/CraftEquipmentSlot.java
index 402a238cf502003a232bb95473bd13e59e067fab..6095f5c9298558c77a788c1c9f9ef1f32825b37c 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftEquipmentSlot.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftEquipmentSlot.java
@@ -5,8 +5,10 @@ import org.bukkit.inventory.EquipmentSlot;
 
 public class CraftEquipmentSlot {
 
-    private static final net.minecraft.world.entity.EquipmentSlot[] slots = new net.minecraft.world.entity.EquipmentSlot[EquipmentSlot.values().length];
-    private static final EquipmentSlot[] enums = new EquipmentSlot[net.minecraft.world.entity.EquipmentSlot.values().length];
+    // Leaves start - reduce array allocations
+    private static final net.minecraft.world.entity.EquipmentSlot[] slots = net.minecraft.world.entity.EquipmentSlot.VALUES;
+    private static final EquipmentSlot[] enums = new EquipmentSlot[net.minecraft.world.entity.EquipmentSlot.VALUES.length];
+    // Leaves end - reduce array allocations
 
     static {
         set(EquipmentSlot.HAND, net.minecraft.world.entity.EquipmentSlot.MAINHAND);
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index a05c1bc8874ef5e380544a6a344c848e37da49c4..75c4b20c1637f4b2e1a77450d30a21b4d2db5af0 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -259,12 +259,13 @@ import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.MarkedYAMLException;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import top.leavesmc.leaves.entity.CraftBotManager;
 
 import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
 
 public final class CraftServer implements Server {
-    private final String serverName = "Paper"; // Paper
+    private final String serverName = "Leaves"; // Leaves // Paper
     private final String serverVersion;
     private final String bukkitVersion = Versioning.getBukkitVersion();
     private final Logger logger = Logger.getLogger("Minecraft");
@@ -304,6 +305,7 @@ public final class CraftServer implements Server {
     public static Exception excessiveVelEx; // Paper - Velocity warnings
     private final io.papermc.paper.logging.SysoutCatcher sysoutCatcher = new io.papermc.paper.logging.SysoutCatcher(); // Paper
     private final CraftPotionBrewer potionBrewer = new CraftPotionBrewer(); // Paper
+    private final CraftBotManager botManager = new CraftBotManager();
 
     // Paper start - Folia region threading API
     private final io.papermc.paper.threadedregions.scheduler.FallbackRegionScheduler regionizedScheduler = new io.papermc.paper.threadedregions.scheduler.FallbackRegionScheduler();
@@ -465,6 +467,8 @@ public final class CraftServer implements Server {
             MapPalette.setMapColorCache(new CraftMapColorCache(this.logger));
         }
         datapackManager = new io.papermc.paper.datapack.PaperDatapackManager(console.getPackRepository()); // Paper
+        top.leavesmc.leaves.protocol.PcaSyncProtocol.init(); // Leaves - pca
+        top.leavesmc.leaves.protocol.JadeProtocol.init(); // Leaves - Jade
     }
 
     public boolean getCommandBlockOverride(String command) {
@@ -1056,6 +1060,33 @@ public final class CraftServer implements Server {
 
         org.spigotmc.SpigotConfig.init((File) console.options.valueOf("spigot-settings")); // Spigot
         this.console.paperConfigurations.reloadConfigs(this.console);
+		top.leavesmc.leaves.LeavesConfig.init((File) console.options.valueOf("leaves-settings")); // Leaves - Server Config
+        // Leaves start - pca
+        if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.enablePcaSyncProtocolGlobal();
+        } else {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.disablePcaSyncProtocolGlobal();
+        }
+        // Leaves end - pca
+        // Leaves start - bbor
+        if (top.leavesmc.leaves.LeavesConfig.bborProtocol) {
+            top.leavesmc.leaves.protocol.BBORProtocol.initAllPlayer();
+        } else {
+            top.leavesmc.leaves.protocol.BBORProtocol.loggedOutAllPlayer();
+        }
+        // Leaves end - bbor
+        // Leaves start - Jade
+        if (top.leavesmc.leaves.LeavesConfig.jadeProtocol) {
+            top.leavesmc.leaves.protocol.JadeProtocol.enableAllPlayer();
+        }
+        // Leaves end - Jade
+        // Leaves start - appleskin
+        if (top.leavesmc.leaves.LeavesConfig.appleskinProtocol) {
+            top.leavesmc.leaves.protocol.AppleSkinProtocol.enableAllPlayer();
+        } else {
+            top.leavesmc.leaves.protocol.AppleSkinProtocol.disableAllPlayer();
+        }
+        // Leaves end - appleskin
         for (ServerLevel world : this.console.getAllLevels()) {
             // world.serverLevelData.setDifficulty(config.difficulty); // Paper - per level difficulty
             world.setSpawnSettings(world.serverLevelData.getDifficulty() != Difficulty.PEACEFUL && config.spawnMonsters, config.spawnAnimals); // Paper - per level difficulty (from MinecraftServer#setDifficulty(ServerLevel, Difficulty, boolean))
@@ -1071,6 +1102,7 @@ public final class CraftServer implements Server {
                 }
             }
             world.spigotConfig.init(); // Spigot
+			world.leavesConfig.init(); // Leaves - World Config
         }
 
         Plugin[] pluginClone = pluginManager.getPlugins().clone(); // Paper
@@ -1086,6 +1118,7 @@ public final class CraftServer implements Server {
         this.reloadData();
         org.spigotmc.SpigotConfig.registerCommands(); // Spigot
         io.papermc.paper.command.PaperCommands.registerCommands(this.console); // Paper
+        top.leavesmc.leaves.LeavesConfig.registerCommands(); // Leaves - Server Command
         this.overrideAllCommandBlockCommands = this.commandsConfiguration.getStringList("command-block-overrides").contains("*");
         this.ignoreVanillaPermissions = this.commandsConfiguration.getBoolean("ignore-vanilla-permissions");
 
@@ -2863,6 +2896,14 @@ public final class CraftServer implements Server {
         {
             return CraftServer.this.console.paperConfigurations.createLegacyObject(CraftServer.this.console);
         }
+		
+		// Leaves start - add config to timings report
+		@Override
+		public YamlConfiguration getLeavesConfig()
+		{
+			return top.leavesmc.leaves.LeavesConfig.config;
+		}
+		/// Leaves end - add config to timings report
 
         @Override
         public void restart() {
@@ -3077,4 +3118,11 @@ public final class CraftServer implements Server {
     }
 
     // Paper end
+
+    // Leaves start - Bot API
+    @Override
+    public CraftBotManager getBotManager() {
+        return botManager;
+    }
+    // Leaves end - Bot API
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index daed278d1bcf84ee42749f24e311b22b70015d79..c20debb13d8496ad7c0ef1eaf5eae1c42c09eb51 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -165,6 +165,14 @@ public class Main {
                         .ofType(File.class)
                         .defaultsTo(new File("paper.yml"))
                         .describedAs("Yml file");
+						
+				// Leaves start - Server Config
+				acceptsAll(asList("leaves", "leaves-settings"), "File for leaves settings")
+                        .withRequiredArg()
+                        .ofType(File.class)
+                        .defaultsTo(new File("leaves.yml"))
+                        .describedAs("Yml file");
+				// Leaves end - Server Config
 
                 acceptsAll(asList("add-plugin", "add-extra-plugin-jar"), "Specify paths to extra plugin jars to be loaded in addition to those in the plugins folder. This argument can be specified multiple times, once for each extra plugin jar path.")
                         .withRequiredArg()
@@ -292,7 +300,7 @@ public class Main {
                     if (buildDate.before(deadline.getTime())) {
                         // Paper start - This is some stupid bullshit
                         System.err.println("*** Warning, you've not updated in a while! ***");
-                        System.err.println("*** Please download a new build as per instructions from https://papermc.io/downloads/paper ***"); // Paper
+                        System.err.println("*** Please download a new build as per instructions from https://leavesmc.top/downloads/leaves ***"); //Paper // Leaves
                         //System.err.println("*** Server will start in 20 seconds ***");
                         //Thread.sleep(TimeUnit.SECONDS.toMillis(20));
                         // Paper End
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index fc0dc8e607cc24020106ea1af92b4421a5f9393d..81670f76c4d7ccec6f9e95465687c83b37c544bd 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -191,6 +191,8 @@ import org.bukkit.plugin.Plugin;
 import org.bukkit.util.BoundingBox;
 import org.bukkit.util.NumberConversions;
 import org.bukkit.util.Vector;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.entity.CraftBot;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
 
@@ -226,7 +228,12 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         if (entity instanceof LivingEntity) {
             // Players
             if (entity instanceof net.minecraft.world.entity.player.Player) {
-                if (entity instanceof ServerPlayer) { return new CraftPlayer(server, (ServerPlayer) entity); }
+                // Leaves start - add CraftBot
+                if (entity instanceof ServerPlayer) {
+                    if (entity instanceof ServerBot) { return new CraftBot(server, (ServerBot) entity); }
+                    else { return new CraftPlayer(server, (ServerPlayer) entity); }
+                }
+                // Leaves end - add CraftBot
                 else { return new CraftHumanEntity(server, (net.minecraft.world.entity.player.Player) entity); }
             }
             // Water Animals
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftEntityEquipment.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftEntityEquipment.java
index 6827979a5b270ced53b46ecb9eff548727dadb81..1b84078152d0585ec51288e585754be176f2d7c2 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftEntityEquipment.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftEntityEquipment.java
@@ -165,7 +165,7 @@ public class CraftEntityEquipment implements EntityEquipment {
 
     @Override
     public void clear() {
-        for (net.minecraft.world.entity.EquipmentSlot slot : net.minecraft.world.entity.EquipmentSlot.values()) {
+        for (net.minecraft.world.entity.EquipmentSlot slot : net.minecraft.world.entity.EquipmentSlot.VALUES) { // Leaves - reduce array allocations
             this.setEquipment(slot, null, false);
         }
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapelessRecipe.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapelessRecipe.java
index f7ea77dd82d978ad307f99c743efacfb34478b3d..96be7a7b030b2f82ac91f0c5c8e66f282fd4d6bc 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapelessRecipe.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftShapelessRecipe.java
@@ -44,6 +44,6 @@ public class CraftShapelessRecipe extends ShapelessRecipe implements CraftRecipe
             data.set(i, toNMS(ingred.get(i), true));
         }
 
-        MinecraftServer.getServer().getRecipeManager().addRecipe(new net.minecraft.world.item.crafting.ShapelessRecipe(CraftNamespacedKey.toMinecraft(this.getKey()), this.getGroup(), CraftRecipe.getCategory(this.getCategory()), CraftItemStack.asNMSCopy(this.getResult()), data));
+        MinecraftServer.getServer().getRecipeManager().addRecipe(new net.minecraft.world.item.crafting.ShapelessRecipe(CraftNamespacedKey.toMinecraft(this.getKey()), this.getGroup(), CraftRecipe.getCategory(this.getCategory()), CraftItemStack.asNMSCopy(this.getResult()), data, true)); // Leaves - is bukkit recipe
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
index 774556a62eb240da42e84db4502e2ed43495be17..ca166161ef919c559de9cc02bdf435cbfcc972df 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
@@ -11,7 +11,7 @@ public final class Versioning {
     public static String getBukkitVersion() {
         String result = "Unknown-Version";
 
-        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/io.papermc.paper/paper-api/pom.properties");
+        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/top.leavesmc.leaves/leaves-api/pom.properties"); // Leaves
         Properties properties = new Properties();
 
         if (stream != null) {
diff --git a/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java b/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java
index bbacf58740f3faea0d555e4012fe2b15fb46ed50..97afd508898096e5c2e6401cf02b0be587f365d9 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java
@@ -6,6 +6,7 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
+import top.leavesmc.leaves.util.ArrayConstants;
 
 public final class WeakCollection<T> implements Collection<T> {
     static final Object NO_VALUE = new Object();
@@ -164,7 +165,7 @@ public final class WeakCollection<T> implements Collection<T> {
 
     @Override
     public Object[] toArray() {
-        return this.toArray(new Object[0]);
+        return this.toArray(ArrayConstants.emptyObjectArray); // Leaves - reduce array allocations
     }
 
     @Override
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index eda7f0bb42f7269676d5d2193e1155912ede9920..0f7064f3fa0c0d1842c92535cf6ee30f153e5e6e 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -292,7 +292,7 @@ public class ActivationRange
         if ( entity instanceof LivingEntity )
         {
             LivingEntity living = (LivingEntity) entity;
-            if ( living.onClimbable() || living.jumping || living.hurtTime > 0 || living.activeEffects.size() > 0 ) // Paper
+            if ( living.onClimableCached() || living.jumping || living.hurtTime > 0 || living.activeEffects.size() > 0 ) // Paper // Leaves - use cached
             {
                 return 1; // Paper
             }
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index 98fba0288be9ed2cb18ffba5cf81148157dd4fcf..a803b08d7d1995c263d05eda23dfe4552acae08d 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -155,14 +155,14 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
                 if (isLongTimeout) {
                 // Paper end
                 log.log( Level.SEVERE, "------------------------------" );
-                log.log( Level.SEVERE, "The server has stopped responding! This is (probably) not a Paper bug." ); // Paper
+                log.log( Level.SEVERE, "The server has stopped responding! This is (probably) not a Leaves bug." ); // Paper // Leaves
                 log.log( Level.SEVERE, "If you see a plugin in the Server thread dump below, then please report it to that author" );
                 log.log( Level.SEVERE, "\t *Especially* if it looks like HTTP or MySQL operations are occurring" );
                 log.log( Level.SEVERE, "If you see a world save or edit, then it means you did far more than your server can handle at once" );
                 log.log( Level.SEVERE, "\t If this is the case, consider increasing timeout-time in spigot.yml but note that this will replace the crash with LARGE lag spikes" );
-                log.log( Level.SEVERE, "If you are unsure or still think this is a Paper bug, please report this to https://github.com/PaperMC/Paper/issues" );
+                log.log( Level.SEVERE, "If you are unsure or still think this is a Leaves bug, please report this to https://github.com/LeavesMC/Leaves/issues" ); // Leaves
                 log.log( Level.SEVERE, "Be sure to include ALL relevant console errors and Minecraft crash reports" );
-                log.log( Level.SEVERE, "Paper version: " + Bukkit.getServer().getVersion() );
+                log.log( Level.SEVERE, "Leaves version: " + Bukkit.getServer().getVersion() ); // Leaves
                 //
                 if ( net.minecraft.world.level.Level.lastPhysicsProblem != null )
                 {
@@ -185,12 +185,12 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
                 // Paper end
                 } else
                 {
-                    log.log(Level.SEVERE, "--- DO NOT REPORT THIS TO PAPER - THIS IS NOT A BUG OR A CRASH  - " + Bukkit.getServer().getVersion() + " ---");
+                    log.log(Level.SEVERE, "--- DO NOT REPORT THIS TO LEAVES - THIS IS NOT A BUG OR A CRASH  - " + Bukkit.getServer().getVersion() + " ---"); // Leaves
                     log.log(Level.SEVERE, "The server has not responded for " + (currentTime - lastTick) / 1000 + " seconds! Creating thread dump");
                 }
                 // Paper end - Different message for short timeout
                 log.log( Level.SEVERE, "------------------------------" );
-                log.log( Level.SEVERE, "Server thread dump (Look for plugins here before reporting to Paper!):" ); // Paper
+                log.log( Level.SEVERE, "Server thread dump (Look for plugins here before reporting to Leaves!):" ); // Paper // Leaevs
                 io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.dumpAllChunkLoadInfo(isLongTimeout); // Paper // Paper - rewrite chunk system
                 this.dumpTickingInfo(); // Paper - log detailed tick information
                 WatchdogThread.dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( MinecraftServer.getServer().serverThread.getId(), Integer.MAX_VALUE ), log );
@@ -206,7 +206,7 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
                     WatchdogThread.dumpThread( thread, log );
                 }
                 } else {
-                    log.log(Level.SEVERE, "--- DO NOT REPORT THIS TO PAPER - THIS IS NOT A BUG OR A CRASH ---");
+                    log.log(Level.SEVERE, "--- DO NOT REPORT THIS TO LEAVES - THIS IS NOT A BUG OR A CRASH ---"); // Leaves
                 }
 
                 log.log( Level.SEVERE, "------------------------------" );
diff --git a/src/main/java/top/leavesmc/leaves/LeavesConfig.java b/src/main/java/top/leavesmc/leaves/LeavesConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..60eaf8ec26b21b23c447bb722f0a58b7269f2027
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/LeavesConfig.java
@@ -0,0 +1,996 @@
+package top.leavesmc.leaves;
+
+import com.destroystokyo.paper.util.SneakyThrow;
+import com.google.common.base.Throwables;
+import io.papermc.paper.configuration.GlobalConfiguration;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.material.PushReaction;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.file.YamlConfiguration;
+import top.leavesmc.leaves.command.LeavesCommand;
+import top.leavesmc.leaves.bot.BotCommand;
+import top.leavesmc.leaves.bot.agent.Actions;
+import top.leavesmc.leaves.command.NoBlockUpdateCommand;
+import top.leavesmc.leaves.profile.LeavesMinecraftSessionService;
+import top.leavesmc.leaves.protocol.syncmatica.SyncmaticaProtocol;
+import top.leavesmc.leaves.util.MathUtils;
+import top.leavesmc.leaves.protocol.CarpetServerProtocol.CarpetRule;
+import top.leavesmc.leaves.protocol.CarpetServerProtocol.CarpetRules;
+
+import java.io.File;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.Random;
+
+// Powered by Tuinity(https://github.com/Tuinity/Tuinity)
+
+public final class LeavesConfig {
+
+    public static final String CONFIG_HEADER = "Configuration file for Leaves.";
+    public static final int CURRENT_CONFIG_VERSION = 3;
+
+    private static final Object[] EMPTY = new Object[0];
+
+    private static File configFile;
+    public static YamlConfiguration config;
+    private static int configVersion;
+    public static boolean createWorldSections = true;
+    static Map<String, Command> commands;
+
+    public static void init(final File file) {
+        LeavesConfig.configFile = file;
+        config = new YamlConfiguration();
+        config.options().header(CONFIG_HEADER);
+        config.options().copyDefaults(true);
+
+        if (!file.exists()) {
+            try {
+                file.createNewFile();
+            } catch (final Exception ex) {
+                Bukkit.getLogger().log(Level.SEVERE, "Failure to create leaves config", ex);
+            }
+        } else {
+            try {
+                config.load(file);
+            } catch (final Exception ex) {
+                Bukkit.getLogger().log(Level.SEVERE, "Failure to load leaves config", ex);
+                SneakyThrow.sneaky(ex); /* Rethrow, this is critical */
+                throw new RuntimeException(ex); // unreachable
+            }
+        }
+
+        if (config.contains("config-version-please-do-not-modify-me")) {
+            LeavesConfig.set("config-version-please-do-not-modify-me", null);
+        }
+        LeavesConfig.configVersion = LeavesConfig.getInt("config-version", CURRENT_CONFIG_VERSION);
+        LeavesConfig.set("config-version", CURRENT_CONFIG_VERSION);
+
+        updateConfigVersion(config);
+
+        LeavesConfig.load(config);
+        registerCarpetRules();
+
+	    commands = new HashMap<>();
+        commands.put("leaves", new LeavesCommand("leaves"));
+
+        if (top.leavesmc.leaves.LeavesConfig.fakeplayerSupport) {
+            commands.put("bot", new BotCommand("bot"));
+            Actions.registerAll();
+        }
+
+        if (LeavesConfig.noBlockUpdateCommand) {
+            commands.put("blockupdate", new NoBlockUpdateCommand("blockupdate"));
+        }
+    }
+
+    public static void load(final YamlConfiguration config) {
+        for (Method method : LeavesConfig.class.getDeclaredMethods()) {
+            if (Modifier.isPrivate(method.getModifiers())) {
+                if (method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE) {
+                    try {
+                        method.setAccessible(true);
+                        method.invoke(null);
+                    } catch (InvocationTargetException ex) {
+                        throw Throwables.propagate(ex.getCause());
+                    } catch (Exception ex) {
+                        Bukkit.getLogger().log(Level.SEVERE, "Error invoking " + method, ex);
+                    }
+                }
+            }
+        }
+
+        /* We re-save to add new options */
+        try {
+            config.save(LeavesConfig.configFile);
+        } catch (final Exception ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Unable to save leaves config", ex);
+        }
+    }
+
+    private static void updateConfigVersion(final YamlConfiguration config) {
+        if (configVersion < CURRENT_CONFIG_VERSION) {
+            switch (configVersion) {
+                case 1 -> {
+                    snowballAndEggCanKnockback = config.getBoolean("settings.snowball-and-egg-can-knockback-player", snowballAndEggCanKnockback);
+                    fakeplayerSupport = config.getBoolean("settings.fakeplayer.enable", fakeplayerSupport);
+                    unableFakeplayerNames = (List<String>) config.getList("settings.fakeplayer.unable-fakeplayer-names", unableFakeplayerNames);
+                    shearsInDispenserCanZeroAmount = config.getBoolean("settings.shears-in-dispenser-can-zero-amount", shearsInDispenserCanZeroAmount);
+                    redstoneShearsWrench = config.getBoolean("settings.redstone-shears-wrench", redstoneShearsWrench);
+                    buddingAmethystCanPushByPiston = config.getBoolean("settings.budding-amethyst-can-push-by-piston", buddingAmethystCanPushByPiston);
+                    spectatorDontGetAdvancement = config.getBoolean("settings.spectator-dont-get-advancement", spectatorDontGetAdvancement);
+                    stickChangeArmorStandArmStatus = config.getBoolean("settings.stick-change-armorstand-arm-status", stickChangeArmorStandArmStatus);
+                    noChatSign = config.getBoolean("settings.no-chat-sign", noChatSign);
+
+                    config.set("settings.snowball-and-egg-can-knockback-player", null);
+                    config.set("settings.player-can-edit-sign", null);
+                    config.set("settings.fakeplayer", null);
+                    config.set("settings.shears-in-dispenser-can-zero-amount", null);
+                    config.set("settings.redstone-shears-wrench", null);
+                    config.set("settings.budding-amethyst-can-push-by-piston", null);
+                    config.set("settings.spectator-dont-get-advancement", null);
+                    config.set("settings.stick-change-armorstand-arm-status", null);
+                    config.set("settings.no-chat-sign", null);
+                }
+
+                case 2 -> {
+                    config.set("settings.modify.player-can-edit-sign", null);
+                    config.set("settings.performance.skip-clone-loot-parameters", null);
+                }
+            }
+        }
+    }
+
+    static void set(final String path, final Object value) {
+        LeavesConfig.config.set(path, value);
+    }
+
+    public static void registerCommands() {
+        for (Map.Entry<String, Command> entry : commands.entrySet()) {
+            MinecraftServer.getServer().server.getCommandMap().register(entry.getKey(), "Leaves", entry.getValue());
+        }
+    }
+
+    static boolean getBoolean(final String path, final boolean dfl) {
+        LeavesConfig.config.addDefault(path, Boolean.valueOf(dfl));
+        return LeavesConfig.config.getBoolean(path, dfl);
+    }
+
+    static int getInt(final String path, final int dfl) {
+        LeavesConfig.config.addDefault(path, Integer.valueOf(dfl));
+        return LeavesConfig.config.getInt(path, dfl);
+    }
+
+    static long getLong(final String path, final long dfl) {
+        LeavesConfig.config.addDefault(path, Long.valueOf(dfl));
+        return LeavesConfig.config.getLong(path, dfl);
+    }
+
+    static double getDouble(final String path, final double dfl) {
+        LeavesConfig.config.addDefault(path, Double.valueOf(dfl));
+        return LeavesConfig.config.getDouble(path, dfl);
+    }
+
+    static String getString(final String path, final String dfl) {
+        LeavesConfig.config.addDefault(path, dfl);
+        return LeavesConfig.config.getString(path, dfl);
+    }
+
+    static <T> List<T> getList(final String path, final List<T> def) {
+        LeavesConfig.config.addDefault(path, def);
+        return (List<T>) LeavesConfig.config.getList(path, config.getList(path));
+    }
+
+    public static boolean snowballAndEggCanKnockback = true;
+    private static void snowballAndEggCanKnockback() {
+        snowballAndEggCanKnockback = getBoolean("settings.modify.snowball-and-egg-can-knockback-player", snowballAndEggCanKnockback);
+    }
+
+    public static boolean fakeplayerSupport = true;
+    public static List<String> unableFakeplayerNames = List.of("player-name");
+    public static int fakeplayerLimit = 10;
+    public static String fakeplayerPrefix = "";
+    public static String fakeplayerSuffix = "";
+    public static boolean alwaysSendFakeplayerData = true;
+    public static boolean fakeplayerResident = false;
+    public static boolean openFakeplayerInventory = false;
+    public static boolean fakeplayerSkipSleep = false;
+    private static void fakeplayer() {
+        fakeplayerSupport = getBoolean("settings.modify.fakeplayer.enable", fakeplayerSupport);
+        unableFakeplayerNames = getList("settings.modify.fakeplayer.unable-fakeplayer-names", unableFakeplayerNames);
+        fakeplayerLimit = getInt("settings.modify.fakeplayer.limit", fakeplayerLimit);
+        fakeplayerPrefix = getString("settings.modify.fakeplayer.prefix", fakeplayerPrefix);
+        fakeplayerSuffix = getString("settings.modify.fakeplayer.suffix", fakeplayerSuffix);
+        alwaysSendFakeplayerData = getBoolean("settings.modify.fakeplayer.always-send-data", alwaysSendFakeplayerData);
+        fakeplayerResident = getBoolean("settings.modify.fakeplayer.resident-fakeplayer", fakeplayerResident);
+        openFakeplayerInventory = getBoolean("settings.modify.fakeplayer.open-fakeplayer-inventory", openFakeplayerInventory);
+        fakeplayerSkipSleep = getBoolean("settings.modify.fakeplayer.skip-sleep-check", fakeplayerSkipSleep);
+    }
+
+    public static boolean shearsInDispenserCanZeroAmount = false;
+    private static void shearsInDispenserCanZeroAmount() {
+        shearsInDispenserCanZeroAmount = getBoolean("settings.modify.shears-in-dispenser-can-zero-amount", shearsInDispenserCanZeroAmount);
+    }
+
+    public static boolean redstoneShearsWrench = true;
+    private static void redstoneShearsWrench() {
+        redstoneShearsWrench = getBoolean("settings.modify.redstone-shears-wrench", redstoneShearsWrench);
+    }
+
+    public static boolean buddingAmethystCanPushByPiston = false;
+    private static void buddingAmethystCanPushByPiston() {
+        buddingAmethystCanPushByPiston = getBoolean("settings.modify.budding-amethyst-can-push-by-piston", buddingAmethystCanPushByPiston);
+    }
+
+    public static boolean spectatorDontGetAdvancement = false;
+    private static void spectatorDontGetAdvancement() {
+        spectatorDontGetAdvancement = getBoolean("settings.modify.spectator-dont-get-advancement", spectatorDontGetAdvancement);
+    }
+
+    public static boolean stickChangeArmorStandArmStatus = true;
+    private static void stickChangeArmorStandHasArm() {
+        stickChangeArmorStandArmStatus = getBoolean("settings.modify.stick-change-armorstand-arm-status", stickChangeArmorStandArmStatus);
+    }
+
+    public static boolean noChatSign = true;
+    private static void noChatSign() {
+        if (LeavesConfig.config.contains("settings.modify.no-chat-sign")) {
+            noChatSign = LeavesConfig.config.getBoolean("settings.modify.no-chat-sign");
+            LeavesConfig.config.set("settings.modify.no-chat-sign", null);
+        }
+        noChatSign = getBoolean("settings.misc.no-chat-sign", noChatSign);
+    }
+
+    public static boolean asyncMobSpawning = false; // void
+    private static boolean asyncMobSpawningLock = false;
+    private static void asyncMobSpawning() {
+        if (!asyncMobSpawningLock) {
+            asyncMobSpawning = getBoolean("settings.performance.async-mob-spawning", asyncMobSpawning);
+            asyncMobSpawningLock = true;
+        }
+
+        if (asyncMobSpawning) {
+            asyncMobSpawning = false;
+            LeavesLogger.LOGGER.severe("Async MobSpawning is updating, it can't work");
+        }
+    }
+
+    public static boolean dontSendUselessEntityPackets = true;
+    private static void dontSendUselessEntityPackets() {
+        dontSendUselessEntityPackets = getBoolean("settings.performance.dont-send-useless-entity-packets", dontSendUselessEntityPackets);
+    }
+
+    public static boolean asyncEntityTracker = false; // void
+    private static boolean asyncEntityTrackerLock = false;
+    private static void asyncEntityTracker() {
+        if (!asyncEntityTrackerLock) {
+            asyncEntityTracker = getBoolean("settings.performance.async-entity-tracker", asyncEntityTracker);
+            asyncEntityTrackerLock = true;
+        }
+
+        if (asyncEntityTracker) {
+            asyncEntityTracker = false;
+            LeavesLogger.LOGGER.severe("Async EntityTracker is updating, it can't work");
+        }
+    }
+
+    public static boolean fixPaper6045 = true;
+    private static void fixPaper6045() {
+        fixPaper6045 = getBoolean("settings.performance.fix.fix-paper-6045", fixPaper6045);
+    }
+
+    public static boolean optimizeEntityCoordinateKey = true;
+    private static void optimizeEntityCoordinateKey() {
+        optimizeEntityCoordinateKey = getBoolean("settings.performance.optimize-entity-coordinate-key", optimizeEntityCoordinateKey);
+    }
+
+    public static boolean enableSuffocationOptimization = true;
+    private static void enableSuffocationOptimization() {
+        enableSuffocationOptimization = getBoolean("settings.performance.enable-suffocation-optimization", enableSuffocationOptimization);
+    }
+
+    public static boolean entityStripRaytracing = true;
+    private static void entityStripRaytracing() {
+        entityStripRaytracing = getBoolean("settings.performance.strip-raytracing-for-entity", entityStripRaytracing);
+    }
+
+    public static boolean checkSpookySeasonOnceAnHour = true;
+    private static void checkSpookySeasonOnceAnHour() {
+        checkSpookySeasonOnceAnHour = getBoolean("settings.performance.check-spooky-season-once-an-hour", checkSpookySeasonOnceAnHour);
+    }
+
+    public static boolean optimizeChunkTicking = true;
+    private static boolean optimizeChunkTickingLock = false;
+    private static void optimizeChunkTicking() {
+        if (!optimizeChunkTickingLock) {
+            optimizeChunkTicking = getBoolean("settings.performance.optimize-chunk-ticking", optimizeChunkTicking);
+            optimizeChunkTickingLock = true;
+        }
+    }
+
+    public static boolean skipPOIFindingInVehicle = true;
+    private static void skipPOIFindingInVehicle() {
+        skipPOIFindingInVehicle = getBoolean("settings.performance.skip-poi-find-in-vehicle", skipPOIFindingInVehicle);
+    }
+
+    public static boolean entityTargetFindingOptimization = true;
+    private static void entityTargetFindingOptimization() {
+        entityTargetFindingOptimization = getBoolean("settings.performance.entity-target-find-optimization", entityTargetFindingOptimization);
+    }
+
+    public static boolean useMoreThreadUnsafeRandom = true;
+    private static void useMoreThreadUnsafeRandom() {
+        useMoreThreadUnsafeRandom = getBoolean("settings.performance.use-more-thread-unsafe-random", useMoreThreadUnsafeRandom);
+    }
+
+    public static boolean disableMethodProfiler = true;
+    private static void disableMethodProfiler() {
+        disableMethodProfiler = getBoolean("settings.misc.disable-method-profiler", disableMethodProfiler);
+    }
+
+    public static boolean throttleInactiveGoalSelectorTick = false;
+    private static void throttleInactiveGoalSelectorTick() {
+        throttleInactiveGoalSelectorTick = getBoolean("settings.performance.inactive-goal-selector-disable", throttleInactiveGoalSelectorTick);
+    }
+
+    public static boolean reduceEntityAllocations = true;
+    private static void reduceEntityAllocations() {
+        reduceEntityAllocations = getBoolean("settings.performance.reduce-entity-allocations", reduceEntityAllocations);
+    }
+
+    public static boolean removeTickGuardLambda = true;
+    private static void removeTickGuardLambda() {
+        removeTickGuardLambda = getBoolean("settings.performance.remove.tick-guard-lambda", removeTickGuardLambda);
+    }
+
+    public static boolean removeInventoryContainsIterators = true;
+    private static void removeInventoryContainsIterators() {
+        removeInventoryContainsIterators = getBoolean("settings.performance.remove.inventory-contains-iterators", removeInventoryContainsIterators);
+    }
+
+    public static boolean removeGetNearPlayerStreams = true;
+    private static void removeGetNearPlayerStreams() {
+        removeGetNearPlayerStreams = getBoolean("settings.performance.remove.get-nearby-players-streams", removeGetNearPlayerStreams);
+    }
+
+    public static boolean removeRangeCheckStreams = true;
+    private static void removeRangeCheckStreams() {
+        removeRangeCheckStreams = getBoolean("settings.performance.remove.range-check-streams-and-iterators", removeRangeCheckStreams);
+    }
+
+    // only config now
+    public static boolean asyncPathfinding = false;
+    private static boolean asyncPathfindingLock = false;
+    private static void asyncPathfinding() { // void
+        if (!asyncPathfindingLock) {
+            asyncPathfinding = getBoolean("settings.performance.async-pathfinding", asyncPathfinding);
+            asyncPathfindingLock = true;
+        }
+
+        if (asyncPathfinding) {
+            asyncPathfinding = false;
+            LeavesLogger.LOGGER.severe("Async Pathfinding is updating, it can't work");
+        }
+    }
+
+    public static boolean cacheClimbCheck = true;
+    private static void cacheClimbCheck() {
+        cacheClimbCheck = getBoolean("settings.performance.cache-climb-check", cacheClimbCheck);
+    }
+
+    public static boolean biomeTemperaturesUseAgingCache = true;
+    private static boolean biomeTemperaturesUseAgingCacheLock = false;
+    private static void biomeTemperaturesUseAgingCache() {
+        if (!biomeTemperaturesUseAgingCacheLock) {
+            biomeTemperaturesUseAgingCache = getBoolean("settings.performance.biome-temperatures-use-aging-cache", biomeTemperaturesUseAgingCache);
+            biomeTemperaturesUseAgingCacheLock = true;
+        }
+    }
+
+    public static boolean reduceEntityFluidLookup = true;
+    private static void reduceEntityFluidLookup() {
+        reduceEntityFluidLookup = getBoolean("settings.performance.reduce-entity-fluid-lookup", reduceEntityFluidLookup);
+    }
+
+    public static boolean reduceChuckLoadAndLookup = true;
+    private static void reduceChuckLoadAndLookup() {
+        reduceChuckLoadAndLookup = getBoolean("settings.performance.reduce-chuck-load-and-lookup", reduceChuckLoadAndLookup);
+    }
+
+    public static boolean simplerVanillaShapelessRecipes = true;
+    private static void simplerVanillaShapelessRecipes() {
+        simplerVanillaShapelessRecipes = getBoolean("settings.performance.simpler-vanilla-shapeless-recipes", simplerVanillaShapelessRecipes);
+    }
+
+    public static boolean pcaSyncProtocol = false;
+    private static void pcaSyncProtocol() {
+        pcaSyncProtocol = getBoolean("settings.protocol.pca-sync-protocol", pcaSyncProtocol);
+    }
+
+    public static String pcaSyncPlayerEntity = "OPS";
+    private static final List<String> pcaSyncPlayerEntityList = List.of("NOBODY", "BOT", "OPS", "OPS_AND_SELF", "EVERYONE");
+    private static void pcaSyncPlayerEntity() {
+        pcaSyncPlayerEntity = getString("settings.protocol.pca-sync-player-entity", pcaSyncPlayerEntity);
+        if (!pcaSyncPlayerEntityList.contains(pcaSyncPlayerEntity)) {
+            pcaSyncPlayerEntity = "OPS";
+            LeavesLogger.LOGGER.severe("pca-sync-player-entity value error, reset to OPS");
+        }
+    }
+
+    public static boolean bborProtocol = false;
+    private static void bborProtocol() {
+        bborProtocol = getBoolean("settings.protocol.bbor-protocol", bborProtocol);
+    }
+
+    public static boolean instantBlockUpdaterReintroduced = false;
+    private static boolean instantBlockUpdaterReintroducedLock = false;
+    private static void instantBlockUpdaterReintroduced() {
+        if (!instantBlockUpdaterReintroducedLock) {
+            instantBlockUpdaterReintroduced = getBoolean("settings.modify.instant-block-updater-reintroduced", instantBlockUpdaterReintroduced);
+            instantBlockUpdaterReintroducedLock = true;
+        }
+    }
+
+    public static boolean flattenTriangularDistribution = false;
+    private static void flattenTriangularDistribution() {
+        flattenTriangularDistribution = getBoolean("settings.modify.flatten-triangular-distribution", flattenTriangularDistribution);
+    }
+
+    public static boolean jadeProtocol = false;
+    private static void jadeProtocol() {
+        jadeProtocol = getBoolean("settings.protocol.jade-protocol", jadeProtocol);
+    }
+
+    public static boolean carpetAlternativeBlockPlacement = false;
+    private static void carpetAlternativeBlockPlacement() {
+        carpetAlternativeBlockPlacement = getBoolean("settings.protocol.carpet-alternative-block-placement", carpetAlternativeBlockPlacement);
+    }
+
+    public static boolean playerOperationLimiter = false;
+    private static void playerOperationLimiter() {
+        playerOperationLimiter = getBoolean("settings.modify.player-operation-limiter", playerOperationLimiter);
+    }
+
+    public static double renewableElytra = -1.0;
+    private static void renewableElytra() {
+        renewableElytra = getDouble("settings.modify.renewable-elytra", renewableElytra);
+    }
+
+    public static int shulkerBoxStackSize = 1;
+    private static String stackableShulkerBoxes = "false";
+    private static void stackableShulkerBoxes() {
+        stackableShulkerBoxes = getString("settings.modify.stackable-shulker-boxes", stackableShulkerBoxes);
+        stackableShulkerBoxes = MathUtils.isNumeric(stackableShulkerBoxes) ? stackableShulkerBoxes : stackableShulkerBoxes.equals("true") ? "2" : "1";
+        shulkerBoxStackSize = Integer.parseInt(stackableShulkerBoxes);
+    }
+
+    public static boolean improveFluidDirectionCaching = true;
+    private static boolean improveFluidDirectionCachingLock = false;
+    private static void improveFluidDirectionCaching() {
+        if (!improveFluidDirectionCachingLock) {
+            improveFluidDirectionCaching = getBoolean("settings.performance.improve-fluid-direction-caching", improveFluidDirectionCaching);
+            improveFluidDirectionCachingLock = true;
+        }
+    }
+
+    public static boolean mcTechnicalMode = true;
+    private static void mcTechnicalMode() {
+        mcTechnicalMode = getBoolean("settings.modify.mc-technical-survival-mode", mcTechnicalMode); // TODO better name?
+        doMcTechnicalMode();
+    }
+
+    public static void doMcTechnicalMode() {
+        if (mcTechnicalMode) {
+            GlobalConfiguration.get().unsupportedSettings.allowPistonDuplication = true;
+            GlobalConfiguration.get().unsupportedSettings.allowHeadlessPistons = true;
+            GlobalConfiguration.get().unsupportedSettings.allowPermanentBlockBreakExploits = true;
+            GlobalConfiguration.get().packetLimiter.allPackets = new GlobalConfiguration.PacketLimiter.PacketLimit(GlobalConfiguration.get().packetLimiter.allPackets.interval(),
+                5000.0, GlobalConfiguration.get().packetLimiter.allPackets.action());
+            GlobalConfiguration.get().packetLimiter.overrides = Map.of();
+            GlobalConfiguration.get().unsupportedSettings.allowGrindstoneOverstacking = true;
+        }
+    }
+
+    public static boolean netherPortalFix = false;
+    private static void netherPortalFix() {
+        netherPortalFix = getBoolean("settings.modify.return-nether-portal-fix", netherPortalFix);
+    }
+
+    public static boolean appleskinProtocol = false;
+    private static void appleskinProtocol() {
+        appleskinProtocol = getBoolean("settings.protocol.appleskin-protocol", appleskinProtocol);
+    }
+
+    public static boolean xaeroMapProtocol = false;
+    public static int xaeroMapServerID = new Random().nextInt();
+    private static void xaeroMapProtocol() {
+        xaeroMapProtocol = getBoolean("settings.protocol.xaero-map-protocol", xaeroMapProtocol);
+        xaeroMapServerID = getInt("settings.protocol.xaero-map-server-id", xaeroMapServerID);
+    }
+
+    public static boolean extraYggdrasilService = false;
+    public static boolean extraYggdrasilLoginProtect = false;
+    public static List<String> extraYggdrasilServiceList = List.of("https://url.with.authlib-injector-yggdrasil");
+    private static void extraYggdrasilService() {
+        extraYggdrasilService = getBoolean("settings.misc.extra-yggdrasil-service.enable", extraYggdrasilService);
+        extraYggdrasilLoginProtect = getBoolean("settings.misc.extra-yggdrasil-service.login-protect", extraYggdrasilLoginProtect);
+        extraYggdrasilServiceList = getList("settings.misc.extra-yggdrasil-service.urls", extraYggdrasilServiceList);
+        if (extraYggdrasilService) {
+            LeavesLogger.LOGGER.warning("extra-yggdrasil-service is an unofficial support. Enabling it may cause data security problems!");
+            GlobalConfiguration.get().unsupportedSettings.performUsernameValidation = true; // always check user name
+            LeavesMinecraftSessionService.initExtraYggdrasilList();
+        }
+    }
+
+    public static boolean useVanillaRandom = false;
+    private static boolean useVanillaRandomLock = false;
+    private static void useVanillaRandom() {
+        if (!useVanillaRandomLock) {
+            useVanillaRandom = getBoolean("settings.modify.use-vanilla-random", useVanillaRandom);
+            useVanillaRandomLock = true;
+        }
+    }
+
+    public static boolean updateSuppressionCrashFix = true;
+    private static void updateSuppressionCrashFix() {
+        updateSuppressionCrashFix = getBoolean("settings.modify.fix-update-suppression-crash", updateSuppressionCrashFix);
+    }
+
+    public static boolean bedrockBreakList = false;
+    private static boolean bedrockBreakListLock = false;
+    private static void bedrockBreakList() {
+        if (!bedrockBreakListLock) {
+            bedrockBreakList = getBoolean("settings.modify.bedrock-break-list", bedrockBreakList);
+            bedrockBreakListLock = true;
+        }
+    }
+
+    public static boolean syncmaticaProtocol = false;
+    public static boolean syncmaticaQuota = false;
+    public static int syncmaticaQuotaLimit = 40000000;
+    private static void syncmaticaProtocol() {
+        syncmaticaProtocol = getBoolean("settings.protocol.syncmatica.enable", syncmaticaProtocol);
+        syncmaticaQuota = getBoolean("settings.protocol.syncmatica.quota", syncmaticaQuota);
+        syncmaticaQuotaLimit = getInt("settings.protocol.syncmatica.quota-limit", syncmaticaQuotaLimit);
+        if (syncmaticaProtocol) {
+            SyncmaticaProtocol.init();
+        }
+    }
+
+    public static boolean disableDistanceCheckForUseItem = false;
+    private static void disableDistanceCheckForUseItem() {
+        disableDistanceCheckForUseItem = getBoolean("settings.modify.disable-distance-check-for-use-item", disableDistanceCheckForUseItem);
+        if (carpetAlternativeBlockPlacement) {
+            disableDistanceCheckForUseItem = true;
+        }
+    }
+
+    public static boolean noFeatherFallingTrample = false;
+    private static void noFeatherFallingTrample() {
+        noFeatherFallingTrample = getBoolean("settings.modify.no-feather-falling-trample", noFeatherFallingTrample);
+    }
+
+    public static boolean sharedVillagerDiscounts = false;
+    private static void sharedVillagerDiscounts() {
+        sharedVillagerDiscounts = getBoolean("settings.modify.shared-villager-discounts", sharedVillagerDiscounts);
+    }
+
+    public static boolean redstoneDontCantOnTrapDoor = false;
+    private static void redstoneDontCantOnTrapDoor() {
+        redstoneDontCantOnTrapDoor = getBoolean("settings.modify.redstone-wire-dont-connect-if-on-trapdoor", redstoneDontCantOnTrapDoor);
+    }
+
+    public static boolean disableCheckOutOfOrderCommand = false;
+    private static void disableCheckOutOfOrderCommand() {
+        disableCheckOutOfOrderCommand = getBoolean("settings.modify.disable-check-out-of-order-command", disableCheckOutOfOrderCommand);
+    }
+
+    public static boolean despawnEndermanWithBlock = false;
+    private static void despawnEndermanWithBlock() {
+        despawnEndermanWithBlock = getBoolean("settings.modify.despawn-enderman-with-block", despawnEndermanWithBlock);
+    }
+
+    public static boolean leavesCarpetSupport = false;
+    private static void leavesCarpetSupport() {
+        leavesCarpetSupport = getBoolean("settings.protocol.leaves-carpet-support", leavesCarpetSupport);
+    }
+
+    public static void registerCarpetRules() {
+        CarpetRules.register(CarpetRule.of("carpet", "creativeNoClip", creativeNoClip));
+        CarpetRules.register(CarpetRule.of("pca", "avoidAnvilTooExpensive", avoidAnvilTooExpensive));
+    }
+
+    public static boolean creativeNoClip = false;
+    private static void creativeNoClip() {
+        creativeNoClip = getBoolean("settings.modify.creative-no-clip", creativeNoClip);
+    }
+
+    public static boolean optimizedDragonRespawn = false;
+    private static void optimizedDragonRespawn() {
+        optimizedDragonRespawn = getBoolean("settings.performance.optimized-dragon-respawn", optimizedDragonRespawn);
+    }
+
+    public static boolean mendingCompatibilityInfinity = false;
+    private static void mendingCompatibilityInfinity() {
+        mendingCompatibilityInfinity = getBoolean("settings.modify.mending-compatibility-infinity", mendingCompatibilityInfinity);
+    }
+
+    public static boolean shaveSnowLayers = true;
+    private static void shaveSnowLayers() {
+        shaveSnowLayers = getBoolean("settings.modify.shave-snow-layers", shaveSnowLayers);
+    }
+
+    public static boolean ignoreLC = false;
+    private static void ignoreLC() {
+        ignoreLC = getBoolean("settings.modify.ignore-lc", ignoreLC);
+    }
+
+    public static boolean elytraAeronauticsNoChunk = false;
+    public static double elytraAeronauticsNoChunkHeight = 500.0D;
+    public static double elytraAeronauticsNoChunkSpeed = -1.0D;
+    public static boolean elytraAeronauticsNoChunkMes = true;
+    public static String elytraAeronauticsNoChunkStartMes = "Flight enter cruise mode";
+    public static String elytraAeronauticsNoChunkEndMes = "Flight exit cruise mode";
+    private static void elytraAeronautics() {
+        elytraAeronauticsNoChunk = getBoolean("settings.modify.elytra-aeronautics.no-chunk-load", elytraAeronauticsNoChunk);
+        elytraAeronauticsNoChunkHeight = getDouble("settings.modify.elytra-aeronautics.no-chunk-height", elytraAeronauticsNoChunkHeight);
+        elytraAeronauticsNoChunkSpeed = getDouble("settings.modify.elytra-aeronautics.no-chunk-speed", elytraAeronauticsNoChunkSpeed);
+        elytraAeronauticsNoChunkMes = getBoolean("settings.modify.elytra-aeronautics.message", elytraAeronauticsNoChunkMes);
+        elytraAeronauticsNoChunkStartMes = getString("settings.modify.elytra-aeronautics.message-start", elytraAeronauticsNoChunkStartMes);
+        elytraAeronauticsNoChunkEndMes = getString("settings.modify.elytra-aeronautics.message-end", elytraAeronauticsNoChunkEndMes);
+    }
+
+    public static boolean msptSyncProtocol = false;
+    public static int msptSyncTickInterval = 20;
+    private static void msptSyncProtocol() {
+        msptSyncTickInterval = getInt("settings.protocol.bladeren.mspt-sync-tick-interval", msptSyncTickInterval);
+        msptSyncProtocol = getBoolean("settings.protocol.bladeren.mspt-sync-protocol", msptSyncProtocol);
+    }
+
+    public static boolean fixPaper9372 = true;
+    private static void fixPaper9372() {
+        fixPaper9372 = getBoolean("settings.performance.fix.fix-paper-9372", fixPaper9372);
+    }
+
+    public static boolean cacheIgniteOdds = true;
+    private static void cacheIgniteOdds() {
+        cacheIgniteOdds = getBoolean("settings.performance.cache-ignite-odds", cacheIgniteOdds);
+    }
+
+    public static boolean lavaRiptide = false;
+    private static void lavaRiptide() {
+        lavaRiptide = getBoolean("settings.modify.lava-riptide", lavaRiptide);
+    }
+
+    public static boolean noBlockUpdateCommand = false;
+    private static void noBlockUpdateCommand() {
+        noBlockUpdateCommand = getBoolean("settings.modify.no-block-update-command", noBlockUpdateCommand);
+    }
+
+    public static boolean skipSelfRaidCheck = false;
+    private static void skipSelfRaidCheck() {
+        skipSelfRaidCheck = getBoolean("settings.modify.raider-die-skip-self-raid-check", skipSelfRaidCheck);
+    }
+
+    public static boolean containerPassthrough = false;
+    private static void containerPassthrough() {
+        containerPassthrough = getBoolean("settings.modify.container-passthrough", containerPassthrough);
+    }
+
+    public static boolean useFastItemMergeRaytracing = true;
+    private static void useFastItemMergeRaytracing() {
+        useFastItemMergeRaytracing = getBoolean("settings.performance.use-fast-item-merge-raytracing", useFastItemMergeRaytracing);
+    }
+
+    public static boolean dontTriggerLootableRefreshNonPlayer = true;
+    private static void dontTriggerLootableRefreshNonPlayer() {
+        dontTriggerLootableRefreshNonPlayer = getBoolean("settings.performance.dont-trigger-lootable-refresh-for-non-player", dontTriggerLootableRefreshNonPlayer);
+    }
+
+    public static boolean dontRespondPingBeforeStart = true;
+    private static void dontRespondPingBeforeStart() {
+        dontRespondPingBeforeStart = getBoolean("settings.misc.dont-respond-ping-before-start-fully", dontRespondPingBeforeStart);
+    }
+
+    public static boolean fasterChunkSerialization = true;
+    private static void fasterChunkSerialization() {
+        fasterChunkSerialization = getBoolean("settings.performance.faster-chunk-serialization", fasterChunkSerialization);
+    }
+
+    public static boolean optimizeWorldGenerationAccess = true;
+    private static void optimizeWorldGenerationAccess() {
+        optimizeWorldGenerationAccess = getBoolean("settings.performance.optimize-world-generation-and-block-access", optimizeWorldGenerationAccess);
+    }
+
+    public static boolean cacheWorldGeneratorSeaLevel = true;
+    private static void cacheWorldGeneratorSeaLevel() {
+        cacheWorldGeneratorSeaLevel = getBoolean("settings.performance.cache-world-generator-sea-level", cacheWorldGeneratorSeaLevel);
+    }
+
+    public static boolean skipSecondaryPOISensorIfAbsent = true;
+    private static void skipSecondaryPOISensorIfAbsent() {
+        skipSecondaryPOISensorIfAbsent = getBoolean("settings.performance.skip-secondary-POI-sensor-if-absent", skipSecondaryPOISensorIfAbsent);
+    }
+
+    public static boolean cacheCubeVoxelShapeShapeArray = true;
+    private static void cacheCubeVoxelShapeShapeArray() {
+        cacheCubeVoxelShapeShapeArray = getBoolean("settings.performance.cache-CubeVoxelShape-shape-array", cacheCubeVoxelShapeShapeArray);
+    }
+
+    public static boolean storeMobCountsInArray = true;
+    private static void storeMobCountsInArray() {
+        storeMobCountsInArray = getBoolean("settings.performance.store-mob-counts-in-array", storeMobCountsInArray);
+    }
+
+    public static boolean cacheBlockStatePairKeyHash = true;
+    private static void cacheBlockStatePairKeyHash() {
+        cacheBlockStatePairKeyHash = getBoolean("settings.performance.cache-BlockStatePairKey-hash", cacheBlockStatePairKeyHash);
+    }
+
+    public static boolean optimizeNoiseGeneration = false;
+    private static void optimizeNoiseGeneration() {
+        optimizeNoiseGeneration = getBoolean("settings.performance.optimize-noise-generation", optimizeNoiseGeneration);
+    }
+
+    public static boolean disablePacketLimit = false;
+    private static void disablePacketLimit() {
+        disablePacketLimit = getBoolean("settings.modify.disable-packet-limit", disablePacketLimit);
+    }
+
+    public static boolean optimizeSunBurnTick = true;
+    private static void optimizeSunBurnTick() {
+        optimizeSunBurnTick = getBoolean("settings.performance.optimize-sun-burn-tick", optimizeSunBurnTick);
+    }
+
+    public static boolean removeDamageLambda = true;
+    private static void removeDamageLambda() {
+        removeDamageLambda = getBoolean("settings.performance.remove.damage-lambda", removeDamageLambda);
+    }
+
+    public static boolean useOptimizedCollection = true;
+    private static void useOptimizedCollection() {
+        useOptimizedCollection = getBoolean("settings.performance.use-optimized-collection", useOptimizedCollection);
+    }
+
+    public static boolean optimizedCubePointRange = true;
+    private static void optimizedCubePointRange() {
+        optimizedCubePointRange = getBoolean("settings.performance.optimized-CubePointRange", optimizedCubePointRange);
+    }
+
+    public static boolean checkFrozenTicksBeforeLandingBlock = true;
+    private static void checkFrozenTicksBeforeLandingBlock() {
+        checkFrozenTicksBeforeLandingBlock = getBoolean("settings.performance.check-frozen-ticks-before-landing-block", checkFrozenTicksBeforeLandingBlock);
+    }
+
+    public static boolean cacheOminousBannerItem = true;
+    private static void cacheOminousBannerItem() {
+        cacheOminousBannerItem = getBoolean("settings.performance.cache-ominous-banner-item", cacheOminousBannerItem);
+    }
+
+    public static boolean skipEntityMoveIfMovementIsZero = true;
+    private static void skipEntityMoveIfMovementIsZero() {
+        skipEntityMoveIfMovementIsZero = getBoolean("settings.performance.skip-entity-move-if-movement-is-zero", skipEntityMoveIfMovementIsZero);
+    }
+
+    public static boolean skipCloningAdvancementCriteria = false;
+    private static void skipCloningAdvancementCriteria() {
+        skipCloningAdvancementCriteria = getBoolean("settings.performance.skip-cloning-advancement-criteria", skipCloningAdvancementCriteria);
+    }
+
+    public static boolean skipUnnecessaryMobSpawningComputations = true;
+    private static void skipUnnecessaryMobSpawningComputations() {
+        skipUnnecessaryMobSpawningComputations = getBoolean("settings.performance.skip-unnecessary-mob-spawning-computations", skipUnnecessaryMobSpawningComputations);
+    }
+
+    public static boolean skipNegligiblePlanarMovementMultiplication = true;
+    private static void skipNegligiblePlanarMovementMultiplication() {
+        skipNegligiblePlanarMovementMultiplication = getBoolean("settings.performance.skip-negligible-planar-movement-multiplication", skipNegligiblePlanarMovementMultiplication);
+    }
+
+    public static boolean villagersDontReleaseMemoryFix = false;
+    private static void villagersDontReleaseMemoryFix() {
+        villagersDontReleaseMemoryFix = getBoolean("settings.performance.fix-villagers-dont-release-memory", villagersDontReleaseMemoryFix);
+    }
+
+    public static boolean avoidAnvilTooExpensive = false;
+    private static void avoidAnvilTooExpensive() {
+        avoidAnvilTooExpensive = getBoolean("settings.modify.avoid-anvil-too-expensive", avoidAnvilTooExpensive);
+    }
+
+    public static boolean bowInfinityFix = false;
+    private static void bowInfinityFix() {
+        bowInfinityFix = getBoolean("settings.modify.bow-infinity-fix", bowInfinityFix);
+    }
+
+    public static boolean zeroTickPlants = false;
+    private static void zeroTickPlants() {
+        zeroTickPlants = getBoolean("settings.modify.zero-tick-plants", zeroTickPlants);
+    }
+
+    public static boolean bstatsPrivacyMode = false;
+    private static void bstatsPrivacyMode() {
+        bstatsPrivacyMode = getBoolean("settings.misc.bstats-privacy-mode", bstatsPrivacyMode);
+    }
+
+    public static final class WorldConfig {
+
+        public final String worldName;
+        public String configPath;
+        ConfigurationSection worldDefaults;
+
+        public WorldConfig(final String worldName) {
+            this.worldName = worldName;
+            this.init();
+        }
+
+        public void init() {
+            this.worldDefaults = LeavesConfig.config.getConfigurationSection("world-settings.default");
+            if (this.worldDefaults == null) {
+                this.worldDefaults = LeavesConfig.config.createSection("world-settings.default");
+            }
+
+            String worldSectionPath = LeavesConfig.configVersion < CURRENT_CONFIG_VERSION ? this.worldName : "world-settings.".concat(this.worldName);
+            ConfigurationSection section = LeavesConfig.config.getConfigurationSection(worldSectionPath);
+            this.configPath = worldSectionPath;
+            if (LeavesConfig.createWorldSections) {
+                if (section == null) {
+                    section = LeavesConfig.config.createSection(worldSectionPath);
+                }
+                LeavesConfig.config.set(worldSectionPath, section);
+            }
+
+            this.load();
+        }
+
+        public void load() {
+            for (final Method method : LeavesConfig.WorldConfig.class.getDeclaredMethods()) {
+                if (method.getReturnType() != void.class || method.getParameterCount() != 0 ||
+                    !Modifier.isPrivate(method.getModifiers()) || Modifier.isStatic(method.getModifiers())) {
+                    continue;
+                }
+
+                try {
+                    method.setAccessible(true);
+                    method.invoke(this, EMPTY);
+                } catch (final Exception ex) {
+                    SneakyThrow.sneaky(ex); /* Rethrow, this is critical */
+                    throw new RuntimeException(ex); // unreachable
+                }
+            }
+
+            if (LeavesConfig.configVersion < CURRENT_CONFIG_VERSION) {
+                ConfigurationSection oldSection = LeavesConfig.config.getConfigurationSection(this.worldName);
+                LeavesConfig.config.set("world-settings.".concat(this.worldName), oldSection);
+                LeavesConfig.config.set(this.worldName, null);
+            }
+
+            /* We re-save to add new options */
+            try {
+                LeavesConfig.config.save(LeavesConfig.configFile);
+            } catch (final Exception ex) {
+                Bukkit.getLogger().log(Level.SEVERE, "Unable to save leaves config", ex);
+            }
+        }
+
+        void set(final String path, final Object val) {
+            final ConfigurationSection config = LeavesConfig.config.getConfigurationSection(this.configPath);
+            this.worldDefaults.set(path, val);
+            if (config != null && config.get(path) != null) {
+                config.set(path, val);
+            }
+        }
+
+        boolean getBoolean(final String path, final boolean dfl) {
+            final ConfigurationSection config = LeavesConfig.config.getConfigurationSection(this.configPath);
+            this.worldDefaults.addDefault(path, Boolean.valueOf(dfl));
+            if (LeavesConfig.configVersion < CURRENT_CONFIG_VERSION) {
+                if (config != null && config.getBoolean(path) == dfl) {
+                    config.set(path, null);
+                }
+            }
+            return config == null ? this.worldDefaults.getBoolean(path) : config.getBoolean(path, this.worldDefaults.getBoolean(path));
+        }
+
+        boolean getBooleanRaw(final String path, final boolean dfl) {
+            final ConfigurationSection config = LeavesConfig.config.getConfigurationSection(this.configPath);
+            if (LeavesConfig.configVersion < CURRENT_CONFIG_VERSION) {
+                if (config != null && config.getBoolean(path) == dfl) {
+                    config.set(path, null);
+                }
+            }
+            return config == null ? this.worldDefaults.getBoolean(path, dfl) : config.getBoolean(path, this.worldDefaults.getBoolean(path, dfl));
+        }
+
+        int getInt(final String path, final int dfl) {
+            final ConfigurationSection config = LeavesConfig.config.getConfigurationSection(this.configPath);
+            this.worldDefaults.addDefault(path, Integer.valueOf(dfl));
+            if (LeavesConfig.configVersion < CURRENT_CONFIG_VERSION) {
+                if (config != null && config.getInt(path) == dfl) {
+                    config.set(path, null);
+                }
+            }
+            return config == null ? this.worldDefaults.getInt(path) : config.getInt(path, this.worldDefaults.getInt(path));
+        }
+
+        int getIntRaw(final String path, final int dfl) {
+            final ConfigurationSection config = LeavesConfig.config.getConfigurationSection(this.configPath);
+            if (LeavesConfig.configVersion < CURRENT_CONFIG_VERSION) {
+                if (config != null && config.getInt(path) == dfl) {
+                    config.set(path, null);
+                }
+            }
+            return config == null ? this.worldDefaults.getInt(path, dfl) : config.getInt(path, this.worldDefaults.getInt(path, dfl));
+        }
+
+        long getLong(final String path, final long dfl) {
+            final ConfigurationSection config = LeavesConfig.config.getConfigurationSection(this.configPath);
+            this.worldDefaults.addDefault(path, Long.valueOf(dfl));
+            if (LeavesConfig.configVersion < CURRENT_CONFIG_VERSION) {
+                if (config != null && config.getLong(path) == dfl) {
+                    config.set(path, null);
+                }
+            }
+            return config == null ? this.worldDefaults.getLong(path) : config.getLong(path, this.worldDefaults.getLong(path));
+        }
+
+        long getLongRaw(final String path, final long dfl) {
+            final ConfigurationSection config = LeavesConfig.config.getConfigurationSection(this.configPath);
+            if (LeavesConfig.configVersion < CURRENT_CONFIG_VERSION) {
+                if (config != null && config.getLong(path) == dfl) {
+                    config.set(path, null);
+                }
+            }
+            return config == null ? this.worldDefaults.getLong(path, dfl) : config.getLong(path, this.worldDefaults.getLong(path, dfl));
+        }
+
+        double getDouble(final String path, final double dfl) {
+            final ConfigurationSection config = LeavesConfig.config.getConfigurationSection(this.configPath);
+            this.worldDefaults.addDefault(path, Double.valueOf(dfl));
+            if (LeavesConfig.configVersion < CURRENT_CONFIG_VERSION) {
+                if (config != null && config.getDouble(path) == dfl) {
+                    config.set(path, null);
+                }
+            }
+            return config == null ? this.worldDefaults.getDouble(path) : config.getDouble(path, this.worldDefaults.getDouble(path));
+        }
+
+        double getDoubleRaw(final String path, final double dfl) {
+            final ConfigurationSection config = LeavesConfig.config.getConfigurationSection(this.configPath);
+            if (LeavesConfig.configVersion < CURRENT_CONFIG_VERSION) {
+                if (config != null && config.getDouble(path) == dfl) {
+                    config.set(path, null);
+                }
+            }
+            return config == null ? this.worldDefaults.getDouble(path, dfl) : config.getDouble(path, this.worldDefaults.getDouble(path, dfl));
+        }
+
+        String getString(final String path, final String dfl) {
+            final ConfigurationSection config = LeavesConfig.config.getConfigurationSection(this.configPath);
+            this.worldDefaults.addDefault(path, dfl);
+            return config == null ? this.worldDefaults.getString(path) : config.getString(path, this.worldDefaults.getString(path));
+        }
+
+        String getStringRaw(final String path, final String dfl) {
+            final ConfigurationSection config = LeavesConfig.config.getConfigurationSection(this.configPath);
+            return config == null ? this.worldDefaults.getString(path, dfl) : config.getString(path, this.worldDefaults.getString(path, dfl));
+        }
+
+        List getList(final String path, final List dfl) {
+            final ConfigurationSection config = LeavesConfig.config.getConfigurationSection(this.configPath);
+            this.worldDefaults.addDefault(path, dfl);
+            return config == null ? this.worldDefaults.getList(path) : config.getList(path, this.worldDefaults.getList(path));
+        }
+
+        List getListRaw(final String path, final List dfl) {
+            final ConfigurationSection config = LeavesConfig.config.getConfigurationSection(this.configPath);
+            return config == null ? this.worldDefaults.getList(path, dfl) : config.getList(path, this.worldDefaults.getList(path, dfl));
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/LeavesLogger.java b/src/main/java/top/leavesmc/leaves/LeavesLogger.java
new file mode 100644
index 0000000000000000000000000000000000000000..890b91a95719f18a75bc2c2176ef5cb9f2bf4274
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/LeavesLogger.java
@@ -0,0 +1,16 @@
+package top.leavesmc.leaves;
+
+import org.bukkit.Bukkit;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public class LeavesLogger extends Logger {
+    public static final LeavesLogger LOGGER = new LeavesLogger();
+
+    private LeavesLogger() {
+        super("Leaves", null);
+        setParent(Bukkit.getLogger());
+        setLevel(Level.ALL);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/BotCommand.java b/src/main/java/top/leavesmc/leaves/bot/BotCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..1cd65e1249f4d8579e9bdd78d508f184fe4fb46a
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/BotCommand.java
@@ -0,0 +1,254 @@
+package top.leavesmc.leaves.bot;
+
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.bukkit.generator.WorldInfo;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.agent.Actions;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.bot.agent.actions.CraftCustomBotAction;
+import top.leavesmc.leaves.entity.Bot;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class BotCommand extends Command {
+
+    public BotCommand(String name) {
+        super(name);
+        this.description = "FakePlayer Command";
+        this.usageMessage = "/bot [create | remove | action | list]";
+        this.setPermission("bukkit.command.bot");
+    }
+
+    @Override
+    public @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, String @NotNull [] args, Location location) throws IllegalArgumentException {
+        var list = new ArrayList<String>();
+
+        if (args.length <= 1) {
+            list.add("create");
+            list.add("remove");
+            list.add("action");
+            list.add("list");
+        }
+
+        if (args.length == 2) {
+            switch (args[0]) {
+                case "create" -> list.add("<BotName>");
+                case "remove", "action" ->
+                    list.addAll(ServerBot.getBots().stream().map(e -> e.getName().getString()).toList());
+                case "list" -> list.addAll(Bukkit.getWorlds().stream().map(WorldInfo::getName).toList());
+            }
+        }
+
+        if (args.length == 3) {
+            switch (args[0]) {
+                case "action" -> list.addAll(Actions.getNames());
+                case "create" -> list.add("<BotSkinName>");
+            }
+        }
+
+        if (args.length >= 4 && args[0].equals("action")) {
+            BotAction action = Actions.getForName(args[2]);
+            if (action != null) {
+                list.addAll(action.getArgument().tabComplete(args.length - 4));
+            }
+        }
+        return list;
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (args.length == 0) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        switch (args[0]) {
+            case "create" -> this.onCreate(sender, args);
+
+            case "remove" -> this.onRemove(sender, args);
+
+            case "action" -> this.onAction(sender, args);
+
+            case "list" -> this.onList(sender, args);
+
+            default -> {
+                sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private void onCreate(CommandSender sender, String @NotNull [] args) {
+        if (args.length < 2) {
+            sender.sendMessage(ChatColor.RED + "Use /bot create <name> [skin_name] to create a fakeplayer");
+            return;
+        }
+
+        if (canCreate(sender, args[1])) {
+            if (sender instanceof Player player) {
+                new ServerBot.BotCreateState(player.getLocation(), args[1], args.length < 3 ? args[1] : args[2]).createAsync(null);
+            } else if (sender instanceof ConsoleCommandSender) {
+                if (args.length < 6) {
+                    sender.sendMessage(ChatColor.RED + "Use /bot create <name> <skin_name> <bukkit_world_name> <x> <y> <z> to create a fakeplayer");
+                    return;
+                }
+
+                try {
+                    World world = Bukkit.getWorld(args[3]);
+                    double x = Double.parseDouble(args[4]);
+                    double y = Double.parseDouble(args[5]);
+                    double z = Double.parseDouble(args[6]);
+
+                    if (world != null) {
+                        new ServerBot.BotCreateState(new Location(world, x, y, z), args[1], args[2]).createAsync(null);
+                    }
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+
+    private boolean canCreate(CommandSender sender, @NotNull String name) {
+        if (!name.matches("^[a-zA-Z0-9_]{4,16}$")) {
+            sender.sendMessage(ChatColor.RED + "This name is illegal");
+            return false;
+        }
+
+        if (Bukkit.getPlayer(name) != null || ServerBot.getBot(name) != null) {
+            sender.sendMessage(ChatColor.RED + "This player is in server");
+            return false;
+        }
+
+        if (top.leavesmc.leaves.LeavesConfig.unableFakeplayerNames.contains(name)) {
+            sender.sendMessage(ChatColor.RED + "This name is not allowed");
+            return false;
+        }
+
+        if (ServerBot.getBots().size() >= top.leavesmc.leaves.LeavesConfig.fakeplayerLimit) {
+            sender.sendMessage(ChatColor.RED + "Fakeplayer limit is full");
+            return false;
+        }
+
+        return true;
+    }
+
+    private void onRemove(CommandSender sender, String @NotNull [] args) {
+        if (args.length < 2) {
+            sender.sendMessage(ChatColor.RED + "Use /bot remove <name> to remove a fakeplayer");
+            return;
+        }
+
+        ServerBot bot = ServerBot.getBot(args[1]);
+
+        if (bot == null) {
+            sender.sendMessage(ChatColor.RED + "This fakeplayer is not in server");
+            return;
+        }
+
+        bot.die(bot.damageSources().fellOutOfWorld());
+    }
+
+    private void onAction(CommandSender sender, String @NotNull [] args) {
+        if (args.length < 3) {
+            sender.sendMessage(ChatColor.RED + "Use /bot action <name> <action> to make fakeplayer do action");
+            return;
+        }
+
+        if (!(sender instanceof CraftPlayer player)) {
+            sender.sendMessage(ChatColor.RED + "This command only can use by player");
+            return;
+        }
+
+        BotAction action = Actions.getForName(args[2]);
+        if (action == null) {
+            sender.sendMessage(ChatColor.RED + "Invalid action");
+            return;
+        }
+
+        ServerBot bot = ServerBot.getBot(args[1]);
+        if (bot == null) {
+            sender.sendMessage(ChatColor.RED + "This fakeplayer is not in server");
+            return;
+        }
+
+        BotAction newAction;
+        if (action instanceof CraftCustomBotAction customBotAction) {
+            String[] realArgs = new String[args.length - 3];
+            if (realArgs.length != 0) {
+                System.arraycopy(args, 3, realArgs, 0, realArgs.length);
+            }
+            newAction = customBotAction.getNew(player, realArgs);
+        } else {
+            newAction = action.getNew(player.getHandle(), action.getArgument().parse(3, args));
+        }
+
+        if (newAction == null) {
+            sender.sendMessage(ChatColor.RED + "Action create error, please check your arguments");
+            return;
+        }
+
+        bot.setBotAction(newAction);
+        sender.sendMessage("Action " + action.getName() + " has been issued to " + bot.getName().getString());
+    }
+
+    private void onList(CommandSender sender, String @NotNull [] args) {
+        if (args.length < 2) {
+            Map<World, List<String>> botMap = new HashMap<>();
+            for (World world : Bukkit.getWorlds()) {
+                botMap.put(world, new ArrayList<>());
+            }
+
+            for (ServerBot bot : ServerBot.getBots()) {
+                Bot bukkitBot = bot.getBukkitPlayer();
+                botMap.get(bukkitBot.getWorld()).add(bukkitBot.getName());
+            }
+
+            sender.sendMessage("Total number: (" + ServerBot.getBots().size() + "/" + top.leavesmc.leaves.LeavesConfig.fakeplayerLimit + ")");
+            for (World world : botMap.keySet()) {
+                sender.sendMessage(world.getName() + "(" + botMap.get(world).size() + "): " + formatPlayerNameList(botMap.get(world)));
+            }
+        } else {
+            World world = Bukkit.getWorld(args[2]);
+
+            if (world == null) {
+                sender.sendMessage(ChatColor.RED + "Unknown world");
+                return;
+            }
+
+            List<String> botList = new ArrayList<>();
+            for (ServerBot bot : ServerBot.getBots()) {
+                Bot bukkitBot = bot.getBukkitPlayer();
+                if (bukkitBot.getWorld() == world) {
+                    botList.add(bukkitBot.getName());
+                }
+            }
+
+            sender.sendMessage(world.getName() + "(" + botList.size() + "): " + formatPlayerNameList(botList));
+        }
+    }
+
+    @NotNull
+    private static String formatPlayerNameList(@NotNull List<String> list) {
+        if (list.isEmpty()) {
+            return "";
+        }
+        String string = list.toString();
+        return string.substring(1, string.length() - 1);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/BotInventoryContainer.java b/src/main/java/top/leavesmc/leaves/bot/BotInventoryContainer.java
new file mode 100644
index 0000000000000000000000000000000000000000..9fce8c91bf0c211c2d87993cc0e2d4e8f5fe3d19
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/BotInventoryContainer.java
@@ -0,0 +1,180 @@
+package top.leavesmc.leaves.bot;
+
+import com.google.common.collect.ImmutableList;
+import com.mojang.datafixers.util.Pair;
+import net.minecraft.core.NonNullList;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.ContainerHelper;
+import net.minecraft.world.SimpleContainer;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+
+import javax.annotation.Nonnull;
+import java.util.List;
+
+// Power by gugle-carpet-addition(https://github.com/Gu-ZT/gugle-carpet-addition)
+public class BotInventoryContainer extends SimpleContainer {
+
+    public final NonNullList<ItemStack> items;
+    public final NonNullList<ItemStack> armor;
+    public final NonNullList<ItemStack> offhand;
+    private final List<NonNullList<ItemStack>> compartments;
+    private final NonNullList<ItemStack> buttons = NonNullList.withSize(13, ItemStack.EMPTY);
+    private final ServerBot player;
+
+    public BotInventoryContainer(ServerBot player) {
+        this.player = player;
+        this.items = this.player.getInventory().items;
+        this.armor = this.player.getInventory().armor;
+        this.offhand = this.player.getInventory().offhand;
+        this.compartments = ImmutableList.of(this.items, this.armor, this.offhand, this.buttons);
+        createButton();
+    }
+
+    @Override
+    public int getContainerSize() {
+        return this.items.size() + this.armor.size() + this.offhand.size() + this.buttons.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        for (ItemStack itemStack : this.items) {
+            if (itemStack.isEmpty()) {
+                continue;
+            }
+            return false;
+        }
+        for (ItemStack itemStack : this.armor) {
+            if (itemStack.isEmpty()) {
+                continue;
+            }
+            return false;
+        }
+        for (ItemStack itemStack : this.offhand) {
+            if (itemStack.isEmpty()) {
+                continue;
+            }
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    @Nonnull
+    public ItemStack getItem(int slot) {
+        Pair<NonNullList<ItemStack>, Integer> pair = getItemSlot(slot);
+        if (pair != null) {
+            return pair.getFirst().get(pair.getSecond());
+        } else {
+            return ItemStack.EMPTY;
+        }
+    }
+
+    public Pair<NonNullList<ItemStack>, Integer> getItemSlot(int slot) {
+        switch (slot) {
+            case 0 -> {
+                return new Pair<>(buttons, 0);
+            }
+            case 1, 2, 3, 4 -> {
+                return new Pair<>(armor, 4 - slot);
+            }
+            case 5, 6 -> {
+                return new Pair<>(buttons, slot - 4);
+            }
+            case 7 -> {
+                return new Pair<>(offhand, 0);
+            }
+            case 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 -> {
+                return new Pair<>(buttons, slot - 5);
+            }
+            case 18, 19, 20, 21, 22, 23, 24, 25, 26,
+                27, 28, 29, 30, 31, 32, 33, 34, 35,
+                36, 37, 38, 39, 40, 41, 42, 43, 44 -> {
+                return new Pair<>(items, slot - 9);
+            }
+            case 45, 46, 47, 48, 49, 50, 51, 52, 53 -> {
+                return new Pair<>(items, slot - 45);
+            }
+            default -> {
+                return null;
+            }
+        }
+    }
+
+    @Override
+    @Nonnull
+    public ItemStack removeItem(int slot, int amount) {
+        Pair<NonNullList<ItemStack>, Integer> pair = getItemSlot(slot);
+        NonNullList<ItemStack> list = null;
+        ItemStack itemStack = ItemStack.EMPTY;
+        if (pair != null) {
+            list = pair.getFirst();
+            slot = pair.getSecond();
+        }
+        if (list != null && !list.get(slot).isEmpty()) {
+            itemStack = ContainerHelper.removeItem(list, slot, amount);
+            player.detectEquipmentUpdates();
+        }
+        return itemStack;
+    }
+
+    @Override
+    @Nonnull
+    public ItemStack removeItemNoUpdate(int slot) {
+        Pair<NonNullList<ItemStack>, Integer> pair = getItemSlot(slot);
+        NonNullList<ItemStack> list = null;
+        if (pair != null) {
+            list = pair.getFirst();
+            slot = pair.getSecond();
+        }
+        if (list != null && !list.get(slot).isEmpty()) {
+            ItemStack itemStack = list.get(slot);
+            list.set(slot, ItemStack.EMPTY);
+            return itemStack;
+        }
+        return ItemStack.EMPTY;
+    }
+
+    @Override
+    public void setItem(int slot, @Nonnull ItemStack stack) {
+        Pair<NonNullList<ItemStack>, Integer> pair = getItemSlot(slot);
+        NonNullList<ItemStack> list = null;
+        if (pair != null) {
+            list = pair.getFirst();
+            slot = pair.getSecond();
+        }
+        if (list != null) {
+            list.set(slot, stack);
+            player.detectEquipmentUpdates();
+        }
+    }
+
+    @Override
+    public void setChanged() {
+    }
+
+    @Override
+    public boolean stillValid(@Nonnull Player player) {
+        if (this.player.isRemoved()) {
+            return false;
+        }
+        return !(player.distanceToSqr(this.player) > 64.0);
+    }
+
+    @Override
+    public void clearContent() {
+        for (List<ItemStack> list : this.compartments) {
+            list.clear();
+        }
+    }
+
+    private void createButton() {
+        for (int i = 0; i < 13; i++) {
+            ItemStack button = new ItemStack(Items.STRUCTURE_VOID);
+            button.setHoverName(Component.empty());
+            button.getOrCreateTag().putBoolean("Leaves.Gui.Placeholder", true);
+            buttons.set(i, button);
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/BotStatsCounter.java b/src/main/java/top/leavesmc/leaves/bot/BotStatsCounter.java
new file mode 100644
index 0000000000000000000000000000000000000000..07b688d376a4af88305e57519a5ae983ed7d91d3
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/BotStatsCounter.java
@@ -0,0 +1,33 @@
+package top.leavesmc.leaves.bot;
+
+import com.mojang.datafixers.DataFixer;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.stats.ServerStatsCounter;
+import net.minecraft.stats.Stat;
+import net.minecraft.world.entity.player.Player;
+
+import java.io.File;
+
+public class BotStatsCounter extends ServerStatsCounter {
+
+    private static final File UNKOWN_FILE = new File("BOT_STATS_REMOVE_THIS");
+
+    public BotStatsCounter(MinecraftServer server) {
+        super(server, UNKOWN_FILE);
+    }
+
+    @Override
+    public void save() {
+
+    }
+
+    @Override
+    public void setValue(Player player, Stat<?> stat, int value) {
+
+    }
+
+    @Override
+    public void parseLocal(DataFixer dataFixer, String json) {
+
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/BotUtil.java b/src/main/java/top/leavesmc/leaves/bot/BotUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..0f19bc7cfe12f128bae26025a6906da1fd7aa518
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/BotUtil.java
@@ -0,0 +1,182 @@
+package top.leavesmc.leaves.bot;
+
+import com.google.common.base.Charsets;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import net.minecraft.core.NonNullList;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.NbtIo;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.storage.LevelResource;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.agent.Actions;
+import top.leavesmc.leaves.bot.agent.BotAction;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Map;
+import java.util.UUID;
+
+public class BotUtil {
+
+    public static void replenishment(@NotNull ItemStack itemStack, NonNullList<ItemStack> itemStackList) {
+        int count = itemStack.getMaxStackSize() / 2;
+        if (itemStack.getCount() <= 8 && count > 8) {
+            for (ItemStack itemStack1 : itemStackList) {
+                if (itemStack1 == ItemStack.EMPTY || itemStack1 == itemStack) {
+                    continue;
+                }
+
+                if (ItemStack.isSameItemSameTags(itemStack1, itemStack)) {
+                    if (itemStack1.getCount() > count) {
+                        itemStack.setCount(itemStack.getCount() + count);
+                        itemStack1.setCount(itemStack1.getCount() - count);
+                    } else {
+                        itemStack.setCount(itemStack.getCount() + itemStack1.getCount());
+                        itemStack1.setCount(0);
+                    }
+                    break;
+                }
+            }
+        }
+    }
+
+    public static void replaceTool(@NotNull EquipmentSlot slot, @NotNull ServerBot bot) {
+        ItemStack itemStack = bot.getItemBySlot(slot);
+        for (int i = 0; i < 36; i++) {
+            ItemStack itemStack1 = bot.getInventory().getItem(i);
+            if (itemStack1 == ItemStack.EMPTY || itemStack1 == itemStack) {
+                continue;
+            }
+
+            if (itemStack1.getItem().getClass() == itemStack.getItem().getClass() && !isDamage(itemStack1, 10)) {
+                ItemStack itemStack2 = itemStack1.copy();
+                bot.getInventory().setItem(i, itemStack);
+                bot.setItemSlot(slot, itemStack2);
+                return;
+            }
+        }
+
+        for (int i = 0; i < 36; i++) {
+            ItemStack itemStack1 = bot.getInventory().getItem(i);
+            if (itemStack1 == ItemStack.EMPTY && itemStack1 != itemStack) {
+                bot.getInventory().setItem(i, itemStack);
+                bot.setItemSlot(slot, ItemStack.EMPTY);
+                return;
+            }
+        }
+    }
+
+    public static boolean isDamage(@NotNull ItemStack item, int minDamage) {
+        return item.isDamageableItem() && (item.getMaxDamage() - item.getDamageValue()) <= minDamage;
+    }
+
+    @NotNull
+    public static JsonObject saveBot(@NotNull ServerBot bot) {
+        double pos_x = bot.getX();
+        double pos_y = bot.getY();
+        double pos_z = bot.getZ();
+        float yaw = bot.getYRot();
+        float pitch = bot.getXRot();
+        String dimension = bot.getLocation().getWorld().getName();
+        String skin = bot.createState.skinName;
+
+        JsonObject fakePlayer = new JsonObject();
+        fakePlayer.addProperty("pos_x", pos_x);
+        fakePlayer.addProperty("pos_y", pos_y);
+        fakePlayer.addProperty("pos_z", pos_z);
+        fakePlayer.addProperty("yaw", yaw);
+        fakePlayer.addProperty("pitch", pitch);
+        fakePlayer.addProperty("dimension", dimension);
+        fakePlayer.addProperty("skin", skin);
+
+        BotAction botAction = bot.getBotAction();
+        if (botAction != null) {
+            JsonObject action = new JsonObject();
+            action.addProperty("name", botAction.getName());
+            action.addProperty("number", String.valueOf(botAction.getNumber()));
+            action.addProperty("delay", String.valueOf(botAction.getTickDelay()));
+            fakePlayer.add("action", action);
+        }
+
+        CompoundTag invnbt = new CompoundTag();
+        invnbt.put("Inventory", bot.getInventory().save(new ListTag()));
+
+        File file = MinecraftServer.getServer().getWorldPath(LevelResource.ROOT).resolve("fakeplayer/" + bot.getStringUUID() + ".dat").toFile();
+        File parent = file.getParentFile();
+        try {
+            if (!parent.exists() || !parent.isDirectory()) {
+                parent.mkdirs();
+            }
+            if (file.exists() && file.isFile()) {
+                file.delete();
+            }
+            file.createNewFile();
+            NbtIo.writeCompressed(invnbt, file);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        return fakePlayer;
+    }
+
+    public static void loadBot(Map.@NotNull Entry<String, JsonElement> entry) {
+        String username = entry.getKey();
+        JsonObject fakePlayer = entry.getValue().getAsJsonObject();
+        double pos_x = fakePlayer.get("pos_x").getAsDouble();
+        double pos_y = fakePlayer.get("pos_y").getAsDouble();
+        double pos_z = fakePlayer.get("pos_z").getAsDouble();
+        float yaw = fakePlayer.get("yaw").getAsFloat();
+        float pitch = fakePlayer.get("pitch").getAsFloat();
+        String dimension = fakePlayer.get("dimension").getAsString();
+        String skin = fakePlayer.get("skin").getAsString();
+
+        Location location = new Location(Bukkit.getWorld(dimension), pos_x, pos_y, pos_z, yaw, pitch);
+        ServerBot.BotCreateState state = new ServerBot.BotCreateState(location, username, skin);
+
+        ListTag inv = null;
+        File file = MinecraftServer.getServer().getWorldPath(LevelResource.ROOT).resolve("fakeplayer/" + getBotUUID(state) + ".dat").toFile();
+        if (file.exists()) {
+            try {
+                CompoundTag nbt = NbtIo.readCompressed(file);
+                inv = nbt.getList("Inventory", 10);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+            file.delete();
+        }
+
+        JsonObject actionObj = null;
+        if (fakePlayer.has("action")) {
+            actionObj = fakePlayer.get("action").getAsJsonObject();
+        }
+
+        final ListTag finalInv = inv;
+        final JsonObject finalActionObj = actionObj;
+        state.createAsync(serverBot -> {
+            if (finalInv != null) {
+                serverBot.getInventory().load(finalInv);
+            }
+
+            if (finalActionObj != null) {
+                BotAction action = Actions.getForName(finalActionObj.get("name").getAsString());
+                if (action != null) {
+                    BotAction newAction = action.getNew(serverBot,
+                        action.getArgument().parse(0, new String[]{finalActionObj.get("delay").getAsString(), finalActionObj.get("number").getAsString()})
+                    );
+                    serverBot.setBotAction(newAction);
+                }
+            }
+        });
+    }
+
+    @NotNull
+    public static UUID getBotUUID(ServerBot.@NotNull BotCreateState state) {
+        return UUID.nameUUIDFromBytes(("Fakeplayer:" + state.getRealName()).getBytes(Charsets.UTF_8));
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/MojangAPI.java b/src/main/java/top/leavesmc/leaves/bot/MojangAPI.java
new file mode 100644
index 0000000000000000000000000000000000000000..daaece30b2a3983f1cc9ee9a851e8f373974d5ec
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/MojangAPI.java
@@ -0,0 +1,41 @@
+package top.leavesmc.leaves.bot;
+
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+
+public class MojangAPI {
+
+    private static final boolean CACHE_ENABLED = false;
+
+    private static final Map<String, String[]> CACHE = new HashMap<>();
+
+    public static String[] getSkin(String name) {
+        if (CACHE_ENABLED && CACHE.containsKey(name)) {
+            return CACHE.get(name);
+        }
+
+        String[] values = pullFromAPI(name);
+        CACHE.put(name, values);
+        return values;
+    }
+
+    // Laggggggggggggggggggggggggggggggggggggggggg
+    public static String[] pullFromAPI(String name) {
+        try {
+            String uuid = new JsonParser().parse(new InputStreamReader(new URL("https://api.mojang.com/users/profiles/minecraft/" + name)
+                .openStream())).getAsJsonObject().get("id").getAsString();
+            JsonObject property = new JsonParser()
+                .parse(new InputStreamReader(new URL("https://sessionserver.mojang.com/session/minecraft/profile/" + uuid + "?unsigned=false")
+                    .openStream())).getAsJsonObject().get("properties").getAsJsonArray().get(0).getAsJsonObject();
+            return new String[] {property.get("value").getAsString(), property.get("signature").getAsString()};
+        } catch (IOException | IllegalStateException e) {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/ServerBot.java b/src/main/java/top/leavesmc/leaves/bot/ServerBot.java
new file mode 100644
index 0000000000000000000000000000000000000000..af9b83f72c1494a35adf604c4cba54d6bbdafae5
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/ServerBot.java
@@ -0,0 +1,692 @@
+package top.leavesmc.leaves.bot;
+
+import com.google.common.collect.Lists;
+import com.google.gson.Gson;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.properties.Property;
+import net.minecraft.Util;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.Connection;
+import net.minecraft.network.PacketSendListener;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ClientboundAddPlayerPacket;
+import net.minecraft.network.protocol.game.ClientboundPlayerInfoRemovePacket;
+import net.minecraft.network.protocol.game.ClientboundPlayerInfoUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundRemoveEntitiesPacket;
+import net.minecraft.network.protocol.game.ClientboundRotateHeadPacket;
+import net.minecraft.network.syncher.EntityDataAccessor;
+import net.minecraft.network.syncher.EntityDataSerializers;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.network.ServerGamePacketListenerImpl;
+import net.minecraft.server.network.ServerPlayerConnection;
+import net.minecraft.stats.ServerStatsCounter;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.InteractionResult;
+import net.minecraft.world.SimpleMenuProvider;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.entity.item.ItemEntity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.inventory.ChestMenu;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.gameevent.GameEvent;
+import net.minecraft.world.level.storage.LevelResource;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.util.Vector;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.LeavesConfig;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.entity.Bot;
+import top.leavesmc.leaves.entity.CraftBot;
+import top.leavesmc.leaves.event.bot.BotCreateEvent;
+import top.leavesmc.leaves.event.bot.BotJoinEvent;
+import top.leavesmc.leaves.util.MathUtils;
+
+import javax.annotation.Nullable;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.EnumSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.function.Consumer;
+
+// TODO remake all
+public class ServerBot extends ServerPlayer {
+
+    private Vec3 velocity;
+    private BotAction action;
+    private BotAction newAction;
+
+    private final boolean removeOnDeath;
+    private int fireTicks;
+    private int jumpTicks;
+    private int noFallTicks;
+    private int noActionTicks;
+    private int doActionNumber;
+    public boolean waterSwim;
+    private Vec3 knockback;
+    public BotCreateState createState;
+
+    private final ServerStatsCounter stats;
+    private final BotInventoryContainer container;
+
+    private static final List<ServerBot> bots = new CopyOnWriteArrayList<>();
+    private static final Plugin MINECRAFT_PLUGIN = new MinecraftInternalPlugin();
+
+    private ServerBot(MinecraftServer server, ServerLevel world, GameProfile profile) {
+        super(server, world, profile);
+        this.entityData.set(new EntityDataAccessor<>(16, EntityDataSerializers.INT), 0xFF);
+        this.entityData.set(Player.DATA_PLAYER_MODE_CUSTOMISATION, (byte) -2);
+
+        this.velocity = new Vec3(this.xxa, this.yya, this.zza);
+        this.noFallTicks = 60;
+        this.fireTicks = 0;
+        this.noActionTicks = 0;
+        this.doActionNumber = -1;
+        this.removeOnDeath = true;
+        this.stats = new BotStatsCounter(server);
+        this.container = new BotInventoryContainer(this);
+        this.fauxSleeping = LeavesConfig.fakeplayerSkipSleep;
+        this.waterSwim = true;
+        this.knockback = Vec3.ZERO;
+    }
+
+    public static ServerBot createBot(@NotNull BotCreateState state) {
+        if (!isCreateLegal(state.name)) {
+            return null;
+        }
+
+        MinecraftServer server = MinecraftServer.getServer();
+
+        BotCreateEvent event = new BotCreateEvent(state.name, state.skinName, state.loc, ChatColor.YELLOW + state.name + " joined the game");
+        server.server.getPluginManager().callEvent(event);
+
+        if (event.isCancelled()) {
+            return null;
+        }
+
+        Location location = event.getCreateLocation();
+
+        ServerLevel world = ((CraftWorld) location.getWorld()).getHandle();
+        CustomGameProfile profile = new CustomGameProfile(BotUtil.getBotUUID(state), state.name, state.skin);
+
+        ServerBot bot = new ServerBot(server, world, profile);
+
+        bot.connection = new ServerGamePacketListenerImpl(server, new Connection(PacketFlow.CLIENTBOUND) {
+            @Override
+            public void send(@NotNull Packet<?> packet, @Nullable PacketSendListener packetsendlistener) {
+            }
+        }, bot);
+        bot.isRealPlayer = true;
+        bot.createState = state;
+
+        if (event.getJoinMessage() != null) {
+            Bukkit.broadcastMessage(event.getJoinMessage());
+        }
+
+        bot.teleportTo(location.getX(), location.getY(), location.getZ());
+        bot.setRot(location.getYaw(), location.getPitch());
+        world.addFreshEntity(bot, CreatureSpawnEvent.SpawnReason.COMMAND);
+
+        bot.renderAll();
+        server.getPlayerList().addNewBot(bot);
+        bots.add(bot);
+
+        BotJoinEvent event1 = new BotJoinEvent(bot.getBukkitPlayer());
+        server.server.getPluginManager().callEvent(event1);
+
+        return bot;
+    }
+
+    public static boolean isCreateLegal(@NotNull String name) {
+        if (!name.matches("^[a-zA-Z0-9_]{4,16}$")) {
+            return false;
+        }
+
+        if (Bukkit.getPlayer(name) != null || ServerBot.getBot(name) != null) {
+            return false;
+        }
+
+        if (top.leavesmc.leaves.LeavesConfig.unableFakeplayerNames.contains(name)) {
+            return false;
+        }
+
+        return ServerBot.getBots().size() < top.leavesmc.leaves.LeavesConfig.fakeplayerLimit;
+    }
+
+    private void renderAll() {
+        Packet<?>[] packets = getRenderPackets();
+        Bukkit.getOnlinePlayers().forEach(p ->
+            render(((CraftPlayer) p).getHandle().connection, packets, false, p.getWorld() == getBukkitPlayer().getWorld()));
+    }
+
+    public void render(ServerPlayerConnection connection, boolean login, boolean all) {
+        render(connection, getRenderPackets(), login, all && LeavesConfig.alwaysSendFakeplayerData);
+    }
+
+    private void render(@NotNull ServerPlayerConnection connection, Packet<?> @NotNull [] packets, boolean login, boolean all) { // always use getRenderPackets() to get packets. replace it soon
+        connection.send(packets[0]);
+        if (all) {
+            connection.send(packets[1]);
+            if (login) {
+                Bukkit.getScheduler().runTaskLater(MINECRAFT_PLUGIN, () -> {
+                    connection.send(packets[2]);
+                }, 10);
+            } else {
+                connection.send(packets[2]);
+            }
+        }
+    }
+
+    @Contract(" -> new")
+    private Packet<?> @NotNull [] getRenderPackets() {
+        return new Packet[]{
+            new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.ADD_PLAYER, ClientboundPlayerInfoUpdatePacket.Action.UPDATE_LISTED, ClientboundPlayerInfoUpdatePacket.Action.UPDATE_DISPLAY_NAME), List.of(this)),
+            new ClientboundAddPlayerPacket(this),
+            // new ClientboundSetEntityDataPacket(this.getId(), ),
+            new ClientboundRotateHeadPacket(this, (byte) ((getYRot() * 256f) / 360f))
+        };
+    }
+
+    private void sendPacket(Packet<?> packet) {
+        Bukkit.getOnlinePlayers().forEach(p -> ((CraftPlayer) p).getHandle().connection.send(packet));
+    }
+
+    // die check start
+    @Override
+    public void die(@NotNull DamageSource damageSource) {
+        super.die(damageSource);
+        this.dieCheck();
+    }
+
+    private void dieCheck() {
+        if (removeOnDeath) {
+            bots.remove(this);
+            server.getPlayerList().removeBot(this);
+            remove(RemovalReason.KILLED);
+            this.setDead();
+            this.removeTab();
+            Bukkit.broadcastMessage(ChatColor.YELLOW + this.getName().getString() + " left the game"); // TODO i18n
+        }
+    }
+
+    private void removeTab() {
+        sendPacket(new ClientboundPlayerInfoRemovePacket(List.of(this.getUUID())));
+    }
+
+    private void setDead() {
+        sendPacket(new ClientboundRemoveEntitiesPacket(getId()));
+        this.dead = true;
+        this.inventoryMenu.removed(this);
+        this.containerMenu.removed(this);
+    }
+
+    // die check end
+
+    @Nullable
+    @Override
+    public Entity changeDimension(@NotNull ServerLevel destination) {
+        return null; // disable dimension change
+    }
+
+    public Bot getBukkitPlayer() {
+        return getBukkitEntity();
+    }
+
+    @Override
+    @NotNull
+    public CraftBot getBukkitEntity() {
+        return (CraftBot) super.getBukkitEntity();
+    }
+
+    @Override
+    public boolean isInWater() {
+        Location loc = getLocation();
+        for (int i = 0; i <= 2; i++) {
+            Material type = loc.getBlock().getType();
+            if (type == Material.WATER || type == Material.LAVA) {
+                return true;
+            }
+            loc.add(0, 0.9, 0);
+        }
+        return false;
+    }
+
+    @Override
+    public void tick() {
+        super.tick();
+        this.doTick();
+
+        if (!isAlive()) {
+            return;
+        }
+
+        if (fireTicks > 0) {
+            --fireTicks;
+        }
+        if (jumpTicks > 0) {
+            --jumpTicks;
+        }
+        if (noFallTicks > 0) {
+            --noFallTicks;
+        }
+        if (noActionTicks > 0) {
+            --noActionTicks;
+        }
+        if (takeXpDelay > 0) {
+            --takeXpDelay;
+        }
+
+        updateLocation();
+
+        float health = getHealth();
+        float maxHealth = getMaxHealth();
+        float regenAmount = 0.010f;
+        float amount;
+
+        if (health < maxHealth - regenAmount) {
+            amount = health + regenAmount;
+        } else {
+            amount = maxHealth;
+        }
+
+        this.setHealth(amount);
+
+        BlockPos blockposition = this.getOnPosLegacy();
+        BlockState iblockdata = this.level().getBlockState(blockposition);
+        Vec3 vec3d1 = this.collide(velocity);
+        this.checkFallDamage(vec3d1.y, this.onGround(), iblockdata, blockposition);
+
+        ++this.attackStrengthTicker;
+
+        if (this.getHealth() > 0.0F) {
+            AABB axisalignedbb;
+
+            if (this.isPassenger() && !this.getVehicle().isRemoved()) {
+                axisalignedbb = this.getBoundingBox().minmax(this.getVehicle().getBoundingBox()).inflate(1.0D, 0.0D, 1.0D);
+            } else {
+                axisalignedbb = this.getBoundingBox().inflate(1.0D, 0.5D, 1.0D);
+            }
+
+            List<Entity> list = this.level().getEntities(this, axisalignedbb);
+            List<Entity> list1 = Lists.newArrayList();
+
+            for (Entity entity : list) {
+                if (entity.getType() == EntityType.EXPERIENCE_ORB) {
+                    list1.add(entity);
+                } else if (!entity.isRemoved()) {
+                    this.touch(entity);
+                }
+            }
+
+            if (!list1.isEmpty()) {
+                this.touch(Util.getRandom(list1, this.random));
+            }
+        }
+
+        if (newAction != null) {
+            action = newAction;
+            newAction = null;
+            noActionTicks = 0;
+            doActionNumber = action.getNumber();
+        }
+
+        if (action != null && noActionTicks <= 0) {
+            if (action.isCancel()) {
+                action = null;
+            } else {
+                if (doActionNumber != 0) {
+                    if (action.doTick(this)) {
+                        doActionNumber--;
+                    }
+                    noActionTicks = action.getTickDelay();
+                } else {
+                    action = null;
+                }
+            }
+        }
+    }
+
+    private void touch(@NotNull Entity entity) {
+        entity.playerTouch(this);
+    }
+
+    @Override
+    public void onItemPickup(@NotNull ItemEntity item) {
+        super.onItemPickup(item);
+        this.updateItemInMainHand();
+    }
+
+    public void updateItemInMainHand() {
+        tryReplenishOrReplaceInMainHand();
+        detectEquipmentUpdates();
+    }
+
+    public void tryReplenishOrReplaceInMainHand() {
+        net.minecraft.world.item.ItemStack mainHand = getMainHandItem();
+
+        if (!mainHand.isEmpty()) {
+            BotUtil.replenishment(mainHand, getInventory().items);
+            if (BotUtil.isDamage(mainHand, 10)) {
+                BotUtil.replaceTool(EquipmentSlot.MAINHAND, this);
+            }
+        }
+    }
+
+    @Override
+    public void checkFallDamage(double heightDifference, boolean onGround, @NotNull BlockState state, @NotNull BlockPos landedPosition) {
+        if (onGround) {
+            if (this.fallDistance > 0.0F) {
+                state.getBlock().fallOn(this.level(), state, landedPosition, this, this.fallDistance);
+                this.level().gameEvent(GameEvent.HIT_GROUND, this.position(), GameEvent.Context.of(this, this.mainSupportingBlockPos.map((blockposition1) -> {
+                    return this.level().getBlockState(blockposition1);
+                }).orElse(state)));
+            }
+
+            this.resetFallDistance();
+        } else if (heightDifference < 0.0D) {
+            this.fallDistance -= (float) heightDifference;
+        }
+    }
+
+    @Override
+    public void doTick() {
+        if (this.hurtTime > 0) {
+            this.hurtTime -= 1;
+        }
+
+        baseTick();
+
+        this.lerpSteps = (int) this.zza;
+        this.animStep = this.run;
+        this.yRotO = this.getYRot();
+        this.xRotO = this.getXRot();
+    }
+
+    public Location getLocation() {
+        return getBukkitPlayer().getLocation();
+    }
+
+    @Override
+    public void knockback(double strength, double x, double z, @NotNull Entity knockingBackEntity) {
+        strength *= 1.0D - this.getAttributeValue(Attributes.KNOCKBACK_RESISTANCE);
+        if (strength > 0.0D) {
+            this.hasImpulse = true;
+            Vec3 vec3d = this.getDeltaMovement();
+            Vec3 vec3d1 = (new Vec3(x, 0.0D, z)).normalize().scale(strength);
+            knockback = new Vec3(vec3d.x / 2.0D - vec3d1.x, this.onGround() ? Math.min(0.4D, vec3d.y / 2.0D + strength) : vec3d.y, vec3d.z / 2.0D - vec3d1.z);
+        }
+    }
+
+    private void updateLocation() {
+        this.velocity = new Vec3(this.xxa, this.yya, this.zza);
+
+        if (waterSwim && isInWater()) {
+            this.addDeltaMovement(new Vec3(0, 0.05, 0));
+        }
+        this.addDeltaMovement(knockback);
+        knockback = Vec3.ZERO;
+
+        this.travel(this.velocity);
+    }
+
+    public void faceLocation(@NotNull Location loc) {
+        look(loc.toVector().subtract(getLocation().toVector()), false);
+    }
+
+    public void look(Vector dir, boolean keepYaw) {
+        float yaw, pitch;
+
+        if (keepYaw) {
+            yaw = this.getYHeadRot();
+            pitch = MathUtils.fetchPitch(dir);
+        } else {
+            float[] vals = MathUtils.fetchYawPitch(dir);
+            yaw = vals[0];
+            pitch = vals[1];
+
+            sendPacket(new ClientboundRotateHeadPacket(this, (byte) (yaw * 256 / 360f)));
+        }
+
+        setRot(yaw, pitch);
+        this.getBukkitEntity().setRotation(yaw, pitch);
+    }
+
+    public void punch() {
+        swing(InteractionHand.MAIN_HAND);
+    }
+
+    public void attack(@NotNull Entity target) {
+        super.attack(target);
+        punch();
+    }
+
+    public void jumpFromGround() {
+        double jumpPower = (double) this.getJumpPower() + this.getJumpBoostPower();
+        this.addDeltaMovement(new Vec3(0, jumpPower, 0));
+    }
+
+    public void dropAll() {
+        getInventory().dropAll();
+        detectEquipmentUpdates();
+    }
+
+    public void setBotAction(BotAction botAction) {
+        this.newAction = botAction;
+    }
+
+    public BotAction getBotAction() {
+        return action;
+    }
+
+    @Override
+    public @NotNull ServerStatsCounter getStats() {
+        return stats;
+    }
+
+    public BotInventoryContainer getContainer() {
+        return container;
+    }
+
+    @Override
+    public @NotNull InteractionResult interact(@NotNull Player player, @NotNull InteractionHand hand) {
+        if (LeavesConfig.openFakeplayerInventory) {
+            if (player.getMainHandItem().isEmpty()) {
+                player.openMenu(new SimpleMenuProvider((i, inventory, p) -> ChestMenu.sixRows(i, inventory, container), getDisplayName()));
+                return InteractionResult.SUCCESS;
+            }
+        }
+        return super.interact(player, hand);
+    }
+
+    public static ServerBot getBot(ServerPlayer player) {
+        ServerBot bot = null;
+        for (ServerBot b : bots) {
+            if (b.getId() == player.getId()) {
+                bot = b;
+                break;
+            }
+        }
+        return bot;
+    }
+
+    public static ServerBot getBot(String name) {
+        ServerBot bot = null;
+        for (ServerBot b : bots) {
+            if (b.getName().getString().equals(name)) {
+                bot = b;
+                break;
+            }
+        }
+        return bot;
+    }
+
+    public static ServerBot getBot(UUID uuid) {
+        ServerBot bot = null;
+        for (ServerBot b : bots) {
+            if (b.uuid == uuid) {
+                bot = b;
+                break;
+            }
+        }
+        return bot;
+    }
+
+    public static void saveOrRemoveAllBot() {
+        if (LeavesConfig.fakeplayerSupport && LeavesConfig.fakeplayerResident) {
+            JsonObject fakePlayerList = new JsonObject();
+            bots.forEach(bot -> fakePlayerList.add(bot.createState.realName, BotUtil.saveBot(bot)));
+            File file = MinecraftServer.getServer().getWorldPath(LevelResource.ROOT).resolve("fake_player.leaves.json").toFile();
+            if (!file.isFile()) {
+                try {
+                    file.createNewFile();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+            try (BufferedWriter bfw = Files.newBufferedWriter(file.toPath(), StandardCharsets.UTF_8)) {
+                bfw.write(new Gson().toJson(fakePlayerList));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        } else {
+            removeAllBot();
+        }
+    }
+
+    public static void loadAllBot() {
+        if (LeavesConfig.fakeplayerSupport && LeavesConfig.fakeplayerResident) {
+            JsonObject fakePlayerList = new JsonObject();
+            File file = MinecraftServer.getServer().getWorldPath(LevelResource.ROOT).resolve("fake_player.leaves.json").toFile();
+            if (!file.isFile()) {
+                return;
+            }
+            try (BufferedReader bfr = Files.newBufferedReader(file.toPath(), StandardCharsets.UTF_8)) {
+                fakePlayerList = new Gson().fromJson(bfr, JsonObject.class);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+            for (Map.Entry<String, JsonElement> entry : fakePlayerList.entrySet()) {
+                BotUtil.loadBot(entry);
+            }
+            file.delete();
+        }
+    }
+
+    public static boolean removeAllBot() {
+        Iterator<ServerBot> iterator = bots.iterator();
+        while (iterator.hasNext()) {
+            ServerBot bot = iterator.next();
+            bot.die(bot.damageSources().fellOutOfWorld());
+        }
+        return true;
+    }
+
+    public static List<ServerBot> getBots() {
+        return bots;
+    }
+
+    public static class CustomGameProfile extends GameProfile {
+
+        public CustomGameProfile(UUID uuid, String name, String[] skin) {
+            super(uuid, name);
+            setSkin(skin);
+        }
+
+        public void setSkin(String[] skin) {
+            if (skin != null) {
+                getProperties().put("textures", new Property("textures", skin[0], skin[1]));
+            }
+        }
+    }
+
+    public static class BotCreateState {
+
+        public Location loc;
+
+        public String[] skin;
+        public String skinName;
+
+        private String realName;
+        private String name;
+
+        public BotCreateState() {
+        }
+
+        public BotCreateState(Location loc, String realName, String skinName) {
+            this.loc = loc;
+            this.skinName = skinName;
+            this.setRealName(realName);
+        }
+
+        public BotCreateState(Location loc, String name, String realName, String skinName, String[] skin) {
+            this.loc = loc;
+            this.skinName = skinName;
+            this.skin = skin;
+            this.realName = realName;
+            this.name = name;
+        }
+
+        public ServerBot createSync() {
+            return createBot(this);
+        }
+
+        public void createAsync(Consumer<ServerBot> consumer) {
+            Bukkit.getScheduler().runTaskAsynchronously(MINECRAFT_PLUGIN, () -> {
+                if (skinName != null) {
+                    this.skin = MojangAPI.getSkin(skinName);
+                }
+
+                Bukkit.getScheduler().runTask(MINECRAFT_PLUGIN, () -> {
+                    ServerBot bot = createBot(this);
+                    if (bot != null && consumer != null) {
+                        consumer.accept(bot);
+                    }
+                });
+            });
+        }
+
+        public void setName(String name) {
+            this.name = name;
+        }
+
+        public void setRealName(String realName) {
+            this.realName = realName;
+            this.name = LeavesConfig.fakeplayerPrefix + realName + LeavesConfig.fakeplayerSuffix;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public String getRealName() {
+            return realName;
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/Actions.java b/src/main/java/top/leavesmc/leaves/bot/agent/Actions.java
new file mode 100644
index 0000000000000000000000000000000000000000..c8490bcb9108d72281338f0a3f806586986ee2d9
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/Actions.java
@@ -0,0 +1,64 @@
+package top.leavesmc.leaves.bot.agent;
+
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.agent.actions.*;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+public class Actions {
+
+    private static final Map<String, BotAction> actions = new HashMap<>();
+
+    public static void registerAll() {
+        register(new AttackAction());
+        register(new BreakBlockAction());
+        register(new DropAction());
+        register(new JumpAction());
+        register(new RotateAction());
+        register(new SneakAction());
+        register(new StopAction());
+        register(new UseItemAction());
+        register(new UseItemOnAction());
+        register(new UseItemToAction());
+        register(new LookAction());
+        register(new FishAction());
+        register(new AttackSelfAction());
+        register(new SwimAction());
+        register(new LayAction());
+    }
+
+    public static boolean register(@NotNull BotAction action) {
+        if (!actions.containsKey(action.getName())) {
+            actions.put(action.getName(), action);
+            return true;
+        }
+        return false;
+    }
+
+    public static boolean unregister(@NotNull String name) {
+        if (actions.containsKey(name)) {
+            actions.remove(name);
+            return true;
+        }
+        return false;
+    }
+
+    @NotNull
+    @Contract(pure = true)
+    public static Collection<BotAction> getAll() {
+        return actions.values();
+    }
+
+    @NotNull
+    public static Set<String> getNames() {
+        return actions.keySet();
+    }
+
+    public static BotAction getForName(String name) {
+        return actions.get(name);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/BotAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/BotAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..9d01944805cfbffbd08343121b8ff27e06e504fb
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/BotAction.java
@@ -0,0 +1,71 @@
+package top.leavesmc.leaves.bot.agent;
+
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+
+import java.util.List;
+
+public abstract class BotAction {
+
+    private final String name;
+    private final CommandArgument argument;
+
+    private boolean cancel;
+    private int tickDelay;
+    private int number;
+
+    public BotAction(String name, CommandArgument argument) {
+        this.name = name;
+        this.argument = argument;
+
+        this.cancel = false;
+        this.tickDelay = 20;
+        this.number = -1;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public int getTickDelay() {
+        return tickDelay;
+    }
+
+    public int getNumber() {
+        return number;
+    }
+
+    public boolean isCancel() {
+        return cancel;
+    }
+
+    public BotAction setTickDelay(int tickDelay) {
+        this.tickDelay = Math.max(0, tickDelay);
+        return this;
+    }
+
+    public BotAction setTabComplete(int index, List<String> list) {
+        argument.setTabComplete(index, list);
+        return this;
+    }
+
+    public BotAction setNumber(int number) {
+        this.number = Math.max(-1, number);
+        return this;
+    }
+
+    public void setCancel(boolean cancel) {
+        this.cancel = cancel;
+    }
+
+    public CommandArgument getArgument() {
+        return argument;
+    }
+
+    public abstract BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result);
+
+    public abstract boolean doTick(@NotNull ServerBot bot);
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/AttackAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/AttackAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..609605b21cfe5af8876f76ea4922e379c5dd166e
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/AttackAction.java
@@ -0,0 +1,36 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.phys.EntityHitResult;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+import top.leavesmc.leaves.command.CommandArgumentType;
+
+import java.util.List;
+
+public class AttackAction extends BotAction {
+
+    public AttackAction() {
+        super("attack", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new AttackAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        EntityHitResult result = bot.getTargetEntity(3);
+        if (result != null) {
+            bot.attack(result.getEntity());
+            return true;
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/AttackSelfAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/AttackSelfAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a0e5626751d0b6ea12a6074b5626937b6668608
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/AttackSelfAction.java
@@ -0,0 +1,42 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import com.google.common.base.Predicates;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+import top.leavesmc.leaves.command.CommandArgumentType;
+
+import java.util.List;
+
+public class AttackSelfAction extends BotAction {
+
+    public AttackSelfAction() {
+        super("attack_self", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new AttackSelfAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        List<Entity> entities = bot.level().getEntities((Entity) null, bot.getBoundingBox(), Predicates.alwaysTrue());
+        if (!entities.isEmpty()) {
+            for (int i = 0; i < entities.size(); i++) {
+                Entity entity = entities.get(i);
+                if (entity != bot) {
+                    bot.attack(entity);
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/BreakBlockAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/BreakBlockAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..2a3ca671b43fec658bf5cd8a6eb08b476a766c29
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/BreakBlockAction.java
@@ -0,0 +1,104 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.block.state.BlockState;
+import org.bukkit.block.Block;
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+import top.leavesmc.leaves.command.CommandArgumentType;
+
+import java.util.List;
+
+public class BreakBlockAction extends BotAction {
+
+    public BreakBlockAction() {
+        super("break", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new BreakBlockAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public BotAction setTickDelay(int tickDelay) {
+        super.setTickDelay(0);
+        this.delay = tickDelay;
+        return this;
+    }
+
+    private int delay = 0;
+    private int nowDelay = 0;
+
+    private BlockPos lastPos = null;
+    private int destroyProgressTime = 0;
+    private int lastSentState = -1;
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        if (nowDelay > 0) {
+            nowDelay--;
+            return false;
+        }
+
+        Block block = bot.getBukkitEntity().getTargetBlockExact(5);
+        if (block != null) {
+            BlockPos pos = ((CraftBlock) block).getPosition();
+
+            if (lastPos == null || !lastPos.equals(pos)) {
+                lastPos = pos;
+                destroyProgressTime = 0;
+                lastSentState = -1;
+            }
+
+            BlockState iblockdata = bot.level().getBlockState(pos);
+            if (!iblockdata.isAir()) {
+                bot.punch();
+
+                if (iblockdata.getDestroyProgress(bot, bot.level(), pos) >= 1.0F) {
+                    bot.gameMode.destroyAndAck(pos, 0, "insta mine");
+                    bot.level().destroyBlockProgress(bot.getId(), pos, -1);
+                    bot.updateItemInMainHand();
+                    finalBreak();
+                    return true;
+                }
+
+                float damage = this.incrementDestroyProgress(bot, iblockdata, pos);
+                if (damage >= 1.0F) {
+                    bot.gameMode.destroyAndAck(pos, 0, "destroyed");
+                    bot.level().destroyBlockProgress(bot.getId(), pos, -1);
+                    bot.updateItemInMainHand();
+                    finalBreak();
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private void finalBreak() {
+        lastPos = null;
+        destroyProgressTime = 0;
+        lastSentState = -1;
+        nowDelay = delay;
+    }
+
+    private float incrementDestroyProgress(ServerBot bot, @NotNull BlockState state, BlockPos pos) {
+        float f = state.getDestroyProgress(bot, bot.level(), pos) * (float) (++destroyProgressTime);
+        int k = (int) (f * 10.0F);
+
+        if (k != lastSentState) {
+            bot.level().destroyBlockProgress(bot.getId(), pos, k);
+            lastSentState = k;
+        }
+
+        return f;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/CraftCustomBotAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/CraftCustomBotAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..89a361249179d7a0a84768e715ced05aafc13272
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/CraftCustomBotAction.java
@@ -0,0 +1,48 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+import top.leavesmc.leaves.entity.botaction.CustomBotAction;
+
+public class CraftCustomBotAction extends BotAction {
+
+    private final CustomBotAction realAction;
+
+    public CraftCustomBotAction(String name, @NotNull CustomBotAction realAction) {
+        super(name, new CommandArgument().setAllTabComplete(realAction.getTabComplete()));
+        this.realAction = realAction;
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    public BotAction getNew(@NotNull Player player, String[] args) {
+        CustomBotAction newRealAction = realAction.getNew(player, args);
+        if (newRealAction != null) {
+            return new CraftCustomBotAction(getName(), newRealAction);
+        }
+        return null;
+    }
+
+    @Override
+    public int getNumber() {
+        return realAction.getNumber();
+    }
+
+    @Override
+    public int getTickDelay() {
+        return realAction.getTickDelay();
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        return realAction.doTick(bot.getBukkitPlayer());
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/DropAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/DropAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..cc72960b8490a72aca5db3e834c71f97e3742f7d
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/DropAction.java
@@ -0,0 +1,26 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+
+public class DropAction extends BotAction {
+
+    public DropAction() {
+        super("drop", new CommandArgument());
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return this.setTickDelay(0).setNumber(1);
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        bot.dropAll();
+        return true;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/FishAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/FishAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..d92ea54770bce73c2f10f1ebcb0dff5b9532e0e9
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/FishAction.java
@@ -0,0 +1,70 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.projectile.FishingHook;
+import net.minecraft.world.item.FishingRodItem;
+import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+import top.leavesmc.leaves.command.CommandArgumentType;
+
+import java.util.List;
+
+public class FishAction extends BotAction {
+
+    public FishAction() {
+        super("fish", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new FishAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public BotAction setTickDelay(int tickDelay) {
+        super.setTickDelay(0);
+        this.delay = tickDelay;
+        return this;
+    }
+
+    private int delay = 0;
+    private int nowDelay = 0;
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        if (nowDelay > 0) {
+            nowDelay--;
+            return false;
+        }
+
+        ItemStack mainHand = bot.getMainHandItem();
+        if (mainHand == ItemStack.EMPTY || mainHand.getItem().getClass() != FishingRodItem.class) {
+            return false;
+        }
+
+        FishingHook fishingHook = bot.fishing;
+        if (fishingHook != null) {
+            if (fishingHook.currentState == FishingHook.FishHookState.HOOKED_IN_ENTITY) {
+                mainHand.use(bot.level(), bot, InteractionHand.MAIN_HAND);
+                nowDelay = 20;
+                return false;
+            }
+            if (fishingHook.nibble > 0) {
+                mainHand.use(bot.level(), bot, InteractionHand.MAIN_HAND);
+                nowDelay = delay;
+                return true;
+            }
+        } else {
+            mainHand.use(bot.level(), bot, InteractionHand.MAIN_HAND);
+        }
+
+        return false;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/JumpAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/JumpAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..d99f667992e45e85c0fe0bd74682d563fe1315eb
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/JumpAction.java
@@ -0,0 +1,35 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+import top.leavesmc.leaves.command.CommandArgumentType;
+
+import java.util.List;
+
+public class JumpAction extends BotAction {
+
+    public JumpAction() {
+        super("jump", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new JumpAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        if (bot.onGround()) {
+            bot.jumpFromGround();
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/LayAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/LayAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..b1d8e632686709c2425794ed28b694cf38984ab7
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/LayAction.java
@@ -0,0 +1,30 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Pose;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+
+public class LayAction extends BotAction {
+
+    public LayAction() {
+        super("lay", new CommandArgument());
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return this.setTickDelay(0).setNumber(1);
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        if (bot.isShiftKeyDown()) {
+            bot.setShiftKeyDown(false);
+        }
+        bot.setPose(bot.getPose() != Pose.FALL_FLYING ? Pose.FALL_FLYING : Pose.STANDING);
+        return true;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/LookAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/LookAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..5432e61c156a1a6d49dcf4b24e3bcfcc6c1aa7bb
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/LookAction.java
@@ -0,0 +1,49 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.util.Vector;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+import top.leavesmc.leaves.command.CommandArgumentType;
+
+import java.util.List;
+
+public class LookAction extends BotAction {
+
+    public LookAction() {
+        super("look", new CommandArgument(CommandArgumentType.DOUBLE, CommandArgumentType.DOUBLE, CommandArgumentType.DOUBLE));
+        setTabComplete(0, List.of("<X>"));
+        setTabComplete(1, List.of("<Y>"));
+        setTabComplete(2, List.of("<Z>"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        Vector pos = result.readVector();
+        if (pos != null) {
+            return new LookAction().setPos(pos).setTickDelay(0).setNumber(1);
+        } else {
+            return null;
+        }
+    }
+
+    private Vector pos;
+
+    public LookAction setPos(Vector pos) {
+        if (pos != null) {
+            this.pos = pos;
+            return this;
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        bot.look(pos.subtract(bot.getLocation().toVector()), false);
+        return true;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/RotateAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/RotateAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..1e5be54b33467591924cb2400639fb593dc50ec6
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/RotateAction.java
@@ -0,0 +1,33 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+
+public class RotateAction extends BotAction {
+
+    public RotateAction() {
+        super("rotate", new CommandArgument());
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new RotateAction().setPlayer(player).setTickDelay(0).setNumber(1);
+    }
+
+    private ServerPlayer player;
+
+    public RotateAction setPlayer(ServerPlayer player) {
+        this.player = player;
+        return this;
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        bot.faceLocation(player.getBukkitEntity().getLocation());
+        return true;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/SneakAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/SneakAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..250416464daae6f824f02b4fd339a4c1b7a2fb67
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/SneakAction.java
@@ -0,0 +1,28 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Pose;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+
+public class SneakAction extends BotAction {
+
+    public SneakAction() {
+        super("sneak", new CommandArgument());
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return this.setTickDelay(0).setNumber(1);
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        bot.setShiftKeyDown(!bot.isShiftKeyDown());
+        bot.setPose(bot.isShiftKeyDown() ? Pose.CROUCHING : Pose.STANDING);
+        return true;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/StopAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/StopAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..36d199269afc46783b0815e3887842cd82b6e813
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/StopAction.java
@@ -0,0 +1,26 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+
+public class StopAction extends BotAction {
+
+    public StopAction() {
+        super("stop", new CommandArgument());
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return this.setTickDelay(0).setNumber(0);
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        this.setCancel(true);
+        return true;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/SwimAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/SwimAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..58c815bd0ebfd455fcf4903ee5ced6b81be00982
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/SwimAction.java
@@ -0,0 +1,26 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+
+public class SwimAction extends BotAction {
+
+    public SwimAction() {
+        super("swim", new CommandArgument());
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return this.setTickDelay(0).setNumber(1);
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        bot.waterSwim = !bot.waterSwim;
+        return true;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/UseItemAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/UseItemAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..5dc3fbf8e62ccffc8291962c835a568efd65d7af
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/UseItemAction.java
@@ -0,0 +1,33 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.InteractionHand;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+import top.leavesmc.leaves.command.CommandArgumentType;
+
+import java.util.List;
+
+public class UseItemAction extends BotAction {
+
+    public UseItemAction() {
+        super("use", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new UseItemAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        bot.punch();
+        bot.updateItemInMainHand();
+        return bot.getInventory().getSelected().use(bot.level(), bot, InteractionHand.MAIN_HAND).getResult().consumesAction();
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/UseItemOnAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/UseItemOnAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..75488ee2cb25190f9c16898759c57f233d240c4c
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/UseItemOnAction.java
@@ -0,0 +1,40 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.level.ClipContext;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+import top.leavesmc.leaves.command.CommandArgumentType;
+
+import java.util.List;
+
+public class UseItemOnAction extends BotAction {
+
+    public UseItemOnAction() {
+        super("use_on", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new UseItemOnAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        HitResult result = bot.getRayTrace(4, ClipContext.Fluid.NONE);
+        if (result.getType() == HitResult.Type.BLOCK) {
+            bot.punch();
+            bot.updateItemInMainHand();
+            return bot.gameMode.useItemOn(bot, bot.level(), bot.getItemInHand(InteractionHand.MAIN_HAND), InteractionHand.MAIN_HAND, (BlockHitResult) result).consumesAction();
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/bot/agent/actions/UseItemToAction.java b/src/main/java/top/leavesmc/leaves/bot/agent/actions/UseItemToAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..cc8689ee726144f220e4ccc5cd418b79a29b79ab
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/bot/agent/actions/UseItemToAction.java
@@ -0,0 +1,38 @@
+package top.leavesmc.leaves.bot.agent.actions;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.phys.EntityHitResult;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.command.CommandArgument;
+import top.leavesmc.leaves.command.CommandArgumentResult;
+import top.leavesmc.leaves.command.CommandArgumentType;
+
+import java.util.List;
+
+public class UseItemToAction extends BotAction {
+
+    public UseItemToAction() {
+        super("use_to", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new UseItemToAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        EntityHitResult result = bot.getTargetEntity(3);
+        if (result != null) {
+            bot.punch();
+            bot.updateItemInMainHand();
+            return result.getEntity().interact(bot, InteractionHand.MAIN_HAND).consumesAction();
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/command/CommandArgument.java b/src/main/java/top/leavesmc/leaves/command/CommandArgument.java
new file mode 100644
index 0000000000000000000000000000000000000000..134c6d26acc612bf6142ae6b6885a0ee53d2a196
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/command/CommandArgument.java
@@ -0,0 +1,49 @@
+package top.leavesmc.leaves.command;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class CommandArgument {
+
+    private final List<CommandArgumentType<?>> argumentTypes;
+    private final List<List<String>> tabComplete;
+
+    public CommandArgument(CommandArgumentType<?>... argumentTypes) {
+        this.argumentTypes = List.of(argumentTypes);
+        this.tabComplete = new ArrayList<>();
+        for (int i = 0; i < argumentTypes.length; i++) {
+            tabComplete.add(new ArrayList<>());
+        }
+    }
+
+    public List<String> tabComplete(int n) {
+        if (tabComplete.size() > n) {
+            return tabComplete.get(n);
+        } else {
+            return List.of();
+        }
+    }
+
+    public CommandArgument setTabComplete(int index, List<String> list) {
+        tabComplete.set(index, list);
+        return this;
+    }
+
+    public CommandArgument setAllTabComplete(List<List<String>> tabComplete) {
+        this.tabComplete.clear();
+        this.tabComplete.addAll(tabComplete);
+        return this;
+    }
+
+    public CommandArgumentResult parse(int index, String @NotNull [] args) {
+        Object[] result = new Object[argumentTypes.size()];
+        Arrays.fill(result, null);
+        for (int i = index, j = 0; i < args.length && j < result.length; i++, j++) {
+            result[j] = argumentTypes.get(j).pasre(args[i]);
+        }
+        return new CommandArgumentResult(new ArrayList<>(Arrays.asList(result)));
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/command/CommandArgumentResult.java b/src/main/java/top/leavesmc/leaves/command/CommandArgumentResult.java
new file mode 100644
index 0000000000000000000000000000000000000000..39e90dcff0de259373d7955021c29397c2cc15d5
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/command/CommandArgumentResult.java
@@ -0,0 +1,61 @@
+package top.leavesmc.leaves.command;
+
+import net.minecraft.core.BlockPos;
+import org.bukkit.util.Vector;
+
+import java.util.List;
+import java.util.Objects;
+
+public class CommandArgumentResult {
+
+    private final List<Object> result;
+
+    public CommandArgumentResult(List<Object> result) {
+        this.result = result;
+    }
+
+    public Integer readInt(int def) {
+        return Objects.requireNonNullElse(read(Integer.class), def);
+    }
+
+    public Double readDouble(double def) {
+        return Objects.requireNonNullElse(read(Double.class), def);
+    }
+
+    public String readString(String def) {
+        return Objects.requireNonNullElse(read(String.class), def);
+    }
+
+    public BlockPos readPos() {
+        Integer[] pos = {read(Integer.class), read(Integer.class), read(Integer.class)};
+        for (Integer po : pos) {
+            if (po == null) {
+                return null;
+            }
+        }
+        return new BlockPos(pos[0], pos[1], pos[2]);
+    }
+
+    public Vector readVector() {
+        Double[] pos = {read(Double.class), read(Double.class), read(Double.class)};
+        for (Double po : pos) {
+            if (po == null) {
+                return null;
+            }
+        }
+        return new Vector(pos[0], pos[1], pos[2]);
+    }
+
+    public <T> T read(Class<T> tClass) {
+        if (result.isEmpty()) {
+            return null;
+        }
+
+        Object obj = result.remove(0);
+        if (tClass.isInstance(obj)) {
+            return tClass.cast(obj);
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/command/CommandArgumentType.java b/src/main/java/top/leavesmc/leaves/command/CommandArgumentType.java
new file mode 100644
index 0000000000000000000000000000000000000000..edf12195c7224ca2fb5d3c2ac3fcf485d3049d07
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/command/CommandArgumentType.java
@@ -0,0 +1,37 @@
+package top.leavesmc.leaves.command;
+
+import org.jetbrains.annotations.NotNull;
+
+public abstract class CommandArgumentType<E> {
+
+    public static final CommandArgumentType<Integer> INTEGER = new CommandArgumentType<>() {
+        @Override
+        public Integer pasre(@NotNull String arg) {
+            try {
+                return Integer.parseInt(arg);
+            } catch (NumberFormatException e) {
+                return null;
+            }
+        }
+    };
+
+    public static final CommandArgumentType<Double> DOUBLE = new CommandArgumentType<>() {
+        @Override
+        public Double pasre(@NotNull String arg) {
+            try {
+                return Double.parseDouble(arg);
+            } catch (NumberFormatException e) {
+                return null;
+            }
+        }
+    };
+
+    public static final CommandArgumentType<String> STRING = new CommandArgumentType<>() {
+        @Override
+        public String pasre(@NotNull String arg) {
+            return arg;
+        }
+    };
+
+    public abstract E pasre(@NotNull String arg);
+}
diff --git a/src/main/java/top/leavesmc/leaves/command/LeavesCommand.java b/src/main/java/top/leavesmc/leaves/command/LeavesCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..78d3df6a15057d42466c266226f308a070f560ac
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/command/LeavesCommand.java
@@ -0,0 +1,116 @@
+package top.leavesmc.leaves.command;
+
+import io.papermc.paper.command.CommandUtil;
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.Util;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginManager;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.command.subcommands.UpdateCommand;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+public final class LeavesCommand extends Command {
+    static final String BASE_PERM = "bukkit.command.leaves.";
+    // subcommand label -> subcommand
+    private static final Map<String, LeavesSubcommand> SUBCOMMANDS = Util.make(() -> {
+        final Map<Set<String>, LeavesSubcommand> commands = new HashMap<>();
+        commands.put(Set.of("update"), new UpdateCommand());
+
+        return commands.entrySet().stream()
+            .flatMap(entry -> entry.getKey().stream().map(s -> Map.entry(s, entry.getValue())))
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    });
+    private static final Set<String> COMPLETABLE_SUBCOMMANDS = SUBCOMMANDS.entrySet().stream().filter(entry -> entry.getValue().tabCompletes()).map(Map.Entry::getKey).collect(Collectors.toSet());
+
+    public LeavesCommand(final String name) {
+        super(name);
+        this.description = "Leaves related commands";
+        this.usageMessage = "/leaves [" + String.join(" | ", SUBCOMMANDS.keySet()) + "]";
+        final List<String> permissions = new ArrayList<>();
+        permissions.add("bukkit.command.leaves");
+        permissions.addAll(SUBCOMMANDS.keySet().stream().map(s -> BASE_PERM + s).toList());
+        this.setPermission(String.join(";", permissions));
+        final PluginManager pluginManager = Bukkit.getServer().getPluginManager();
+        for (final String perm : permissions) {
+            pluginManager.addPermission(new Permission(perm, PermissionDefault.OP));
+        }
+    }
+
+    private static boolean testPermission(final CommandSender sender, final String permission) {
+        if (sender.hasPermission(BASE_PERM + permission) || sender.hasPermission("bukkit.command.leaves")) {
+            return true;
+        }
+        sender.sendMessage(Bukkit.permissionMessage());
+        return false;
+    }
+
+    @NotNull
+
+    @Override
+    public List<String> tabComplete(final @NotNull CommandSender sender, final @NotNull String alias, final String[] args, final @Nullable Location location) throws IllegalArgumentException {
+        if (args.length <= 1) {
+            return CommandUtil.getListMatchingLast(sender, args, COMPLETABLE_SUBCOMMANDS);
+        }
+
+        final @Nullable Pair<String, LeavesSubcommand> subCommand = resolveCommand(args[0]);
+        if (subCommand != null) {
+            return subCommand.second().tabComplete(sender, subCommand.first(), Arrays.copyOfRange(args, 1, args.length));
+        }
+
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean execute(final @NotNull CommandSender sender, final @NotNull String commandLabel, final String[] args) {
+        if (!testPermission(sender)) {
+            return true;
+        }
+
+        if (args.length == 0) {
+            sender.sendMessage(text("Usage: " + this.usageMessage, RED));
+            return false;
+        }
+        final Pair<String, LeavesSubcommand> subCommand = resolveCommand(args[0]);
+
+        if (subCommand == null) {
+            sender.sendMessage(text("Usage: " + this.usageMessage, RED));
+            return false;
+        }
+
+        if (!testPermission(sender, subCommand.first())) {
+            return true;
+        }
+        final String[] choppedArgs = Arrays.copyOfRange(args, 1, args.length);
+        return subCommand.second().execute(sender, subCommand.first(), choppedArgs);
+    }
+
+    @Nullable
+    private static Pair<String, LeavesSubcommand> resolveCommand(String label) {
+        label = label.toLowerCase(Locale.ENGLISH);
+        LeavesSubcommand subCommand = SUBCOMMANDS.get(label);
+
+        if (subCommand != null) {
+            return Pair.of(label, subCommand);
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/command/LeavesSubcommand.java b/src/main/java/top/leavesmc/leaves/command/LeavesSubcommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..7ba1b573c8e49cc0838c25bc26687d14841a9e7f
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/command/LeavesSubcommand.java
@@ -0,0 +1,18 @@
+package top.leavesmc.leaves.command;
+
+import org.bukkit.command.CommandSender;
+
+import java.util.Collections;
+import java.util.List;
+
+public interface LeavesSubcommand {
+    boolean execute(CommandSender sender, String subCommand, String[] args);
+
+    default List<String> tabComplete(final CommandSender sender, final String subCommand, final String[] args) {
+        return Collections.emptyList();
+    }
+
+    default boolean tabCompletes() {
+        return true;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/command/NoBlockUpdateCommand.java b/src/main/java/top/leavesmc/leaves/command/NoBlockUpdateCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..0eacacf05033289ad2dec9f759d359c956321798
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/command/NoBlockUpdateCommand.java
@@ -0,0 +1,37 @@
+package top.leavesmc.leaves.command;
+
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.LeavesConfig;
+
+import java.util.List;
+
+public class NoBlockUpdateCommand extends Command {
+
+    private static boolean noBlockUpdate = false;
+
+    public NoBlockUpdateCommand(@NotNull String name) {
+        super(name);
+        this.description = "No Block Update Command";
+        this.usageMessage = "/blockupdate";
+        this.setPermission("bukkit.command.blockupdate");
+    }
+
+    @Override
+    public @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args) throws IllegalArgumentException {
+        return List.of();
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, @NotNull String[] args) {
+        if (!testPermission(sender)) return true;
+        noBlockUpdate = !noBlockUpdate;
+        sender.sendMessage("Block update status: " + !noBlockUpdate);
+        return true;
+    }
+
+    public static boolean isNoBlockUpdate() {
+        return LeavesConfig.noBlockUpdateCommand && noBlockUpdate;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/command/subcommands/UpdateCommand.java b/src/main/java/top/leavesmc/leaves/command/subcommands/UpdateCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..62068c4378e855f61c0e26ee3273212535224c2f
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/command/subcommands/UpdateCommand.java
@@ -0,0 +1,22 @@
+package top.leavesmc.leaves.command.subcommands;
+
+import org.bukkit.ChatColor;
+import org.bukkit.command.CommandSender;
+import top.leavesmc.leaves.command.LeavesSubcommand;
+import top.leavesmc.leaves.util.LeavesUpdateHelper;
+
+public class UpdateCommand implements LeavesSubcommand {
+
+    @Override
+    public boolean execute(CommandSender sender, String subCommand, String[] args) {
+        sender.sendMessage(ChatColor.GRAY + "Trying to update Leaves, see the console for more info.");
+        LeavesUpdateHelper.initAutoUpdate();
+        LeavesUpdateHelper.tryUpdateLeaves();
+        return true;
+    }
+
+    @Override
+    public boolean tabCompletes() {
+        return false;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/entity/CraftBot.java b/src/main/java/top/leavesmc/leaves/entity/CraftBot.java
new file mode 100644
index 0000000000000000000000000000000000000000..e30ce391f638778fc805ca75287917af99b37443
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/entity/CraftBot.java
@@ -0,0 +1,60 @@
+package top.leavesmc.leaves.entity;
+
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.Actions;
+import top.leavesmc.leaves.bot.agent.BotAction;
+import top.leavesmc.leaves.entity.botaction.LeavesBotAction;
+
+public class CraftBot extends CraftPlayer implements Bot {
+
+    public CraftBot(CraftServer server, ServerBot entity) {
+        super(server, entity);
+    }
+
+    @Override
+    public String getSkinName() {
+        return getHandle().createState.skinName;
+    }
+
+    @Override
+    public @NotNull String getRealName() {
+        return getHandle().createState.getRealName();
+    }
+
+    @Override
+    public boolean setBotAction(@NotNull String action, @NotNull Player player, @NotNull String[] args) {
+        BotAction botAction = Actions.getForName(action);
+        if (botAction != null) {
+            BotAction newAction = botAction.getNew(((CraftPlayer) player).getHandle(), botAction.getArgument().parse(0, args));
+            if (newAction != null) {
+                getHandle().setBotAction(newAction);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public boolean setBotAction(@NotNull LeavesBotAction action, @NotNull Player player, @NotNull String[] args) {
+        return setBotAction(action.getName(), player, args);
+    }
+
+    @Override
+    public ServerBot getHandle() {
+        return (ServerBot) entity;
+    }
+
+    public void setHandle(final ServerBot entity) {
+        super.setHandle(entity);
+    }
+
+    @Override
+    public String toString() {
+        return "CraftBot{" + "name=" + getName() + '}';
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/entity/CraftBotManager.java b/src/main/java/top/leavesmc/leaves/entity/CraftBotManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..df5796bfa333a287ccd486be9a9cdae4ca5dc757
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/entity/CraftBotManager.java
@@ -0,0 +1,93 @@
+package top.leavesmc.leaves.entity;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Lists;
+import org.bukkit.Location;
+import org.bukkit.util.Consumer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.bot.agent.Actions;
+import top.leavesmc.leaves.bot.agent.actions.CraftCustomBotAction;
+import top.leavesmc.leaves.entity.botaction.CustomBotAction;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.UUID;
+
+public class CraftBotManager implements BotManager {
+
+    private final Collection<Bot> botViews = Collections.unmodifiableList(Lists.transform(ServerBot.getBots(), new Function<ServerBot, CraftBot>() {
+        @Override
+        public CraftBot apply(ServerBot bot) {
+            return bot.getBukkitEntity();
+        }
+    }));
+
+    @Override
+    public @Nullable Bot getBot(@NotNull UUID uuid) {
+        return ServerBot.getBot(uuid).getBukkitPlayer();
+    }
+
+    @Override
+    public @Nullable Bot getBot(@NotNull String name) {
+        return ServerBot.getBot(name).getBukkitPlayer();
+    }
+
+    @Override
+    public @Nullable Bot createBot(@NotNull String name, @NotNull String realName, @Nullable String[] skin, @Nullable String skinName, @NotNull Location location) {
+        ServerBot bot = new ServerBot.BotCreateState(location, name, realName, skinName, skin).createSync();
+        if (bot != null) {
+            return bot.getBukkitPlayer();
+        }
+        return null;
+    }
+
+    @Override
+    public void createBot(@NotNull String name, @Nullable String skinName, @NotNull Location location, Consumer<Bot> consumer) {
+        new ServerBot.BotCreateState(location, name, skinName).createAsync((serverBot -> {
+            consumer.accept(serverBot.getBukkitPlayer());
+        }));
+    }
+
+    @Override
+    public void removeBot(@NotNull String name) {
+        ServerBot bot = ServerBot.getBot(name);
+        if (bot != null) {
+            bot.die(bot.damageSources().fellOutOfWorld());
+        }
+    }
+
+    @Override
+    public void removeBot(@NotNull UUID uuid) {
+        ServerBot bot = ServerBot.getBot(uuid);
+        if (bot != null) {
+            bot.die(bot.damageSources().fellOutOfWorld());
+        }
+    }
+
+    @Override
+    public void removeAllBots() {
+        ServerBot.removeAllBot();
+    }
+
+    @Override
+    public void saveOrRemoveAllBots() {
+        ServerBot.saveOrRemoveAllBot();
+    }
+
+    @Override
+    public Collection<Bot> getBots() {
+        return botViews;
+    }
+
+    @Override
+    public boolean registerCustomBotAction(String name, CustomBotAction action) {
+        return Actions.register(new CraftCustomBotAction(name, action));
+    }
+
+    @Override
+    public boolean unregisterCustomBotAction(String name) {
+        return Actions.unregister(name);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/lithium/common/util/Pos.java b/src/main/java/top/leavesmc/leaves/lithium/common/util/Pos.java
new file mode 100644
index 0000000000000000000000000000000000000000..f1650846d080ab743aa324a3fe94447e2b3d7ece
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/lithium/common/util/Pos.java
@@ -0,0 +1,104 @@
+
+package top.leavesmc.leaves.lithium.common.util;
+
+import net.minecraft.core.SectionPos;
+import net.minecraft.world.level.LevelHeightAccessor;
+
+public class Pos {
+
+    public static class BlockCoord {
+        public static int getYSize(LevelHeightAccessor view) {
+            return view.getHeight();
+        }
+
+        public static int getMinY(LevelHeightAccessor view) {
+            return view.getMinBuildHeight();
+        }
+
+        public static int getMaxYInclusive(LevelHeightAccessor view) {
+            return view.getMaxBuildHeight() - 1;
+        }
+
+        public static int getMaxYExclusive(LevelHeightAccessor view) {
+            return view.getMaxBuildHeight();
+        }
+
+        public static int getMaxInSectionCoord(int sectionCoord) {
+            return 15 + getMinInSectionCoord(sectionCoord);
+        }
+
+        public static int getMaxYInSectionIndex(LevelHeightAccessor view, int sectionIndex) {
+            return getMaxInSectionCoord(SectionYCoord.fromSectionIndex(view, sectionIndex));
+        }
+
+        public static int getMinInSectionCoord(int sectionCoord) {
+            return SectionPos.sectionToBlockCoord(sectionCoord);
+        }
+
+        public static int getMinYInSectionIndex(LevelHeightAccessor view, int sectionIndex) {
+            return getMinInSectionCoord(SectionYCoord.fromSectionIndex(view, sectionIndex));
+        }
+    }
+
+    public static class ChunkCoord {
+        public static int fromBlockCoord(int blockCoord) {
+            return SectionPos.blockToSectionCoord(blockCoord);
+        }
+
+        public static int fromBlockSize(int i) {
+            return i >> 4; //same method as fromBlockCoord, just be clear about coord/size semantic difference
+        }
+    }
+
+    public static class SectionYCoord {
+        public static int getNumYSections(LevelHeightAccessor view) {
+            return view.getSectionsCount();
+        }
+
+        public static int getMinYSection(LevelHeightAccessor view) {
+            return view.getMinSection();
+        }
+
+        public static int getMaxYSectionInclusive(LevelHeightAccessor view) {
+            return view.getMaxSection() - 1;
+        }
+
+        public static int getMaxYSectionExclusive(LevelHeightAccessor view) {
+            return view.getMaxSection();
+        }
+
+        public static int fromSectionIndex(LevelHeightAccessor view, int sectionCoord) {
+            return sectionCoord + SectionYCoord.getMinYSection(view);
+        }
+
+        public static int fromBlockCoord(int blockCoord) {
+            return SectionPos.blockToSectionCoord(blockCoord);
+        }
+    }
+
+    public static class SectionYIndex {
+        public static int getNumYSections(LevelHeightAccessor view) {
+            return view.getSectionsCount();
+        }
+
+        public static int getMinYSectionIndex(LevelHeightAccessor view) {
+            return 0;
+        }
+
+        public static int getMaxYSectionIndexInclusive(LevelHeightAccessor view) {
+            return view.getSectionsCount() - 1;
+        }
+
+        public static int getMaxYSectionIndexExclusive(LevelHeightAccessor view) {
+            return view.getSectionsCount();
+        }
+
+        public static int fromSectionCoord(LevelHeightAccessor view, int sectionCoord) {
+            return sectionCoord - SectionYCoord.getMinYSection(view);
+        }
+
+        public static int fromBlockCoord(LevelHeightAccessor view, int blockCoord) {
+            return fromSectionCoord(view, SectionPos.blockToSectionCoord(blockCoord));
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/lithium/common/util/collections/Object2BooleanCacheTable.java b/src/main/java/top/leavesmc/leaves/lithium/common/util/collections/Object2BooleanCacheTable.java
new file mode 100644
index 0000000000000000000000000000000000000000..45232059b188b5f072e28c4cdf05929005972220
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/lithium/common/util/collections/Object2BooleanCacheTable.java
@@ -0,0 +1,62 @@
+package top.leavesmc.leaves.lithium.common.util.collections;
+
+import it.unimi.dsi.fastutil.HashCommon;
+import net.minecraft.util.Mth;
+
+import java.util.function.Predicate;
+
+// Powered by Gale(https://github.com/GaleMC/Gale)
+
+/**
+ * A lossy hashtable implementation that stores a mapping between an object and a boolean.
+ * <p>
+ * Any hash collisions will result in an overwrite: this is safe because the correct value can always be recomputed,
+ * given that the given operator is deterministic.
+ * <p>
+ * This implementation is safe to use from multiple threads
+ */
+public final class Object2BooleanCacheTable<T> {
+
+    private final int mask;
+    private final Node<T>[] nodes;
+    private final Predicate<T> operator;
+
+    @SuppressWarnings("unchecked")
+    public Object2BooleanCacheTable(int capacity, Predicate<T> operator) {
+        int capacity1 = Mth.smallestEncompassingPowerOfTwo(capacity);
+        this.mask = capacity1 - 1;
+        this.nodes = (Node<T>[]) new Node[capacity1];
+        this.operator = operator;
+    }
+
+    private static <T> int hash(T key) {
+        return HashCommon.mix(key.hashCode());
+    }
+
+    public boolean get(T key) {
+        int idx = hash(key) & this.mask;
+
+        Node<T> node = this.nodes[idx];
+        if (node != null && key.equals(node.key)) {
+            return node.value;
+        }
+
+        boolean test = this.operator.test(key);
+        this.nodes[idx] = new Node<>(key, test);
+
+        return test;
+    }
+
+    static class Node<T> {
+
+        final T key;
+        final boolean value;
+
+        Node(T key, boolean value) {
+            this.key = key;
+            this.value = value;
+        }
+
+    }
+
+}
diff --git a/src/main/java/top/leavesmc/leaves/lithium/common/world/chunk/LithiumHashPalette.java b/src/main/java/top/leavesmc/leaves/lithium/common/world/chunk/LithiumHashPalette.java
new file mode 100644
index 0000000000000000000000000000000000000000..6f71d2028dd047b9b4cc5fd6cb2857cc5b46e668
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/lithium/common/world/chunk/LithiumHashPalette.java
@@ -0,0 +1,196 @@
+package top.leavesmc.leaves.lithium.common.world.chunk;
+
+import com.google.common.collect.ImmutableList;
+import it.unimi.dsi.fastutil.HashCommon;
+import it.unimi.dsi.fastutil.objects.Reference2IntMap;
+import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.function.Predicate;
+
+import net.minecraft.core.IdMap;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.world.level.chunk.Palette;
+import net.minecraft.world.level.chunk.PaletteResize;
+import org.jetbrains.annotations.NotNull;
+
+import static it.unimi.dsi.fastutil.Hash.FAST_LOAD_FACTOR;
+
+// Powered by Gale(https://github.com/GaleMC/Gale)
+
+/**
+ * Generally provides better performance over the vanilla {@link net.minecraft.world.level.chunk.HashMapPalette} when calling
+ * {@link LithiumHashPalette#idFor(Object)} through using a faster backing map and reducing pointer chasing.
+ */
+public class LithiumHashPalette<T> implements Palette<T> {
+    private static final int ABSENT_VALUE = -1;
+
+    private final IdMap<T> idList;
+    private final PaletteResize<T> resizeHandler;
+    private final int indexBits;
+
+    private final Reference2IntMap<T> table;
+    private T[] entries;
+    private int size = 0;
+
+    public LithiumHashPalette(IdMap<T> idList, PaletteResize<T> resizeHandler, int indexBits, T[] entries, Reference2IntMap<T> table, int size) {
+        this.idList = idList;
+        this.resizeHandler = resizeHandler;
+        this.indexBits = indexBits;
+        this.entries = entries;
+        this.table = table;
+        this.size = size;
+    }
+
+    public LithiumHashPalette(IdMap<T> idList, int bits, PaletteResize<T> resizeHandler, @NotNull List<T> list) {
+        this(idList, bits, resizeHandler);
+
+        for (T t : list) {
+            this.addEntry(t);
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    public LithiumHashPalette(IdMap<T> idList, int bits, PaletteResize<T> resizeHandler) {
+        this.idList = idList;
+        this.indexBits = bits;
+        this.resizeHandler = resizeHandler;
+
+        int capacity = 1 << bits;
+
+        this.entries = (T[]) new Object[capacity];
+        this.table = new Reference2IntOpenHashMap<>(capacity, FAST_LOAD_FACTOR);
+        this.table.defaultReturnValue(ABSENT_VALUE);
+    }
+
+    @Override
+    public int idFor(@NotNull T obj) {
+        int id = this.table.getInt(obj);
+
+        if (id == ABSENT_VALUE) {
+            id = this.computeEntry(obj);
+        }
+
+        return id;
+    }
+
+    @Override
+    public boolean maybeHas(@NotNull Predicate<T> predicate) {
+        for (int i = 0; i < this.size; ++i) {
+            if (predicate.test(this.entries[i])) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private int computeEntry(T obj) {
+        int id = this.addEntry(obj);
+
+        if (id >= 1 << this.indexBits) {
+            if (this.resizeHandler == null) {
+                throw new IllegalStateException("Cannot grow");
+            } else {
+                id = this.resizeHandler.onResize(this.indexBits + 1, obj);
+            }
+        }
+
+        return id;
+    }
+
+    private int addEntry(T obj) {
+        int nextId = this.size;
+
+        if (nextId >= this.entries.length) {
+            this.resize(this.size);
+        }
+
+        this.table.put(obj, nextId);
+        this.entries[nextId] = obj;
+
+        this.size++;
+
+        return nextId;
+    }
+
+    private void resize(int neededCapacity) {
+        this.entries = Arrays.copyOf(this.entries, HashCommon.nextPowerOfTwo(neededCapacity + 1));
+    }
+
+    @Override
+    public T valueFor(int id) {
+        T[] entries = this.entries;
+
+        if (id >= 0 && id < entries.length) {
+            return entries[id];
+        }
+
+        return null;
+    }
+
+    @Override
+    public void read(FriendlyByteBuf buf) {
+        this.clear();
+
+        int entryCount = buf.readVarInt();
+
+        for (int i = 0; i < entryCount; ++i) {
+            this.addEntry(this.idList.byId(buf.readVarInt()));
+        }
+    }
+
+    @Override
+    public void write(FriendlyByteBuf buf) {
+        int size = this.size;
+        buf.writeVarInt(size);
+
+        for (int i = 0; i < size; ++i) {
+            buf.writeVarInt(this.idList.getId(this.valueFor(i)));
+        }
+    }
+
+    @Override
+    public int getSerializedSize() {
+        int size = FriendlyByteBuf.getVarIntSize(this.size);
+
+        for (int i = 0; i < this.size; ++i) {
+            size += FriendlyByteBuf.getVarIntSize(this.idList.getId(this.valueFor(i)));
+        }
+
+        return size;
+    }
+
+    @Override
+    public int getSize() {
+        return this.size;
+    }
+
+    @NotNull
+    @Override
+    public Palette<T> copy() {
+        return new LithiumHashPalette<>(this.idList, this.resizeHandler, this.indexBits, this.entries.clone(), new Reference2IntOpenHashMap<>(this.table), this.size);
+    }
+
+    private void clear() {
+        Arrays.fill(this.entries, null);
+        this.table.clear();
+        this.size = 0;
+    }
+
+    public List<T> getElements() {
+        ImmutableList.Builder<T> builder = new ImmutableList.Builder<>();
+        for (T entry : this.entries) {
+            if (entry != null) {
+                builder.add(entry);
+            }
+        }
+        return builder.build();
+    }
+
+    public static <A> Palette<A> create(int bits, IdMap<A> idList, PaletteResize<A> listener, List<A> list) {
+        return new LithiumHashPalette<>(idList, bits, listener, list);
+    }
+}
+
diff --git a/src/main/java/top/leavesmc/leaves/profile/LeavesAuthenticationService.java b/src/main/java/top/leavesmc/leaves/profile/LeavesAuthenticationService.java
new file mode 100644
index 0000000000000000000000000000000000000000..ee10e314a7e1af28ea008123f75caee26515b692
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/profile/LeavesAuthenticationService.java
@@ -0,0 +1,103 @@
+package top.leavesmc.leaves.profile;
+
+import com.destroystokyo.paper.profile.PaperAuthenticationService;
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.exceptions.AuthenticationException;
+import com.mojang.authlib.exceptions.AuthenticationUnavailableException;
+import com.mojang.authlib.exceptions.InsufficientPrivilegesException;
+import com.mojang.authlib.exceptions.InvalidCredentialsException;
+import com.mojang.authlib.exceptions.UserBannedException;
+import com.mojang.authlib.exceptions.UserMigratedException;
+import com.mojang.authlib.minecraft.MinecraftSessionService;
+import com.mojang.authlib.properties.PropertyMap;
+import com.mojang.authlib.yggdrasil.response.HasJoinedMinecraftServerResponse;
+import com.mojang.authlib.yggdrasil.response.ProfileSearchResultsResponse;
+import com.mojang.util.UUIDTypeAdapter;
+import org.apache.commons.lang3.StringUtils;
+
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.net.Proxy;
+import java.net.URL;
+import java.util.UUID;
+
+public class LeavesAuthenticationService extends PaperAuthenticationService {
+
+    protected final Gson gson;
+
+    public LeavesAuthenticationService(Proxy proxy) {
+        super(proxy);
+
+        GsonBuilder builder = new GsonBuilder();
+        builder.registerTypeAdapter(GameProfile.class, new GameProfileSerializer());
+        builder.registerTypeAdapter(PropertyMap.class, new PropertyMap.Serializer());
+        builder.registerTypeAdapter(UUID.class, new UUIDTypeAdapter());
+        builder.registerTypeAdapter(ProfileSearchResultsResponse.class, new ProfileSearchResultsResponse.Serializer());
+        this.gson = builder.create();
+    }
+
+    @Override
+    public MinecraftSessionService createMinecraftSessionService() {
+        return new LeavesMinecraftSessionService(this, this.environment);
+    }
+
+    public HasJoinedMinecraftServerResponse makeHasJoinResponse(URL url) throws AuthenticationException {
+        try {
+            String jsonResult = performGetRequest(url, null);
+            HasJoinedMinecraftServerResponse result = this.gson.fromJson(jsonResult, HasJoinedMinecraftServerResponse.class);
+            if (result == null) {
+                return null;
+            } else if (StringUtils.isNotBlank(result.getError())) {
+                if ("UserMigratedException".equals(result.getCause())) {
+                    throw new UserMigratedException(result.getErrorMessage());
+                } else if ("ForbiddenOperationException".equals(result.getError())) {
+                    throw new InvalidCredentialsException(result.getErrorMessage());
+                } else if ("InsufficientPrivilegesException".equals(result.getError())) {
+                    throw new InsufficientPrivilegesException(result.getErrorMessage());
+                } else if ("multiplayer.access.banned".equals(result.getError())) {
+                    throw new UserBannedException();
+                } else {
+                    throw new AuthenticationException(result.getErrorMessage());
+                }
+            } else {
+                return result;
+            }
+        } catch (IllegalStateException | JsonParseException | IOException var7) {
+            throw new AuthenticationUnavailableException("Cannot contact authentication server", var7);
+        }
+    }
+
+    public static class GameProfileSerializer implements JsonSerializer<GameProfile>, JsonDeserializer<GameProfile> {
+        private GameProfileSerializer() {
+        }
+
+        public GameProfile deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
+            JsonObject object = (JsonObject)json;
+            UUID id = object.has("id") ? (UUID)context.deserialize(object.get("id"), UUID.class) : null;
+            String name = object.has("name") ? object.getAsJsonPrimitive("name").getAsString() : null;
+            return new GameProfile(id, name);
+        }
+
+        public JsonElement serialize(GameProfile src, Type typeOfSrc, JsonSerializationContext context) {
+            JsonObject result = new JsonObject();
+            if (src.getId() != null) {
+                result.add("id", context.serialize(src.getId()));
+            }
+
+            if (src.getName() != null) {
+                result.addProperty("name", src.getName());
+            }
+
+            return result;
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/profile/LeavesMinecraftSessionService.java b/src/main/java/top/leavesmc/leaves/profile/LeavesMinecraftSessionService.java
new file mode 100644
index 0000000000000000000000000000000000000000..fc39aa3c97118a3796f10951145f17ad696a79cb
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/profile/LeavesMinecraftSessionService.java
@@ -0,0 +1,101 @@
+package top.leavesmc.leaves.profile;
+
+import com.destroystokyo.paper.profile.PaperMinecraftSessionService;
+import com.google.gson.JsonParseException;
+import com.mojang.authlib.Environment;
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.HttpAuthenticationService;
+import com.mojang.authlib.exceptions.AuthenticationException;
+import com.mojang.authlib.exceptions.AuthenticationUnavailableException;
+import com.mojang.authlib.exceptions.InsufficientPrivilegesException;
+import com.mojang.authlib.exceptions.InvalidCredentialsException;
+import com.mojang.authlib.exceptions.UserBannedException;
+import com.mojang.authlib.exceptions.UserMigratedException;
+import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
+import com.mojang.authlib.yggdrasil.response.HasJoinedMinecraftServerResponse;
+import com.mojang.authlib.yggdrasil.response.Response;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.apache.commons.lang3.StringUtils;
+import top.leavesmc.leaves.LeavesConfig;
+import top.leavesmc.leaves.bot.ServerBot;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class LeavesMinecraftSessionService extends PaperMinecraftSessionService {
+
+    protected LeavesMinecraftSessionService(LeavesAuthenticationService authenticationService, Environment environment) {
+        super(authenticationService, environment);
+    }
+
+    private static List<URL> extraYggdrasilList = List.of();
+
+    public static void initExtraYggdrasilList() {
+        List<URL> list = new ArrayList<>();
+        for (String str : LeavesConfig.extraYggdrasilServiceList) {
+            list.add(HttpAuthenticationService.constantURL(str + "/sessionserver/session/minecraft/hasJoined"));
+        }
+        extraYggdrasilList = Collections.unmodifiableList(list);
+    }
+
+    @Override
+    public LeavesAuthenticationService getAuthenticationService() {
+        return (LeavesAuthenticationService) super.getAuthenticationService();
+    }
+
+    @Override
+    public GameProfile hasJoinedServer(GameProfile user, String serverId, InetAddress address) throws AuthenticationUnavailableException {
+        GameProfile result = super.hasJoinedServer(user, serverId, address); // mojang result
+
+        ServerPlayer player = MinecraftServer.getServer().getPlayerList().getPlayerByName(user.getName());
+        if (player != null && !(player instanceof ServerBot)) {
+            return null; // if it has same name, return null
+        }
+
+        if (LeavesConfig.extraYggdrasilService && result == null) {
+            Map<String, Object> arguments = new HashMap<>();
+            arguments.put("username", user.getName());
+            arguments.put("serverId", serverId);
+            if (address != null) {
+                arguments.put("ip", address.getHostAddress());
+            }
+
+            GameProfile cache = null;
+            if (LeavesConfig.extraYggdrasilLoginProtect) {
+                cache = MinecraftServer.getServer().services.profileCache().getProfileIfCached(user.getName());
+            }
+
+            for (URL checkUrl : extraYggdrasilList) {
+                URL url = HttpAuthenticationService.concatenateURL(checkUrl, HttpAuthenticationService.buildQuery(arguments));
+
+                try {
+                    HasJoinedMinecraftServerResponse response = this.getAuthenticationService().makeHasJoinResponse(url);
+                    if (response != null && response.getId() != null) {
+                        if (LeavesConfig.extraYggdrasilLoginProtect && cache != null) {
+                            if (response.getId() != cache.getId()) {
+                                continue;
+                            }
+                        }
+                        result = new GameProfile(response.getId(), user.getName());
+                        if (response.getProperties() != null) {
+                            result.getProperties().putAll(response.getProperties());
+                        }
+                        return result;
+                    }
+                } catch (AuthenticationUnavailableException var8) {
+                    throw var8;
+                } catch (AuthenticationException ignored) {
+                }
+            }
+        }
+
+        return result;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/AppleSkinProtocol.java b/src/main/java/top/leavesmc/leaves/protocol/AppleSkinProtocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..6f0b2140df822dc86e360837780768f2f5203041
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/AppleSkinProtocol.java
@@ -0,0 +1,95 @@
+package top.leavesmc.leaves.protocol;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.food.FoodData;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.LeavesConfig;
+import top.leavesmc.leaves.util.ProtocolUtils;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+
+public class AppleSkinProtocol {
+
+    public static final String PROTOCOL_ID = "appleskin";
+
+    private static final ResourceLocation SATURATION_KEY = id("saturation_sync");
+    private static final ResourceLocation EXHAUSTION_KEY = id("exhaustion_sync");
+
+    private static final Map<UUID, Float> previousSaturationLevels = new HashMap<>();
+    private static final Map<UUID, Float> previousExhaustionLevels = new HashMap<>();
+
+    private static final float MINIMUM_EXHAUSTION_CHANGE_THRESHOLD = 0.01F;
+
+    private static final Set<ServerPlayer> players = new HashSet<>();
+
+    @Contract("_ -> new")
+    public static @NotNull ResourceLocation id(String path) {
+        return new ResourceLocation(PROTOCOL_ID, path);
+    }
+
+    public static void enableAllPlayer() {
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().getPlayers()) {
+            onPlayerLoggedIn(player);
+        }
+    }
+
+    public static void disableAllPlayer() {
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().getPlayers()) {
+            onPlayerLoggedOut(player);
+        }
+    }
+
+    public static void onPlayerLoggedIn(@NotNull ServerPlayer player) {
+        if (LeavesConfig.appleskinProtocol) {
+            players.add(player);
+            resetPlayerData(player);
+        }
+    }
+
+    public static void onPlayerLoggedOut(@NotNull ServerPlayer player) {
+        if (LeavesConfig.appleskinProtocol) {
+            players.remove(player);
+            resetPlayerData(player);
+        }
+    }
+
+    private static void resetPlayerData(@NotNull ServerPlayer player) {
+        previousExhaustionLevels.remove(player.getUUID());
+        previousSaturationLevels.remove(player.getUUID());
+    }
+
+    public static void tick() {
+        if (LeavesConfig.appleskinProtocol) {
+            for (ServerPlayer player : players) {
+                FoodData data = player.getFoodData();
+
+                float saturation = data.getSaturationLevel();
+                Float previousSaturation = previousSaturationLevels.get(player.getUUID());
+                if (previousSaturation == null || saturation != previousSaturation) {
+                    FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+                    buf.writeFloat(saturation);
+                    ProtocolUtils.sendPayloadPacket(player, SATURATION_KEY, buf);
+                    previousSaturationLevels.put(player.getUUID(), saturation);
+                }
+
+                float exhaustion = data.getExhaustionLevel();
+                Float previousExhaustion = previousExhaustionLevels.get(player.getUUID());
+                if (previousExhaustion == null || Math.abs(exhaustion - previousExhaustion) >= MINIMUM_EXHAUSTION_CHANGE_THRESHOLD) {
+                    FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+                    buf.writeFloat(exhaustion);
+                    ProtocolUtils.sendPayloadPacket(player, EXHAUSTION_KEY, buf);
+                    previousExhaustionLevels.put(player.getUUID(), exhaustion);
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/BBORProtocol.java b/src/main/java/top/leavesmc/leaves/protocol/BBORProtocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..95469919589b48e1c672b6b9dc884118d33d86de
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/BBORProtocol.java
@@ -0,0 +1,216 @@
+package top.leavesmc.leaves.protocol;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Registry;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.levelgen.structure.BoundingBox;
+import net.minecraft.world.level.levelgen.structure.Structure;
+import net.minecraft.world.level.levelgen.structure.StructurePiece;
+import net.minecraft.world.level.levelgen.structure.StructureStart;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.LeavesConfig;
+import top.leavesmc.leaves.util.ProtocolUtils;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.stream.Collectors;
+
+public class BBORProtocol {
+
+    public static final String PROTOCOL_ID = "bbor";
+
+    // send
+    private static final ResourceLocation INITIALIZE_CLIENT = id("initialize");
+    private static final ResourceLocation ADD_BOUNDING_BOX = id("add_bounding_box_v2");
+    private static final ResourceLocation STRUCTURE_LIST_SYNC = id("structure_list_sync_v1");
+    // call
+    public static final ResourceLocation SUBSCRIBE = id("subscribe");
+    private static final Map<Integer, ServerPlayer> players = new ConcurrentHashMap<>();
+    private static final Map<Integer, Set<BBoundingBox>> playerBoundingBoxesCache = new HashMap<>();
+    private static final Map<ResourceLocation, Map<BBoundingBox, Set<BBoundingBox>>> dimensionCache = new ConcurrentHashMap<>();
+
+    private static final ServerLevel OVERWORLD = MinecraftServer.getServer().overworld();
+
+    @Contract("_ -> new")
+    public static @NotNull ResourceLocation id(String path) {
+        return new ResourceLocation(PROTOCOL_ID, path);
+    }
+
+    public static void onPlayerLoggedIn(@NotNull ServerPlayer player) {
+        if (LeavesConfig.bborProtocol) {
+            FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+            buf.writeLong(OVERWORLD.getSeed());
+            buf.writeInt(OVERWORLD.levelData.getXSpawn());
+            buf.writeInt(OVERWORLD.levelData.getZSpawn());
+            ProtocolUtils.sendPayloadPacket(player, INITIALIZE_CLIENT, buf);
+
+            final Registry<Structure> structureRegistry = player.server.registryAccess().registryOrThrow(Registries.STRUCTURE);
+            final Set<String> structureIds = structureRegistry.entrySet().stream().map(e -> e.getKey().location().toString()).collect(Collectors.toSet());
+            FriendlyByteBuf buf1 = new FriendlyByteBuf(Unpooled.buffer());
+            buf1.writeVarInt(structureIds.size());
+            structureIds.forEach(buf1::writeUtf);
+            ProtocolUtils.sendPayloadPacket(player, STRUCTURE_LIST_SYNC, buf1);
+        }
+    }
+
+    public static void onPlayerSubscribed(@NotNull ServerPlayer player) {
+        if (LeavesConfig.bborProtocol) {
+            players.put(player.getId(), player);
+            sendBoundingToPlayer(player.getId(), player);
+        }
+    }
+
+    public static void onDataPackReload() {
+        if (LeavesConfig.bborProtocol) {
+            for (var playerEntry : players.entrySet()) {
+                final Registry<Structure> structureRegistry = MinecraftServer.getServer().registryAccess().registryOrThrow(Registries.STRUCTURE);
+                final Set<String> structureIds = structureRegistry.entrySet().stream().map(e -> e.getKey().location().toString()).collect(Collectors.toSet());
+                FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+                buf.writeVarInt(structureIds.size());
+                structureIds.forEach(buf::writeUtf);
+                ProtocolUtils.sendPayloadPacket(playerEntry.getValue(), STRUCTURE_LIST_SYNC, buf);
+            }
+        }
+    }
+
+    public static void onPlayerLoggedOut(@NotNull ServerPlayer player) {
+        if (LeavesConfig.bborProtocol) {
+            players.remove(player.getId());
+            playerBoundingBoxesCache.remove(player.getId());
+        }
+    }
+
+    public static void onChunkLoaded(@NotNull LevelChunk chunk) {
+        if (LeavesConfig.bborProtocol) {
+            Map<String, StructureStart> structures = new HashMap<>();
+            final Registry<Structure> structureFeatureRegistry = chunk.getLevel().registryAccess().registryOrThrow(Registries.STRUCTURE);
+            for (var es : chunk.getAllStarts().entrySet()) {
+                final var optional = structureFeatureRegistry.getResourceKey(es.getKey());
+                optional.ifPresent(key -> structures.put(key.location().toString(), es.getValue()));
+            }
+            if (structures.size() > 0) {
+                onStructuresLoaded(chunk.getLevel().dimension().location(), structures);
+            }
+        }
+    }
+
+    public static void onStructuresLoaded(@NotNull ResourceLocation dimensionID, @NotNull Map<String, StructureStart> structures) {
+        Map<BBoundingBox, Set<BBoundingBox>> cache = getOrCreateCache(dimensionID);
+        for (var entry : structures.entrySet()) {
+            StructureStart structureStart = entry.getValue();
+            if (structureStart == null) {
+                return;
+            }
+
+            String type = "structure:" + entry.getKey();
+            BoundingBox bb = structureStart.getBoundingBox();
+            BBoundingBox boundingBox = buildStructure(bb, type);
+            if (cache.containsKey(boundingBox)) {
+                return;
+            }
+
+            Set<BBoundingBox> structureBoundingBoxes = new HashSet<>();
+            for (StructurePiece structureComponent : structureStart.getPieces()) {
+                structureBoundingBoxes.add(buildStructure(structureComponent.getBoundingBox(), type));
+            }
+            cache.put(boundingBox, structureBoundingBoxes);
+        }
+    }
+
+    private static @NotNull BBoundingBox buildStructure(@NotNull BoundingBox bb, String type) {
+        BlockPos min = new BlockPos(bb.minX(), bb.minY(), bb.minZ());
+        BlockPos max = new BlockPos(bb.maxX(), bb.maxY(), bb.maxZ());
+        return new BBoundingBox(type, min, max);
+    }
+
+    private static void sendBoundingToPlayer(int id, ServerPlayer player) {
+        for (var entry : dimensionCache.entrySet()) {
+            if (entry.getValue() == null) {
+                return;
+            }
+
+            Set<BBoundingBox> playerBoundingBoxes = playerBoundingBoxesCache.computeIfAbsent(id, k -> new HashSet<>());
+            Map<BBoundingBox, Set<BBoundingBox>> boundingBoxMap = entry.getValue();
+            for (BBoundingBox key : boundingBoxMap.keySet()) {
+                if (playerBoundingBoxes.contains(key)) {
+                    continue;
+                }
+
+                Set<BBoundingBox> boundingBoxes = boundingBoxMap.get(key);
+
+                FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+                buf.writeResourceLocation(entry.getKey());
+                key.serialize(buf);
+                if (boundingBoxes != null && boundingBoxes.size() > 1) {
+                    for (BBoundingBox box : boundingBoxes) {
+                        box.serialize(buf);
+                    }
+                }
+                ProtocolUtils.sendPayloadPacket(player, ADD_BOUNDING_BOX, buf);
+                playerBoundingBoxes.add(key);
+            }
+        }
+    }
+
+    public static void tick() {
+        if (LeavesConfig.bborProtocol) {
+            for (var playerEntry : players.entrySet()) {
+                sendBoundingToPlayer(playerEntry.getKey(), playerEntry.getValue());
+            }
+        }
+    }
+
+    public static void initAllPlayer() {
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().getPlayers()) {
+            onPlayerLoggedIn(player);
+        }
+    }
+
+    public static void loggedOutAllPlayer() {
+        players.clear();
+        playerBoundingBoxesCache.clear();
+        for (var cache : dimensionCache.values()) {
+            cache.clear();
+        }
+        dimensionCache.clear();
+    }
+
+    private static Map<BBoundingBox, Set<BBoundingBox>> getOrCreateCache(ResourceLocation dimensionId) {
+        return dimensionCache.computeIfAbsent(dimensionId, dt -> new ConcurrentHashMap<>());
+    }
+
+    private record BBoundingBox(String type, BlockPos min, BlockPos max) {
+
+        public void serialize(@NotNull FriendlyByteBuf buf) {
+            buf.writeChar('S');
+            buf.writeInt(type.hashCode());
+            buf.writeVarInt(min.getX()).writeVarInt(min.getY()).writeVarInt(min.getZ());
+            buf.writeVarInt(max.getX()).writeVarInt(max.getY()).writeVarInt(max.getZ());
+        }
+
+        @Override
+        public int hashCode() {
+            return combineHashCodes(min.hashCode(), max.hashCode());
+        }
+
+        private static int combineHashCodes(int @NotNull ... hashCodes) {
+            final int prime = 31;
+            int result = 0;
+            for (int hashCode : hashCodes) {
+                result = prime * result + hashCode;
+            }
+            return result;
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/CarpetAlternativeBlockPlacement.java b/src/main/java/top/leavesmc/leaves/protocol/CarpetAlternativeBlockPlacement.java
new file mode 100644
index 0000000000000000000000000000000000000000..848c380ed3d9755bab680b1e244a6024110bc383
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/CarpetAlternativeBlockPlacement.java
@@ -0,0 +1,101 @@
+package top.leavesmc.leaves.protocol;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.item.context.BlockPlaceContext;
+import net.minecraft.world.level.block.BedBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.ComparatorBlock;
+import net.minecraft.world.level.block.RepeaterBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.ComparatorMode;
+import net.minecraft.world.level.block.state.properties.DirectionProperty;
+import net.minecraft.world.level.block.state.properties.Half;
+import net.minecraft.world.level.block.state.properties.Property;
+import net.minecraft.world.level.block.state.properties.SlabType;
+import net.minecraft.world.phys.Vec3;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
+
+public class CarpetAlternativeBlockPlacement {
+
+    @Nullable
+    public static BlockState alternativeBlockPlacement(@NotNull Block block, @NotNull BlockPlaceContext context) {
+        Vec3 hitPos = context.getClickLocation();
+        BlockPos blockPos = context.getClickedPos();
+        double relativeHitX = hitPos.x - blockPos.getX();
+        BlockState state = block.getStateForPlacement(context);
+
+        if (relativeHitX < 2 || state == null) {
+            return null;
+        }
+
+        DirectionProperty directionProp = getFirstDirectionProperty(state);
+        int protocolValue = ((int) relativeHitX - 2) / 2;
+
+        if (directionProp != null) {
+            Direction origFacing = state.getValue(directionProp);
+            Direction facing = origFacing;
+            int facingIndex = protocolValue & 0xF;
+
+            if (facingIndex == 6) {
+                facing = facing.getOpposite();
+            } else if (facingIndex <= 5) {
+                facing = Direction.from3DDataValue(facingIndex);
+            }
+
+            if (!directionProp.getPossibleValues().contains(facing)) {
+                facing = context.getPlayer().getDirection().getOpposite();
+            }
+
+            if (facing != origFacing && directionProp.getPossibleValues().contains(facing)) {
+                if (state.getBlock() instanceof BedBlock) {
+                    BlockPos headPos = blockPos.relative(facing);
+
+                    if (!context.getLevel().getBlockState(headPos).canBeReplaced(context)) {
+                        return null;
+                    }
+                }
+
+                state = state.setValue(directionProp, facing);
+            }
+        } else if (state.hasProperty(BlockStateProperties.AXIS)) {
+            Direction.Axis axis = Direction.Axis.VALUES[protocolValue % 3];
+            state = state.setValue(BlockStateProperties.AXIS, axis);
+        }
+
+        protocolValue &= 0xFFFFFFF0;
+
+        if (protocolValue >= 16) {
+            if (block instanceof RepeaterBlock) {
+                Integer delay = (protocolValue / 16);
+
+                if (RepeaterBlock.DELAY.getPossibleValues().contains(delay)) {
+                    state = state.setValue(RepeaterBlock.DELAY, delay);
+                }
+            } else if (protocolValue == 16) {
+                if (block instanceof ComparatorBlock) {
+                    state = state.setValue(ComparatorBlock.MODE, ComparatorMode.SUBTRACT);
+                } else if (state.hasProperty(BlockStateProperties.HALF) && state.getValue(BlockStateProperties.HALF) == Half.BOTTOM) {
+                    state = state.setValue(BlockStateProperties.HALF, Half.TOP);
+                } else if (state.hasProperty(BlockStateProperties.SLAB_TYPE) && state.getValue(BlockStateProperties.SLAB_TYPE) == SlabType.BOTTOM) {
+                    state = state.setValue(BlockStateProperties.SLAB_TYPE, SlabType.TOP);
+                }
+            }
+        }
+
+        return state;
+    }
+
+    @Nullable
+    public static DirectionProperty getFirstDirectionProperty(@NotNull BlockState state) {
+        for (Property<?> prop : state.getProperties()) {
+            if (prop instanceof DirectionProperty) {
+                return (DirectionProperty) prop;
+            }
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/CarpetServerProtocol.java b/src/main/java/top/leavesmc/leaves/protocol/CarpetServerProtocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..9c13a3b7d2321dc59beec6e220790d1df0728c16
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/CarpetServerProtocol.java
@@ -0,0 +1,96 @@
+package top.leavesmc.leaves.protocol;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.game.ServerboundCustomPayloadPacket;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.LeavesConfig;
+import top.leavesmc.leaves.LeavesLogger;
+import top.leavesmc.leaves.util.ProtocolUtils;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class CarpetServerProtocol {
+
+    public static final String PROTOCOL_ID = "carpet";
+
+    private static final ResourceLocation HELLO_ID = id("hello"); // why?????????????
+
+    private static final int HI = 69;
+    private static final int HELLO = 420;
+    private static final int DATA = 1;
+
+    @Contract("_ -> new")
+    public static @NotNull ResourceLocation id(String path) {
+        return new ResourceLocation(PROTOCOL_ID, path);
+    }
+
+    public static void handlePacket(ServerPlayer player, @NotNull ServerboundCustomPayloadPacket packet) {
+        if (packet.identifier.equals(HELLO_ID)) {
+            FriendlyByteBuf data = packet.data;
+            if (data.readVarInt() == HELLO) {
+                handleHello(player, data);
+            }
+        }
+    }
+
+    private static void handleHello(@NotNull ServerPlayer player, @NotNull FriendlyByteBuf data) {
+        LeavesLogger.LOGGER.info("Player " + player.getScoreboardName() + " joined with carpet " + data.readUtf(64));
+        ProtocolUtils.sendPayloadPacket(player, HELLO_ID, CarpetRules.buildBuf());
+    }
+
+    public static void onPlayerJoin(ServerPlayer player) {
+        if (LeavesConfig.leavesCarpetSupport) {
+            FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+            buf.writeVarInt(HI).writeUtf("leaves-carpet-1.0.0");
+            ProtocolUtils.sendPayloadPacket(player, HELLO_ID, buf);
+        }
+    }
+
+    public static class CarpetRules {
+
+        private static final Map<String, CarpetRule> rules = new HashMap<>();
+
+        @NotNull
+        public static FriendlyByteBuf buildBuf() {
+            FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+            buf.writeVarInt(1);
+
+            CompoundTag rulesNbt = new CompoundTag();
+            rules.values().forEach(rule -> rule.writeNBT(rulesNbt));
+
+            CompoundTag tag = new CompoundTag();
+            tag.put("Rules", rulesNbt);
+            buf.writeNbt(tag);
+
+            return buf;
+        }
+
+        public static void register(CarpetRule rule) {
+            rules.put(rule.name, rule);
+        }
+    }
+
+    public record CarpetRule(String identifier, String name, String value) {
+
+        @NotNull
+        @Contract("_, _, _ -> new")
+        public static CarpetRule of(String identifier, String name, boolean value) {
+            return new CarpetRule(identifier, name, Boolean.toString(value));
+        }
+
+        public void writeNBT(@NotNull CompoundTag rules) {
+            CompoundTag rule = new CompoundTag();
+            rule.putString("Value", value);
+            rule.putString("Manager", identifier);
+            rule.putString("Rule", name);
+            rules.put(name, rule);
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/JadeProtocol.java b/src/main/java/top/leavesmc/leaves/protocol/JadeProtocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d366c44e1809d5d046017e08542453acc920520
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/JadeProtocol.java
@@ -0,0 +1,579 @@
+package top.leavesmc.leaves.protocol;
+
+import com.google.common.cache.Cache;
+import com.google.common.cache.CacheBuilder;
+import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ListMultimap;
+import com.google.common.collect.Lists;
+import com.mojang.authlib.GameProfile;
+import io.netty.buffer.Unpooled;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.protocol.game.ServerboundCustomPayloadPacket;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.Container;
+import net.minecraft.world.LockCode;
+import net.minecraft.world.Nameable;
+import net.minecraft.world.effect.MobEffectCategory;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.entity.AgeableMob;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.OwnableEntity;
+import net.minecraft.world.entity.animal.Animal;
+import net.minecraft.world.entity.animal.Chicken;
+import net.minecraft.world.entity.animal.allay.Allay;
+import net.minecraft.world.entity.animal.frog.Tadpole;
+import net.minecraft.world.entity.animal.horse.AbstractHorse;
+import net.minecraft.world.entity.vehicle.ContainerEntity;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.BaseCommandBlock;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.ChestBlock;
+import net.minecraft.world.level.block.ChiseledBookShelfBlock;
+import net.minecraft.world.level.block.entity.AbstractFurnaceBlockEntity;
+import net.minecraft.world.level.block.entity.BaseContainerBlockEntity;
+import net.minecraft.world.level.block.entity.BeehiveBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntityType;
+import net.minecraft.world.level.block.entity.BrewingStandBlockEntity;
+import net.minecraft.world.level.block.entity.ChestBlockEntity;
+import net.minecraft.world.level.block.entity.ChiseledBookShelfBlockEntity;
+import net.minecraft.world.level.block.entity.CommandBlockEntity;
+import net.minecraft.world.level.block.entity.ComparatorBlockEntity;
+import net.minecraft.world.level.block.entity.EnderChestBlockEntity;
+import net.minecraft.world.level.block.entity.HopperBlockEntity;
+import net.minecraft.world.level.block.entity.JukeboxBlockEntity;
+import net.minecraft.world.level.block.entity.LecternBlockEntity;
+import net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.phys.BlockHitResult;
+import org.apache.commons.lang3.mutable.MutableInt;
+import org.apache.logging.log4j.util.TriConsumer;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import top.leavesmc.leaves.LeavesConfig;
+import top.leavesmc.leaves.LeavesLogger;
+import top.leavesmc.leaves.util.ProtocolUtils;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Objects;
+import java.util.UUID;
+import java.util.concurrent.ExecutionException;
+import java.util.function.Function;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
+
+public class JadeProtocol {
+
+    public static final String PROTOCOL_ID = "jade";
+
+    // send
+    public static final ResourceLocation PACKET_SERVER_PING = id("server_ping");
+    public static final ResourceLocation PACKET_RECEIVE_DATA = id("receive_data");
+    // call
+    public static final ResourceLocation PACKET_REQUEST_ENTITY = id("request_entity");
+    public static final ResourceLocation PACKET_REQUEST_TILE = id("request_tile");
+
+    private static final HierarchyLookup<IJadeProvider<Entity>> entityDataProviders = new HierarchyLookup<>(Entity.class);
+    private static final HierarchyLookup<IJadeProvider<BlockEntity>> tileDataProviders = new HierarchyLookup<>(BlockEntity.class);
+
+    public static final int MAX_DISTANCE_SQR = 900;
+
+    @Contract("_ -> new")
+    public static @NotNull ResourceLocation id(String path) {
+        return new ResourceLocation(PROTOCOL_ID, path);
+    }
+
+    public static void onPlayerJoin(ServerPlayer player) {
+        if (LeavesConfig.jadeProtocol) {
+            FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+            buf.writeUtf("{}");
+            ProtocolUtils.sendPayloadPacket(player, PACKET_SERVER_PING, buf);
+        }
+    }
+
+    public static void enableAllPlayer() {
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+            onPlayerJoin(player);
+        }
+    }
+
+    private static final Map<ResourceLocation, TriConsumer<MinecraftServer, ServerPlayer, FriendlyByteBuf>> globalReceivers = new HashMap<>();
+
+    private static void registerGlobalReceiver(ResourceLocation identifier, TriConsumer<MinecraftServer, ServerPlayer, FriendlyByteBuf> consumer) {
+        globalReceivers.put(identifier, consumer);
+    }
+
+    public static void handlePacket(MinecraftServer server, ServerPlayer player, @NotNull ServerboundCustomPayloadPacket packet) {
+        globalReceivers.getOrDefault(packet.identifier, ((server1, player1, buf) -> LeavesLogger.LOGGER.severe("NullPotion"))).accept(server, player, packet.data);
+    }
+
+    public static void init() {
+        entityDataProviders.register(Entity.class, ((data, player, world, entity, showDetails) -> {
+            UUID ownerUUID = null;
+            if (entity instanceof OwnableEntity) {
+                ownerUUID = ((OwnableEntity) entity).getOwnerUUID();
+            } else if (entity instanceof AbstractHorse) {
+                ownerUUID = ((AbstractHorse) entity).getOwnerUUID();
+            }
+            if (ownerUUID != null) {
+                MinecraftServer.getServer().getProfileCache().get(ownerUUID).map(GameProfile::getName).ifPresent(name -> data.putString("OwnerName", name));
+            }
+        }));
+        entityDataProviders.register(LivingEntity.class, ((data, player, world, entity, showDetails) -> {
+            LivingEntity living = (LivingEntity) entity;
+            Collection<MobEffectInstance> effects = living.getActiveEffects();
+            if (effects.isEmpty()) {
+                return;
+            }
+            ListTag list = new ListTag();
+            for (MobEffectInstance effect : effects) {
+                CompoundTag compound = new CompoundTag();
+                compound.putString("Name", effect.getDescriptionId());
+                compound.putInt("Amplifier", effect.getAmplifier());
+                int duration = Math.min(32767, effect.getDuration());
+                compound.putInt("Duration", duration);
+                compound.putBoolean("Bad", effect.getEffect().getCategory() == MobEffectCategory.HARMFUL);
+                list.add(compound);
+            }
+            data.put("Potions", list);
+        }));
+        entityDataProviders.register(AgeableMob.class, ((data, player, world, entity, showDetails) -> {
+            int time = -((AgeableMob) entity).getAge();
+            if (time > 0) {
+                data.putInt("GrowingTime", time);
+            }
+        }));
+        entityDataProviders.register(Tadpole.class, ((data, player, world, entity, showDetails) -> {
+            int time = ((Tadpole) entity).getTicksLeftUntilAdult();
+            if (time > 0) {
+                data.putInt("GrowingTime", time);
+            }
+        }));
+        entityDataProviders.register(Animal.class, ((data, player, world, entity, showDetails) -> {
+            int time = ((Animal) entity).getAge();
+            if (time > 0) {
+                data.putInt("BreedingCD", time);
+            }
+        }));
+        entityDataProviders.register(Allay.class, ((data, player, world, entity, showDetails) -> {
+            int time = 0;
+            Allay allay = (Allay) entity;
+            if (allay.duplicationCooldown > 0 && allay.duplicationCooldown < Integer.MAX_VALUE) {
+                time = (int) allay.duplicationCooldown;
+            }
+            if (time > 0) {
+                data.putInt("BreedingCD", time);
+            }
+        }));
+        entityDataProviders.register(Chicken.class, ((data, player, world, entity, showDetails) -> {
+            data.putInt("NextEgg", ((Chicken) entity).eggTime / 20);
+        }));
+        entityDataProviders.register(Entity.class, ((tag, player, world, object, showDetails) -> {
+            var groups = getGroups(player, (ServerLevel) world, object, showDetails);
+            if (groups != null) {
+                if (ViewGroup.saveList(tag, "JadeItemStorage", groups, item -> {
+                    CompoundTag itemTag = new CompoundTag();
+                    int count = item.getCount();
+                    if (count > 64) item.setCount(1);
+                    item.save(itemTag);
+                    if (count > 64) itemTag.putInt("NewCount", count);
+                    return itemTag;
+                })) {
+                    tag.putString("JadeItemStorageUid", EntityType.getKey(object.getType()).toString());
+                } else {
+                    if (object instanceof ContainerEntity containerEntity && containerEntity.getLootTable() != null) {
+                        tag.putBoolean("Loot", true);
+                    }
+                }
+            }
+        }));
+
+        tileDataProviders.register(BrewingStandBlockEntity.class, ((data, player, world, object, showDetails) -> {
+            if (object instanceof BrewingStandBlockEntity brewingStand) {
+                CompoundTag compound = new CompoundTag();
+                compound.putInt("Time", brewingStand.brewTime);
+                compound.putInt("Fuel", brewingStand.fuel);
+                data.put("BrewingStand", compound);
+            }
+        }));
+        tileDataProviders.register(BeehiveBlockEntity.class, ((data, player, world, object, showDetails) -> {
+            data.getAllKeys().clear();
+            BeehiveBlockEntity beehive = (BeehiveBlockEntity) object;
+            data.putByte("Bees", (byte) beehive.getOccupantCount());
+            data.putBoolean("Full", beehive.isFull());
+        }));
+        tileDataProviders.register(CommandBlockEntity.class, ((data, player, world, object, showDetails) -> {
+            if (object == null || !player.canUseGameMasterBlocks()) {
+                return;
+            }
+            BaseCommandBlock logic = ((CommandBlockEntity) object).getCommandBlock();
+            String command = logic.getCommand();
+            if (command.isEmpty()) {
+                return;
+            }
+            if (command.length() > 40) {
+                command = command.substring(0, 37) + "...";
+            }
+            data.putString("Command", command);
+        }));
+        tileDataProviders.register(JukeboxBlockEntity.class, ((data, player, world, object, showDetails) -> {
+            if (object instanceof JukeboxBlockEntity jukebox) {
+                ItemStack stack = jukebox.getFirstItem();
+                if (!stack.isEmpty()) {
+                    data.put("Record", stack.save(new CompoundTag()));
+                }
+            }
+        }));
+        tileDataProviders.register(LecternBlockEntity.class, ((data, player, world, object, showDetails) -> {
+            ItemStack stack = ((LecternBlockEntity) object).getBook();
+            if (!stack.isEmpty()) {
+                if (stack.hasCustomHoverName() || stack.getItem() != Items.WRITABLE_BOOK) {
+                    data.put("Book", stack.save(new CompoundTag()));
+                }
+            }
+        }));
+        tileDataProviders.register(ComparatorBlockEntity.class, ((data, player, world, object, showDetails) -> {
+            data.putInt("Signal", ((ComparatorBlockEntity) object).getOutputSignal());
+        }));
+        tileDataProviders.register(HopperBlockEntity.class, ((data, player, world, object, showDetails) -> {
+            BlockState state = object.getBlockState();
+            if (state.hasProperty(BlockStateProperties.ENABLED) && !state.getValue(BlockStateProperties.ENABLED)) {
+                data.putBoolean("HopperLocked", true);
+            }
+        }));
+        tileDataProviders.register(AbstractFurnaceBlockEntity.class, ((data, player, world, object, showDetails) -> {
+            AbstractFurnaceBlockEntity furnace = (AbstractFurnaceBlockEntity) object;
+            ListTag items = new ListTag();
+            for (int i = 0; i < 3; i++) {
+                items.add(furnace.getItem(i).save(new CompoundTag()));
+            }
+            data.put("furnace", items);
+            CompoundTag furnaceTag = furnace.saveWithoutMetadata();
+            data.putInt("progress", furnaceTag.getInt("CookTime"));
+            data.putInt("total", furnaceTag.getInt("CookTimeTotal"));
+        }));
+        tileDataProviders.register(BlockEntity.class, ((data, player, world, object, showDetails) -> {
+            if (object instanceof Nameable nameable) {
+                if (nameable.hasCustomName()) {
+                    data.putString("givenName", Component.Serializer.toJson(nameable.getCustomName()));
+                }
+            }
+        }));
+        tileDataProviders.register(ChiseledBookShelfBlockEntity.class, ((data, player, world, object, showDetails) -> {
+            ChiseledBookShelfBlockEntity bookShelf = (ChiseledBookShelfBlockEntity) object;
+            if (!bookShelf.isEmpty()) {
+                data.put("Bookshelf", bookShelf.saveWithoutMetadata());
+            }
+        }));
+        tileDataProviders.register(BlockEntity.class, ((tag, player, world, object, showDetails) -> {
+            if (object instanceof AbstractFurnaceBlockEntity) {
+                return;
+            }
+            var groups = getGroups(player, (ServerLevel) world, object, showDetails);
+            if (groups != null) {
+                if (ViewGroup.saveList(tag, "JadeItemStorage", groups, item -> {
+                    CompoundTag itemTag = new CompoundTag();
+                    int count = item.getCount();
+                    if (count > 64) item.setCount(1);
+                    item.save(itemTag);
+                    if (count > 64) itemTag.putInt("NewCount", count);
+                    return itemTag;
+                })) {
+                    tag.putString("JadeItemStorageUid", BlockEntityType.getKey(object.getType()).toString());
+                } else {
+                    if (object instanceof RandomizableContainerBlockEntity te && te.lootTable != null) {
+                        tag.putBoolean("Loot", true);
+                        return;
+                    }
+                    if (!player.isCreative() && !player.isSpectator() && object instanceof BaseContainerBlockEntity te) {
+                        if (te.lockKey != LockCode.NO_LOCK) {
+                            tag.putBoolean("Locked", true);
+                        }
+                    }
+                }
+            }
+        }));
+
+        registerGlobalReceiver(PACKET_REQUEST_TILE, JadeProtocol::requestTileData);
+        registerGlobalReceiver(PACKET_REQUEST_ENTITY, JadeProtocol::requestEntityData);
+    }
+
+    public static void requestEntityData(MinecraftServer server, ServerPlayer player, FriendlyByteBuf buf) {
+        if (!LeavesConfig.jadeProtocol) {
+            return;
+        }
+
+        Level world = player.level();
+        boolean showDetails = buf.readBoolean();
+        Entity entity = world.getEntity(buf.readVarInt());
+        if (entity == null || player.distanceToSqr(entity) > MAX_DISTANCE_SQR) {
+            return;
+        }
+
+        server.execute(() -> {
+            var providers = entityDataProviders.get(entity);
+            if (providers.isEmpty()) {
+                return;
+            }
+
+            CompoundTag tag = new CompoundTag();
+            for (IJadeProvider<Entity> provider : providers) {
+                try {
+                    provider.saveData(tag, player, world, entity, showDetails);
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+            tag.putInt("WailaEntityID", entity.getId());
+
+            FriendlyByteBuf buf1 = new FriendlyByteBuf(Unpooled.buffer());
+            buf1.writeNbt(tag);
+            ProtocolUtils.sendPayloadPacket(player, PACKET_RECEIVE_DATA, buf1);
+        });
+    }
+
+    public static void requestTileData(MinecraftServer server, ServerPlayer player, FriendlyByteBuf buf) {
+        if (!LeavesConfig.jadeProtocol) {
+            return;
+        }
+
+        boolean showDetails = buf.readBoolean();
+        BlockHitResult result = buf.readBlockHitResult();
+        BlockPos pos = result.getBlockPos();
+        Level world = player.level();
+        if (pos.distSqr(player.blockPosition()) > MAX_DISTANCE_SQR || !world.isLoaded(pos)) {
+            return;
+        }
+
+        server.execute(() -> {
+            BlockEntity tile = world.getBlockEntity(pos);
+            if (tile == null) return;
+
+            List<IJadeProvider<BlockEntity>> providers = tileDataProviders.get(tile);
+            if (providers.isEmpty()) {
+                return;
+            }
+
+            CompoundTag tag = new CompoundTag();
+            for (IJadeProvider<BlockEntity> provider : providers) {
+                try {
+                    provider.saveData(tag, player, world, tile, showDetails);
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+
+            tag.putInt("x", pos.getX());
+            tag.putInt("y", pos.getY());
+            tag.putInt("z", pos.getZ());
+            tag.putString("id", BuiltInRegistries.BLOCK_ENTITY_TYPE.getKey(tile.getType()).toString());
+
+            FriendlyByteBuf buf1 = new FriendlyByteBuf(Unpooled.buffer());
+            buf1.writeNbt(tag);
+            ProtocolUtils.sendPayloadPacket(player, PACKET_RECEIVE_DATA, buf1);
+        });
+
+    }
+
+    public interface IJadeProvider<T> {
+        public void saveData(CompoundTag data, ServerPlayer player, Level world, T object, boolean showDetails);
+    }
+
+    // Power by Jade
+
+    public static List<ViewGroup<ItemStack>> getGroups(ServerPlayer player, ServerLevel world, Object target, boolean showDetails) {
+        if (target instanceof RandomizableContainerBlockEntity te && te.lootTable != null) {
+            return List.of();
+        }
+        if (target instanceof ContainerEntity containerEntity && containerEntity.getLootTable() != null) {
+            return List.of();
+        }
+        if (!player.isCreative() && !player.isSpectator() && target instanceof BaseContainerBlockEntity te) {
+            if (te.lockKey != LockCode.NO_LOCK) {
+                return List.of();
+            }
+        }
+
+        return wrapItemStorage(target, player);
+    }
+
+    public static List<ViewGroup<ItemStack>> wrapItemStorage(Object target, ServerPlayer player) {
+        int size = 54;
+        if (target instanceof AbstractHorse horse) {
+            return List.of(fromContainer(horse.inventory, size, 2));
+        }
+        if (target instanceof Container container) {
+            if (target instanceof ChestBlockEntity be) {
+                if (be.getBlockState().getBlock() instanceof ChestBlock chestBlock) {
+                    Container compound = ChestBlock.getContainer(chestBlock, be.getBlockState(), be.getLevel(), be.getBlockPos(), false);
+                    if (compound != null) {
+                        container = compound;
+                    }
+                }
+            }
+            return List.of(fromContainer(container, size, 0));
+        }
+        if (player != null && target instanceof EnderChestBlockEntity) {
+            return List.of(fromContainer(player.getEnderChestInventory(), size, 0));
+        }
+        return null;
+    }
+
+    public static ViewGroup<ItemStack> fromContainer(Container container, int maxSize, int startIndex) {
+        return compacted(IntStream.range(startIndex, container.getContainerSize()).limit(maxSize * 3L).mapToObj(container::getItem), maxSize);
+    }
+
+    public static ViewGroup<ItemStack> compacted(Stream<ItemStack> stream, int maxSize) {
+        List<ItemStack> stacks = Lists.newArrayList();
+        MutableInt start = new MutableInt();
+        stream.filter(stack -> !stack.isEmpty()).filter(stack -> {
+            if (stack.hasTag() && stack.getTag().contains("CustomModelData")) {
+                for (String key : stack.getTag().getAllKeys()) {
+                    if (key.toLowerCase(Locale.ENGLISH).endsWith("clear") && stack.getTag().getBoolean(key)) {
+                        return false;
+                    }
+                }
+            }
+            return true;
+        }).forEach(stack -> {
+            int size = stacks.size();
+            if (size > maxSize) return;
+            for (int i = 0; i < size; i++) {
+                int j = (i + start.intValue()) % size;
+                if (ItemStack.isSameItemSameTags(stack, stacks.get(j))) {
+                    stacks.get(j).grow(stack.getCount());
+                    start.setValue(j);
+                    return;
+                }
+            }
+            stacks.add(stack.copy());
+        });
+        if (stacks.size() > maxSize) stacks.remove(maxSize);
+        return new ViewGroup<>(stacks);
+    }
+
+    public static class ViewGroup<T> {
+
+        public final List<T> views;
+        @Nullable
+        public String id;
+        @Nullable
+        protected CompoundTag extraData;
+
+        public ViewGroup(List<T> views) {
+            this.views = views;
+        }
+
+        public void save(CompoundTag tag, Function<T, CompoundTag> writer) {
+            ListTag list = new ListTag();
+            for (var view : views) {
+                list.add(writer.apply(view));
+            }
+            tag.put("Views", list);
+            if (id != null) {
+                tag.putString("Id", id);
+            }
+            if (extraData != null) {
+                tag.put("Data", extraData);
+            }
+        }
+
+        public static <T> boolean saveList(CompoundTag tag, String key, List<ViewGroup<T>> groups, Function<T, CompoundTag> writer) {
+            if (groups == null || groups.isEmpty()) return false;
+            ListTag groupList = new ListTag();
+            for (ViewGroup<T> group : groups) {
+                if (group.views.isEmpty()) {
+                    continue;
+                }
+                CompoundTag groupTag = new CompoundTag();
+                group.save(groupTag, writer);
+                groupList.add(groupTag);
+            }
+            if (!groupList.isEmpty()) {
+                tag.put(key, groupList);
+                return true;
+            }
+            return false;
+        }
+
+        public CompoundTag getExtraData() {
+            if (extraData == null) {
+                extraData = new CompoundTag();
+            }
+            return extraData;
+        }
+
+        public void setProgress(float progress) {
+            getExtraData().putFloat("Progress", progress);
+        }
+    }
+
+    public static class HierarchyLookup<T extends IJadeProvider<?>> {
+
+        private final Class<?> baseClass;
+        private final ListMultimap<Class<?>, T> objects = ArrayListMultimap.create();
+        private final Cache<Class<?>, List<T>> resultCache = CacheBuilder.newBuilder().build();
+        private final boolean singleton;
+
+        public HierarchyLookup(Class<?> baseClass) {
+            this(baseClass, false);
+        }
+
+        public HierarchyLookup(Class<?> baseClass, boolean singleton) {
+            this.baseClass = baseClass;
+            this.singleton = singleton;
+        }
+
+        public void register(Class<?> clazz, T provider) {
+            Objects.requireNonNull(clazz);
+            objects.put(clazz, provider);
+        }
+
+        public List<T> get(Object obj) {
+            if (obj == null) {
+                return List.of();
+            }
+            return get(obj.getClass());
+        }
+
+        public List<T> get(Class<?> clazz) {
+            try {
+                return resultCache.get(clazz, () -> {
+                    List<T> list = Lists.newArrayList();
+                    getInternal(clazz, list);
+                    if (singleton && !list.isEmpty()) return ImmutableList.of(list.get(0));
+                    return list;
+                });
+            } catch (ExecutionException e) {
+                e.printStackTrace();
+            }
+            return List.of();
+        }
+
+        private void getInternal(Class<?> clazz, List<T> list) {
+            if (clazz != baseClass && clazz != Object.class) {
+                getInternal(clazz.getSuperclass(), list);
+            }
+            list.addAll(objects.get(clazz));
+        }
+    }
+
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/PcaSyncProtocol.java b/src/main/java/top/leavesmc/leaves/protocol/PcaSyncProtocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..819c89946670cc41f390d1855cf7159aec6bb1b5
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/PcaSyncProtocol.java
@@ -0,0 +1,357 @@
+package top.leavesmc.leaves.protocol;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.core.BlockPos;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.game.ServerboundCustomPayloadPacket;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.ChestBlock;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.ChestType;
+import org.apache.commons.lang3.tuple.ImmutablePair;
+import org.apache.commons.lang3.tuple.MutablePair;
+import org.apache.commons.lang3.tuple.Pair;
+import org.apache.logging.log4j.util.TriConsumer;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import top.leavesmc.leaves.LeavesConfig;
+import top.leavesmc.leaves.LeavesLogger;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.util.ProtocolUtils;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.locks.ReentrantLock;
+
+public class PcaSyncProtocol {
+
+    public static final String PROTOCOL_ID = "pca";
+
+    public static final ReentrantLock lock = new ReentrantLock(true);
+    public static final ReentrantLock pairLock = new ReentrantLock(true);
+
+    // send
+    private static final ResourceLocation ENABLE_PCA_SYNC_PROTOCOL = id("enable_pca_sync_protocol");
+    private static final ResourceLocation DISABLE_PCA_SYNC_PROTOCOL = id("disable_pca_sync_protocol");
+    private static final ResourceLocation UPDATE_ENTITY = id("update_entity");
+    private static final ResourceLocation UPDATE_BLOCK_ENTITY = id("update_block_entity");
+    // call
+    private static final ResourceLocation SYNC_BLOCK_ENTITY = id("sync_block_entity");
+    private static final ResourceLocation SYNC_ENTITY = id("sync_entity");
+    private static final ResourceLocation CANCEL_SYNC_BLOCK_ENTITY = id("cancel_sync_block_entity");
+    private static final ResourceLocation CANCEL_SYNC_ENTITY = id("cancel_sync_entity");
+    private static final Map<ServerPlayer, Pair<ResourceLocation, BlockPos>> playerWatchBlockPos = new HashMap<>();
+    private static final Map<ServerPlayer, Pair<ResourceLocation, Entity>> playerWatchEntity = new HashMap<>();
+    private static final Map<Pair<ResourceLocation, BlockPos>, Set<ServerPlayer>> blockPosWatchPlayerSet = new HashMap<>();
+    private static final Map<Pair<ResourceLocation, Entity>, Set<ServerPlayer>> entityWatchPlayerSet = new HashMap<>();
+    private static final MutablePair<ResourceLocation, Entity> ResourceLocationEntityPair = new MutablePair<>();
+    private static final MutablePair<ResourceLocation, BlockPos> ResourceLocationBlockPosPair = new MutablePair<>();
+
+    @Contract("_ -> new")
+    public static @NotNull ResourceLocation id(String path) {
+        return new ResourceLocation(PROTOCOL_ID, path);
+    }
+
+    public static void enablePcaSyncProtocol(@NotNull ServerPlayer player) {
+        FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+        ProtocolUtils.sendPayloadPacket(player, ENABLE_PCA_SYNC_PROTOCOL, buf);
+        lock.lock();
+        lock.unlock();
+    }
+
+    public static void disablePcaSyncProtocol(@NotNull ServerPlayer player) {
+        FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+        ProtocolUtils.sendPayloadPacket(player, DISABLE_PCA_SYNC_PROTOCOL, buf);
+    }
+
+    public static void updateEntity(@NotNull ServerPlayer player, @NotNull Entity entity) {
+        FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+        buf.writeResourceLocation(entity.level().dimension().location());
+        buf.writeInt(entity.getId());
+        buf.writeNbt(entity.saveWithoutId(new CompoundTag()));
+        ProtocolUtils.sendPayloadPacket(player, UPDATE_ENTITY, buf);
+    }
+
+    public static void updateBlockEntity(@NotNull ServerPlayer player, @NotNull BlockEntity blockEntity) {
+        Level world = blockEntity.getLevel();
+
+        if (world == null) {
+            return;
+        }
+
+        FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+        buf.writeResourceLocation(world.dimension().location());
+        buf.writeBlockPos(blockEntity.getBlockPos());
+        buf.writeNbt(blockEntity.saveWithId());
+        ProtocolUtils.sendPayloadPacket(player, UPDATE_BLOCK_ENTITY, buf);
+    }
+
+    private static final Map<ResourceLocation, TriConsumer<MinecraftServer, ServerPlayer, FriendlyByteBuf>> globalReceivers = new HashMap<>();
+
+    private static void registerGlobalReceiver(ResourceLocation identifier, TriConsumer<MinecraftServer, ServerPlayer, FriendlyByteBuf> consumer) {
+        globalReceivers.put(identifier, consumer);
+    }
+
+    public static void handlePacket(MinecraftServer server, ServerPlayer player, @NotNull ServerboundCustomPayloadPacket packet) {
+        globalReceivers.getOrDefault(
+            packet.identifier, ((server1, player1, buf) -> LeavesLogger.LOGGER.severe("NullPotion"))
+        ).accept(server, player, packet.data);
+    }
+
+    public static void init() {
+        registerGlobalReceiver(SYNC_BLOCK_ENTITY, PcaSyncProtocol::syncBlockEntityHandler);
+        registerGlobalReceiver(SYNC_ENTITY, PcaSyncProtocol::syncEntityHandler);
+        registerGlobalReceiver(CANCEL_SYNC_BLOCK_ENTITY, PcaSyncProtocol::cancelSyncBlockEntityHandler);
+        registerGlobalReceiver(CANCEL_SYNC_ENTITY, PcaSyncProtocol::cancelSyncEntityHandler);
+    }
+
+    public static void onJoin(ServerPlayer player) {
+        if (LeavesConfig.pcaSyncProtocol) {
+            enablePcaSyncProtocol(player);
+        }
+    }
+
+    private static void cancelSyncBlockEntityHandler(MinecraftServer server, ServerPlayer player,
+                                                     FriendlyByteBuf buf) {
+        if (!LeavesConfig.pcaSyncProtocol) {
+            return;
+        }
+        PcaSyncProtocol.clearPlayerWatchBlock(player);
+    }
+
+    private static void cancelSyncEntityHandler(MinecraftServer server, ServerPlayer player,
+                                                FriendlyByteBuf buf) {
+        if (!LeavesConfig.pcaSyncProtocol) {
+            return;
+        }
+        PcaSyncProtocol.clearPlayerWatchEntity(player);
+    }
+
+    private static void syncBlockEntityHandler(MinecraftServer server, ServerPlayer player,
+                                               FriendlyByteBuf buf) {
+        if (!LeavesConfig.pcaSyncProtocol) {
+            return;
+        }
+        BlockPos pos = buf.readBlockPos();
+        ServerLevel world = player.serverLevel();
+        BlockState blockState = world.getBlockState(pos);
+        clearPlayerWatchData(player);
+
+        BlockEntity blockEntityAdj = null;
+        if (blockState.getBlock() instanceof ChestBlock) {
+            if (blockState.getValue(ChestBlock.TYPE) != ChestType.SINGLE) {
+                BlockPos posAdj = pos.offset(ChestBlock.getConnectedDirection(blockState).getNormal());
+                // The method in World now checks that the caller is from the same thread...
+                blockEntityAdj = world.getChunk(posAdj).getBlockEntity(posAdj);
+            }
+        }
+
+        if (blockEntityAdj != null) {
+            updateBlockEntity(player, blockEntityAdj);
+        }
+
+        // The method in World now checks that the caller is from the same thread...
+        BlockEntity blockEntity = world.getChunk(pos).getBlockEntity(pos);
+        if (blockEntity != null) {
+            updateBlockEntity(player, blockEntity);
+        }
+
+        Pair<ResourceLocation, BlockPos> pair = new ImmutablePair<>(player.level().dimension().location(), pos);
+        lock.lock();
+        playerWatchBlockPos.put(player, pair);
+        if (!blockPosWatchPlayerSet.containsKey(pair)) {
+            blockPosWatchPlayerSet.put(pair, new HashSet<>());
+        }
+        blockPosWatchPlayerSet.get(pair).add(player);
+        lock.unlock();
+    }
+
+    private static void syncEntityHandler(MinecraftServer server, ServerPlayer player,
+                                          FriendlyByteBuf buf) {
+        if (!LeavesConfig.pcaSyncProtocol) {
+            return;
+        }
+        int entityId = buf.readInt();
+        ServerLevel world = player.serverLevel();
+        Entity entity = world.getEntity(entityId);
+        if (entity != null) {
+            clearPlayerWatchData(player);
+            if (entity instanceof Player) {
+                if (LeavesConfig.pcaSyncPlayerEntity.equals("NOBODY")) {
+                    return;
+                } else if (LeavesConfig.pcaSyncPlayerEntity.equals("BOT")) {
+                    if (!(entity instanceof ServerBot)) {
+                        return;
+                    }
+                } else if (LeavesConfig.pcaSyncPlayerEntity.equals("OPS")) {
+                    if (!(entity instanceof ServerBot) && server.getProfilePermissions(player.getGameProfile()) < 2) {
+                        return;
+                    }
+                } else if (LeavesConfig.pcaSyncPlayerEntity.equals("OPS_AND_SELF")) {
+                    if (!(entity instanceof ServerBot) &&
+                        server.getProfilePermissions(player.getGameProfile()) < 2 &&
+                        entity != player) {
+                        return;
+                    }
+                } else if (!LeavesConfig.pcaSyncPlayerEntity.equals("EVERYONE")) {
+                    // wtf????
+                    LeavesLogger.LOGGER.warning("pcaSyncPlayerEntity wtf???");
+                    return;
+                }
+            }
+            updateEntity(player, entity);
+
+            Pair<ResourceLocation, Entity> pair = new ImmutablePair<>(entity.level().dimension().location(), entity);
+            lock.lock();
+            playerWatchEntity.put(player, pair);
+            if (!entityWatchPlayerSet.containsKey(pair)) {
+                entityWatchPlayerSet.put(pair, new HashSet<>());
+            }
+            entityWatchPlayerSet.get(pair).add(player);
+            lock.unlock();
+        }
+    }
+
+    private static MutablePair<ResourceLocation, Entity> getResourceLocationEntityPair(ResourceLocation ResourceLocation, Entity entity) {
+        pairLock.lock();
+        ResourceLocationEntityPair.setLeft(ResourceLocation);
+        ResourceLocationEntityPair.setRight(entity);
+        pairLock.unlock();
+        return ResourceLocationEntityPair;
+    }
+
+    private static MutablePair<ResourceLocation, BlockPos> getResourceLocationBlockPosPair(ResourceLocation ResourceLocation, BlockPos pos) {
+        pairLock.lock();
+        ResourceLocationBlockPosPair.setLeft(ResourceLocation);
+        ResourceLocationBlockPosPair.setRight(pos);
+        pairLock.unlock();
+        return ResourceLocationBlockPosPair;
+    }
+
+    private static @Nullable Set<ServerPlayer> getWatchPlayerList(@NotNull Entity entity) {
+        return entityWatchPlayerSet.get(getResourceLocationEntityPair(entity.level().dimension().location(), entity));
+    }
+
+    private static @Nullable Set<ServerPlayer> getWatchPlayerList(@NotNull Level world, @NotNull BlockPos blockPos) {
+        return blockPosWatchPlayerSet.get(getResourceLocationBlockPosPair(world.dimension().location(), blockPos));
+    }
+
+    public static boolean syncEntityToClient(@NotNull Entity entity) {
+        if (entity.level().isClientSide()) {
+            return false;
+        }
+        lock.lock();
+        Set<ServerPlayer> playerList = getWatchPlayerList(entity);
+        boolean ret = false;
+        if (playerList != null) {
+            for (ServerPlayer player : playerList) {
+                updateEntity(player, entity);
+                ret = true;
+            }
+        }
+        lock.unlock();
+        return ret;
+    }
+
+    public static boolean syncBlockEntityToClient(@NotNull BlockEntity blockEntity) {
+        boolean ret = false;
+        Level world = blockEntity.getLevel();
+        BlockPos pos = blockEntity.getBlockPos();
+        if (world != null) {
+            if (world.isClientSide()) {
+                return false;
+            }
+            BlockState blockState = world.getBlockState(pos);
+            lock.lock();
+            Set<ServerPlayer> playerList = getWatchPlayerList(world, blockEntity.getBlockPos());
+
+            Set<ServerPlayer> playerListAdj = null;
+
+            if (blockState.getBlock() instanceof ChestBlock) {
+                if (blockState.getValue(ChestBlock.TYPE) != ChestType.SINGLE) {
+                    BlockPos posAdj = pos.offset(ChestBlock.getConnectedDirection(blockState).getNormal());
+                    playerListAdj = getWatchPlayerList(world, posAdj);
+                }
+            }
+            if (playerListAdj != null) {
+                if (playerList == null) {
+                    playerList = playerListAdj;
+                } else {
+                    playerList.addAll(playerListAdj);
+                }
+            }
+
+            if (playerList != null) {
+                for (ServerPlayer player : playerList) {
+                    updateBlockEntity(player, blockEntity);
+                    ret = true;
+                }
+            }
+            lock.unlock();
+        }
+        return ret;
+    }
+
+    private static void clearPlayerWatchEntity(ServerPlayer player) {
+        lock.lock();
+        Pair<ResourceLocation, Entity> pair = playerWatchEntity.get(player);
+        if (pair != null) {
+            Set<ServerPlayer> playerSet = entityWatchPlayerSet.get(pair);
+            playerSet.remove(player);
+            if (playerSet.isEmpty()) {
+                entityWatchPlayerSet.remove(pair);
+            }
+            playerWatchEntity.remove(player);
+        }
+        lock.unlock();
+    }
+
+    private static void clearPlayerWatchBlock(ServerPlayer player) {
+        lock.lock();
+        Pair<ResourceLocation, BlockPos> pair = playerWatchBlockPos.get(player);
+        if (pair != null) {
+            Set<ServerPlayer> playerSet = blockPosWatchPlayerSet.get(pair);
+            playerSet.remove(player);
+            if (playerSet.isEmpty()) {
+                blockPosWatchPlayerSet.remove(pair);
+            }
+            playerWatchBlockPos.remove(player);
+        }
+        lock.unlock();
+    }
+
+    public static void disablePcaSyncProtocolGlobal() {
+        lock.lock();
+        playerWatchBlockPos.clear();
+        playerWatchEntity.clear();
+        blockPosWatchPlayerSet.clear();
+        entityWatchPlayerSet.clear();
+        lock.unlock();
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().getPlayers()) {
+            disablePcaSyncProtocol(player);
+        }
+    }
+
+    public static void enablePcaSyncProtocolGlobal() {
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().getPlayers()) {
+            enablePcaSyncProtocol(player);
+        }
+    }
+
+
+    public static void clearPlayerWatchData(ServerPlayer player) {
+        PcaSyncProtocol.clearPlayerWatchBlock(player);
+        PcaSyncProtocol.clearPlayerWatchEntity(player);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/XaeroMapProtocol.java b/src/main/java/top/leavesmc/leaves/protocol/XaeroMapProtocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..01c370ec64835fdd038256560f89ed251b3d3d6d
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/XaeroMapProtocol.java
@@ -0,0 +1,39 @@
+package top.leavesmc.leaves.protocol;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.LeavesConfig;
+import top.leavesmc.leaves.util.ProtocolUtils;
+
+public class XaeroMapProtocol {
+
+    public static final String PROTOCOL_ID_MINI = "xaerominimap";
+    public static final String PROTOCOL_ID_WORLD = "xaeroworldmap";
+
+    private static final ResourceLocation MINIMAP_KEY = idMini("main");
+    private static final ResourceLocation WORLDMAP_KEY = idWorld("main");
+
+    @Contract("_ -> new")
+    public static @NotNull ResourceLocation idMini(String path) {
+        return new ResourceLocation(PROTOCOL_ID_MINI, path);
+    }
+
+    @Contract("_ -> new")
+    public static @NotNull ResourceLocation idWorld(String path) {
+        return new ResourceLocation(PROTOCOL_ID_WORLD, path);
+    }
+
+    public static void onSendWorldInfo(@NotNull ServerPlayer player) {
+        if (LeavesConfig.xaeroMapProtocol) {
+            FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+            buf.writeByte(0);
+            buf.writeInt(LeavesConfig.xaeroMapServerID);
+            ProtocolUtils.sendPayloadPacket(player, MINIMAP_KEY, buf);
+            ProtocolUtils.sendPayloadPacket(player, WORLDMAP_KEY, buf);
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/bladeren/LeavesProtocol.java b/src/main/java/top/leavesmc/leaves/protocol/bladeren/LeavesProtocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..c03d70efd5b6d0b6640c9cc9dd194746cfd19ace
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/bladeren/LeavesProtocol.java
@@ -0,0 +1,29 @@
+package top.leavesmc.leaves.protocol.bladeren;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.LeavesConfig;
+import top.leavesmc.leaves.util.ProtocolUtils;
+
+public class LeavesProtocol {
+
+    public static final String PROTOCOL_ID = "bladeren";
+
+    private static final ResourceLocation LAVA_RIPTIDE = id("lava_riptide");
+
+    @Contract("_ -> new")
+    public static @NotNull ResourceLocation id(String path) {
+        return new ResourceLocation(PROTOCOL_ID, path);
+    }
+
+    public static void onPlayerJoin(@NotNull ServerPlayer player) {
+        // lava riptide
+        FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+        buf.writeBoolean(LeavesConfig.lavaRiptide);
+        ProtocolUtils.sendPayloadPacket(player, LAVA_RIPTIDE, buf);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/bladeren/MsptSyncProtocol.java b/src/main/java/top/leavesmc/leaves/protocol/bladeren/MsptSyncProtocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..0f9062d409267f7ea9df9bac4e4323b497448545
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/bladeren/MsptSyncProtocol.java
@@ -0,0 +1,63 @@
+package top.leavesmc.leaves.protocol.bladeren;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.game.ServerboundCustomPayloadPacket;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.LeavesConfig;
+import top.leavesmc.leaves.util.ProtocolUtils;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class MsptSyncProtocol {
+
+    public static final String PROTOCOL_ID = "bladeren";
+
+    private static final ResourceLocation MSPT_SYNC_ENABLE = id("mspt_sync_enable");
+    private static final ResourceLocation MSPT_SYNC = id("mspt_sync");
+
+    private static final List<ServerPlayer> players = new ArrayList<>();
+
+    @Contract("_ -> new")
+    public static @NotNull ResourceLocation id(String path) {
+        return new ResourceLocation(PROTOCOL_ID, path);
+    }
+
+    public static void onPlayerJoin(@NotNull ServerPlayer player) {
+        if (LeavesConfig.msptSyncProtocol) {
+            FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+            ProtocolUtils.sendPayloadPacket(player, MSPT_SYNC_ENABLE, buf);
+        }
+    }
+
+    public static void handlePacket(ServerPlayer player, @NotNull ServerboundCustomPayloadPacket packet) {
+        if (packet.identifier.equals(MSPT_SYNC_ENABLE)) {
+            players.add(player);
+        }
+    }
+
+    public static void onPlayerLoggedOut(@NotNull ServerPlayer player) {
+        if (LeavesConfig.msptSyncProtocol) {
+            players.remove(player);
+        }
+    }
+
+    public static void tick(MinecraftServer server) {
+        if (LeavesConfig.msptSyncProtocol) {
+            if (server.getTickCount() % LeavesConfig.msptSyncTickInterval == 0 && !players.isEmpty()) {
+                FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+                double mspt = Arrays.stream(server.tickTimes).average().getAsDouble() * 1.0E-6D;
+                double tps = 1000.0D / Math.max(mspt, 50);
+                buf.writeDouble(mspt);
+                buf.writeDouble(tps);
+                players.forEach(player -> ProtocolUtils.sendPayloadPacket(player, MSPT_SYNC, buf));
+            }
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/CommunicationManager.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/CommunicationManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..1dda69bb2ab8103d0886a7800c227344d7fc32f7
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/CommunicationManager.java
@@ -0,0 +1,378 @@
+package top.leavesmc.leaves.protocol.syncmatica;
+
+import com.mojang.authlib.GameProfile;
+import io.netty.buffer.Unpooled;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.protocol.game.ServerboundCustomPayloadPacket;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.network.ServerGamePacketListenerImpl;
+import net.minecraft.world.level.block.Mirror;
+import net.minecraft.world.level.block.Rotation;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.protocol.syncmatica.exchange.DownloadExchange;
+import top.leavesmc.leaves.protocol.syncmatica.exchange.Exchange;
+import top.leavesmc.leaves.protocol.syncmatica.exchange.ExchangeTarget;
+import top.leavesmc.leaves.protocol.syncmatica.exchange.ModifyExchangeServer;
+import top.leavesmc.leaves.protocol.syncmatica.exchange.UploadExchange;
+import top.leavesmc.leaves.protocol.syncmatica.exchange.VersionHandshakeServer;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+
+public class CommunicationManager {
+
+    private final Map<UUID, List<ServerPlacement>> downloadingFile = new HashMap<>();
+    private final Map<ExchangeTarget, ServerPlayer> playerMap = new HashMap<>();
+
+    protected final Collection<ExchangeTarget> broadcastTargets = new ArrayList<>();
+
+    protected final Map<UUID, Boolean> downloadState = new HashMap<>();
+    protected final Map<UUID, Exchange> modifyState = new HashMap<>();
+
+    protected static final Rotation[] rotOrdinals = Rotation.values();
+    protected static final Mirror[] mirOrdinals = Mirror.values();
+
+    public CommunicationManager() {
+    }
+
+    public GameProfile getGameProfile(final ExchangeTarget exchangeTarget) {
+        return playerMap.get(exchangeTarget).getGameProfile();
+    }
+
+    public void sendMessage(final @NotNull ExchangeTarget client, final MessageType type, final String identifier) {
+        if (client.getFeatureSet().hasFeature(Feature.MESSAGE)) {
+            final FriendlyByteBuf newPacketBuf = new FriendlyByteBuf(Unpooled.buffer());
+            newPacketBuf.writeUtf(type.toString());
+            newPacketBuf.writeUtf(identifier);
+            client.sendPacket(PacketType.MESSAGE.identifier, newPacketBuf);
+        } else if (playerMap.containsKey(client)) {
+            final ServerPlayer player = playerMap.get(client);
+            player.sendSystemMessage(Component.literal("Syncmatica " + type.toString() + " " + identifier));
+        }
+    }
+
+    public void onPlayerJoin(final ExchangeTarget newPlayer, final ServerPlayer player) {
+        final VersionHandshakeServer hi = new VersionHandshakeServer(newPlayer);
+        playerMap.put(newPlayer, player);
+        final GameProfile profile = player.getGameProfile();
+        SyncmaticaProtocol.getPlayerIdentifierProvider().updateName(profile.getId(), profile.getName());
+        startExchangeUnchecked(hi);
+    }
+
+    public void onPlayerLeave(final @NotNull ExchangeTarget oldPlayer) {
+        final Collection<Exchange> potentialMessageTarget = oldPlayer.getExchanges();
+        if (potentialMessageTarget != null) {
+            for (final Exchange target : potentialMessageTarget) {
+                target.close(false);
+                handleExchange(target);
+            }
+        }
+        broadcastTargets.remove(oldPlayer);
+        playerMap.remove(oldPlayer);
+    }
+
+    public void onPacketGet(final @NotNull ServerboundCustomPayloadPacket packet, final @NotNull ServerGamePacketListenerImpl impl) {
+        onPacket(impl.exchangeTarget, packet.identifier, packet.data);
+    }
+
+    public void onPacket(final @NotNull ExchangeTarget source, final ResourceLocation id, final FriendlyByteBuf packetBuf) {
+        Exchange handler = null;
+        final Collection<Exchange> potentialMessageTarget = source.getExchanges();
+        if (potentialMessageTarget != null) {
+            for (final Exchange target : potentialMessageTarget) {
+                if (target.checkPacket(id, packetBuf)) {
+                    target.handle(id, packetBuf);
+                    handler = target;
+                    break;
+                }
+            }
+        }
+        if (handler == null) {
+            handle(source, id, packetBuf);
+        } else if (handler.isFinished()) {
+            notifyClose(handler);
+        }
+    }
+
+    protected void handle(ExchangeTarget source, @NotNull ResourceLocation id, FriendlyByteBuf packetBuf) {
+        if (id.equals(PacketType.REQUEST_LITEMATIC.identifier)) {
+            final UUID syncmaticaId = packetBuf.readUUID();
+            final ServerPlacement placement = SyncmaticaProtocol.getSyncmaticManager().getPlacement(syncmaticaId);
+            if (placement == null) {
+                return;
+            }
+            final File toUpload = SyncmaticaProtocol.getFileStorage().getLocalLitematic(placement);
+            final UploadExchange upload;
+            try {
+                upload = new UploadExchange(placement, toUpload, source);
+            } catch (final FileNotFoundException e) {
+                e.printStackTrace();
+                return;
+            }
+            startExchange(upload);
+            return;
+        }
+        if (id.equals(PacketType.REGISTER_METADATA.identifier)) {
+            final ServerPlacement placement = receiveMetaData(packetBuf, source);
+            if (SyncmaticaProtocol.getSyncmaticManager().getPlacement(placement.getId()) != null) {
+                cancelShare(source, placement);
+                return;
+            }
+
+            final GameProfile profile = playerMap.get(source).getGameProfile();
+            final PlayerIdentifier playerIdentifier = SyncmaticaProtocol.getPlayerIdentifierProvider().createOrGet(profile);
+            if (!placement.getOwner().equals(playerIdentifier)) {
+                placement.setOwner(playerIdentifier);
+                placement.setLastModifiedBy(playerIdentifier);
+            }
+
+            if (!SyncmaticaProtocol.getFileStorage().getLocalState(placement).isLocalFileReady()) {
+                if (SyncmaticaProtocol.getFileStorage().getLocalState(placement) == LocalLitematicState.DOWNLOADING_LITEMATIC) {
+                    downloadingFile.computeIfAbsent(placement.getHash(), key -> new ArrayList<>()).add(placement);
+                    return;
+                }
+                try {
+                    download(placement, source);
+                } catch (final Exception e) {
+                    e.printStackTrace();
+                }
+                return;
+            }
+
+            addPlacement(source, placement);
+            return;
+        }
+        if (id.equals(PacketType.REMOVE_SYNCMATIC.identifier)) {
+            final UUID placementId = packetBuf.readUUID();
+            final ServerPlacement placement = SyncmaticaProtocol.getSyncmaticManager().getPlacement(placementId);
+            if (placement != null) {
+                final Exchange modifier = getModifier(placement);
+                if (modifier != null) {
+                    modifier.close(true);
+                    notifyClose(modifier);
+                }
+                SyncmaticaProtocol.getSyncmaticManager().removePlacement(placement);
+                for (final ExchangeTarget client : broadcastTargets) {
+                    final FriendlyByteBuf newPacketBuf = new FriendlyByteBuf(Unpooled.buffer());
+                    newPacketBuf.writeUUID(placement.getId());
+                    client.sendPacket(PacketType.REMOVE_SYNCMATIC.identifier, newPacketBuf);
+                }
+            }
+        }
+        if (id.equals(PacketType.MODIFY_REQUEST.identifier)) {
+            final UUID placementId = packetBuf.readUUID();
+            final ModifyExchangeServer modifier = new ModifyExchangeServer(placementId, source);
+            startExchange(modifier);
+        }
+    }
+
+    protected void handleExchange(Exchange exchange) {
+        if (exchange instanceof DownloadExchange) {
+            final ServerPlacement p = ((DownloadExchange) exchange).getPlacement();
+
+            if (exchange.isSuccessful()) {
+                addPlacement(exchange.getPartner(), p);
+                if (downloadingFile.containsKey(p.getHash())) {
+                    for (final ServerPlacement placement : downloadingFile.get(p.getHash())) {
+                        addPlacement(exchange.getPartner(), placement);
+                    }
+                }
+            } else {
+                cancelShare(exchange.getPartner(), p);
+                if (downloadingFile.containsKey(p.getHash())) {
+                    for (final ServerPlacement placement : downloadingFile.get(p.getHash())) {
+                        cancelShare(exchange.getPartner(), placement);
+                    }
+                }
+            }
+
+            downloadingFile.remove(p.getHash());
+            return;
+        }
+        if (exchange instanceof VersionHandshakeServer && exchange.isSuccessful()) {
+            broadcastTargets.add(exchange.getPartner());
+        }
+        if (exchange instanceof ModifyExchangeServer && exchange.isSuccessful()) {
+            final ServerPlacement placement = ((ModifyExchangeServer) exchange).getPlacement();
+            for (final ExchangeTarget client : broadcastTargets) {
+                if (client.getFeatureSet().hasFeature(Feature.MODIFY)) {
+                    final FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+                    buf.writeUUID(placement.getId());
+                    putPositionData(placement, buf, client);
+                    if (client.getFeatureSet().hasFeature(Feature.CORE_EX)) {
+                        buf.writeUUID(placement.getLastModifiedBy().uuid);
+                        buf.writeUtf(placement.getLastModifiedBy().getName());
+                    }
+                    client.sendPacket(PacketType.MODIFY.identifier, buf);
+                } else {
+                    final FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+                    buf.writeUUID(placement.getId());
+                    client.sendPacket(PacketType.REMOVE_SYNCMATIC.identifier, buf);
+                    final FriendlyByteBuf buf2 = new FriendlyByteBuf(Unpooled.buffer());
+                    putMetaData(placement, buf2, client);
+                    client.sendPacket(PacketType.REGISTER_METADATA.identifier, buf2);
+                }
+            }
+        }
+    }
+
+    private void addPlacement(final ExchangeTarget t, final @NotNull ServerPlacement placement) {
+        if (SyncmaticaProtocol.getSyncmaticManager().getPlacement(placement.getId()) != null) {
+            cancelShare(t, placement);
+            return;
+        }
+        SyncmaticaProtocol.getSyncmaticManager().addPlacement(placement);
+        for (final ExchangeTarget target : broadcastTargets) {
+            sendMetaData(placement, target);
+        }
+    }
+
+    private void cancelShare(final @NotNull ExchangeTarget source, final @NotNull ServerPlacement placement) {
+        final FriendlyByteBuf FriendlyByteBuf = new FriendlyByteBuf(Unpooled.buffer());
+        FriendlyByteBuf.writeUUID(placement.getId());
+        source.sendPacket(PacketType.CANCEL_SHARE.identifier, FriendlyByteBuf);
+    }
+
+    public void sendMetaData(final ServerPlacement metaData, final ExchangeTarget target) {
+        final FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+        putMetaData(metaData, buf, target);
+        target.sendPacket(PacketType.REGISTER_METADATA.identifier, buf);
+    }
+
+    public void putMetaData(final @NotNull ServerPlacement metaData, final @NotNull FriendlyByteBuf buf, final @NotNull ExchangeTarget exchangeTarget) {
+        buf.writeUUID(metaData.getId());
+
+        buf.writeUtf(SyncmaticaProtocol.sanitizeFileName(metaData.getName()));
+        buf.writeUUID(metaData.getHash());
+
+        if (exchangeTarget.getFeatureSet().hasFeature(Feature.CORE_EX)) {
+            buf.writeUUID(metaData.getOwner().uuid);
+            buf.writeUtf(metaData.getOwner().getName());
+            buf.writeUUID(metaData.getLastModifiedBy().uuid);
+            buf.writeUtf(metaData.getLastModifiedBy().getName());
+        }
+
+        putPositionData(metaData, buf, exchangeTarget);
+    }
+
+    public void putPositionData(final @NotNull ServerPlacement metaData, final @NotNull FriendlyByteBuf buf, final @NotNull ExchangeTarget exchangeTarget) {
+        buf.writeBlockPos(metaData.getPosition());
+        buf.writeUtf(metaData.getDimension());
+        buf.writeInt(metaData.getRotation().ordinal());
+        buf.writeInt(metaData.getMirror().ordinal());
+
+        if (exchangeTarget.getFeatureSet().hasFeature(Feature.CORE_EX)) {
+            if (metaData.getSubRegionData().getModificationData() == null) {
+                buf.writeInt(0);
+                return;
+            }
+
+            final Collection<SubRegionPlacementModification> regionData = metaData.getSubRegionData().getModificationData().values();
+            buf.writeInt(regionData.size());
+
+            for (final SubRegionPlacementModification subPlacement : regionData) {
+                buf.writeUtf(subPlacement.name);
+                buf.writeBlockPos(subPlacement.position);
+                buf.writeInt(subPlacement.rotation.ordinal());
+                buf.writeInt(subPlacement.mirror.ordinal());
+            }
+        }
+    }
+
+    public ServerPlacement receiveMetaData(final @NotNull FriendlyByteBuf buf, final @NotNull ExchangeTarget exchangeTarget) {
+        final UUID id = buf.readUUID();
+
+        final String fileName = SyncmaticaProtocol.sanitizeFileName(buf.readUtf(32767));
+        final UUID hash = buf.readUUID();
+
+        PlayerIdentifier owner = PlayerIdentifier.MISSING_PLAYER;
+        PlayerIdentifier lastModifiedBy = PlayerIdentifier.MISSING_PLAYER;
+
+        if (exchangeTarget.getFeatureSet().hasFeature(Feature.CORE_EX)) {
+            final PlayerIdentifierProvider provider = SyncmaticaProtocol.getPlayerIdentifierProvider();
+            owner = provider.createOrGet(buf.readUUID(), buf.readUtf(32767));
+            lastModifiedBy = provider.createOrGet(buf.readUUID(), buf.readUtf(32767));
+        }
+
+        final ServerPlacement placement = new ServerPlacement(id, fileName, hash, owner);
+        placement.setLastModifiedBy(lastModifiedBy);
+
+        receivePositionData(placement, buf, exchangeTarget);
+
+        return placement;
+    }
+
+    public void receivePositionData(final @NotNull ServerPlacement placement, final @NotNull FriendlyByteBuf buf, final @NotNull ExchangeTarget exchangeTarget) {
+        final BlockPos pos = buf.readBlockPos();
+        final String dimensionId = buf.readUtf(32767);
+        final Rotation rot = rotOrdinals[buf.readInt()];
+        final Mirror mir = mirOrdinals[buf.readInt()];
+        placement.move(dimensionId, pos, rot, mir);
+
+        if (exchangeTarget.getFeatureSet().hasFeature(Feature.CORE_EX)) {
+            final SubRegionData subRegionData = placement.getSubRegionData();
+            subRegionData.reset();
+            final int limit = buf.readInt();
+            for (int i = 0; i < limit; i++) {
+                subRegionData.modify(buf.readUtf(32767), buf.readBlockPos(), rotOrdinals[buf.readInt()], mirOrdinals[buf.readInt()]);
+            }
+        }
+    }
+
+    public void download(final ServerPlacement syncmatic, final ExchangeTarget source) throws NoSuchAlgorithmException, IOException {
+        if (!SyncmaticaProtocol.getFileStorage().getLocalState(syncmatic).isReadyForDownload()) {
+            throw new IllegalArgumentException(syncmatic.toString() + " is not ready for download local state is: " + SyncmaticaProtocol.getFileStorage().getLocalState(syncmatic).toString());
+        }
+        final File toDownload = SyncmaticaProtocol.getFileStorage().createLocalLitematic(syncmatic);
+        final Exchange downloadExchange = new DownloadExchange(syncmatic, toDownload, source);
+        setDownloadState(syncmatic, true);
+        startExchange(downloadExchange);
+    }
+
+    public void setDownloadState(final @NotNull ServerPlacement syncmatic, final boolean b) {
+        downloadState.put(syncmatic.getHash(), b);
+    }
+
+    public boolean getDownloadState(final @NotNull ServerPlacement syncmatic) {
+        return downloadState.getOrDefault(syncmatic.getHash(), false);
+    }
+
+    public void setModifier(final @NotNull ServerPlacement syncmatic, final Exchange exchange) {
+        modifyState.put(syncmatic.getHash(), exchange);
+    }
+
+    public Exchange getModifier(final @NotNull ServerPlacement syncmatic) {
+        return modifyState.get(syncmatic.getHash());
+    }
+
+    public void startExchange(final @NotNull Exchange newExchange) {
+        if (!broadcastTargets.contains(newExchange.getPartner())) {
+            throw new IllegalArgumentException(newExchange.getPartner().toString() + " is not a valid ExchangeTarget");
+        }
+        startExchangeUnchecked(newExchange);
+    }
+
+    protected void startExchangeUnchecked(final @NotNull Exchange newExchange) {
+        newExchange.getPartner().getExchanges().add(newExchange);
+        newExchange.init();
+        if (newExchange.isFinished()) {
+            notifyClose(newExchange);
+        }
+    }
+
+    public void notifyClose(final @NotNull Exchange e) {
+        e.getPartner().getExchanges().remove(e);
+        handleExchange(e);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/Feature.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/Feature.java
new file mode 100644
index 0000000000000000000000000000000000000000..1125755d7d78a118d1fe407e9ca554a89f4d9a9a
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/Feature.java
@@ -0,0 +1,23 @@
+package top.leavesmc.leaves.protocol.syncmatica;
+
+import org.jetbrains.annotations.Nullable;
+
+public enum Feature {
+    CORE,
+    FEATURE,
+    MODIFY,
+    MESSAGE,
+    QUOTA,
+    DEBUG,
+    CORE_EX;
+
+    @Nullable
+    public static Feature fromString(final String s) {
+        for (final Feature f : Feature.values()) {
+            if (f.toString().equals(s)) {
+                return f;
+            }
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/FeatureSet.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/FeatureSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..3d851913e2016fcd384b6a8b1e91753cb8ea91ef
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/FeatureSet.java
@@ -0,0 +1,67 @@
+package top.leavesmc.leaves.protocol.syncmatica;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+public class FeatureSet {
+
+    private static final Map<String, FeatureSet> versionFeatures;
+    private final Collection<Feature> features;
+
+    @Nullable
+    public static FeatureSet fromVersionString(@NotNull String version) {
+        if (version.matches("^\\d+(\\.\\d+){2,4}$")) {
+            final int minSize = version.indexOf(".");
+            while (version.length() > minSize) {
+                if (versionFeatures.containsKey(version)) {
+                    return versionFeatures.get(version);
+                }
+                final int lastDot = version.lastIndexOf(".");
+                version = version.substring(0, lastDot);
+            }
+        }
+        return null;
+    }
+
+    @NotNull
+    public static FeatureSet fromString(final @NotNull String features) {
+        final FeatureSet featureSet = new FeatureSet(new ArrayList<>());
+        for (final String feature : features.split("\n")) {
+            final Feature f = Feature.fromString(feature);
+            if (f != null) {
+                featureSet.features.add(f);
+            }
+        }
+        return featureSet;
+    }
+
+    @Override
+    public String toString() {
+        final StringBuilder output = new StringBuilder();
+        boolean b = false;
+        for (final Feature feature : features) {
+            output.append(b ? "\n" + feature.toString() : feature.toString());
+            b = true;
+        }
+        return output.toString();
+    }
+
+    public FeatureSet(final Collection<Feature> features) {
+        this.features = features;
+    }
+
+    public boolean hasFeature(final Feature f) {
+        return features.contains(f);
+    }
+
+    static {
+        versionFeatures = new HashMap<>();
+        versionFeatures.put("0.1", new FeatureSet(Collections.singletonList(Feature.CORE)));
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/FileStorage.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/FileStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..5dccbce7287fe436de9436f35a7d1ffcfc5d74ab
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/FileStorage.java
@@ -0,0 +1,80 @@
+package top.leavesmc.leaves.protocol.syncmatica;
+
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.UUID;
+
+public class FileStorage {
+
+    private final HashMap<ServerPlacement, Long> buffer = new HashMap<>();
+
+    public LocalLitematicState getLocalState(final ServerPlacement placement) {
+        final File localFile = getSchematicPath(placement);
+        if (localFile.isFile()) {
+            if (isDownloading(placement)) {
+                return LocalLitematicState.DOWNLOADING_LITEMATIC;
+            }
+            if ((buffer.containsKey(placement) && buffer.get(placement) == localFile.lastModified()) || hashCompare(localFile, placement)) {
+                return LocalLitematicState.LOCAL_LITEMATIC_PRESENT;
+            }
+            return LocalLitematicState.LOCAL_LITEMATIC_DESYNC;
+        }
+        return LocalLitematicState.NO_LOCAL_LITEMATIC;
+    }
+
+    private boolean isDownloading(final ServerPlacement placement) {
+        return SyncmaticaProtocol.getCommunicationManager().getDownloadState(placement);
+    }
+
+    public File getLocalLitematic(final ServerPlacement placement) {
+        if (getLocalState(placement).isLocalFileReady()) {
+            return getSchematicPath(placement);
+        } else {
+            return null;
+        }
+    }
+
+    public File createLocalLitematic(final ServerPlacement placement) {
+        if (getLocalState(placement).isLocalFileReady()) {
+            throw new IllegalArgumentException("");
+        }
+        final File file = getSchematicPath(placement);
+        if (file.exists()) {
+            file.delete();
+        }
+        try {
+            file.createNewFile();
+        } catch (final IOException e) {
+            e.printStackTrace();
+        }
+        return file;
+    }
+
+    private boolean hashCompare(final File localFile, final ServerPlacement placement) {
+        UUID hash = null;
+        try {
+            hash = SyncmaticaProtocol.createChecksum(new FileInputStream(localFile));
+        } catch (final Exception e) {
+            e.printStackTrace();
+        }
+
+        if (hash == null) {
+            return false;
+        }
+        if (hash.equals(placement.getHash())) {
+            buffer.put(placement, localFile.lastModified());
+            return true;
+        }
+        return false;
+    }
+
+    @Contract("_ -> new")
+    private @NotNull File getSchematicPath(final @NotNull ServerPlacement placement) {
+        return new File(SyncmaticaProtocol.getLitematicFolder(), placement.getHash().toString() + ".litematic");
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/LocalLitematicState.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/LocalLitematicState.java
new file mode 100644
index 0000000000000000000000000000000000000000..82ffc8cbd1b488c8723693b685a91c2a4149fb47
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/LocalLitematicState.java
@@ -0,0 +1,24 @@
+package top.leavesmc.leaves.protocol.syncmatica;
+
+public enum LocalLitematicState {
+    NO_LOCAL_LITEMATIC(true, false),
+    LOCAL_LITEMATIC_DESYNC(true, false),
+    DOWNLOADING_LITEMATIC(false, false),
+    LOCAL_LITEMATIC_PRESENT(false, true);
+
+    private final boolean downloadReady;
+    private final boolean fileReady;
+
+    LocalLitematicState(final boolean downloadReady, final boolean fileReady) {
+        this.downloadReady = downloadReady;
+        this.fileReady = fileReady;
+    }
+
+    public boolean isReadyForDownload() {
+        return downloadReady;
+    }
+
+    public boolean isLocalFileReady() {
+        return fileReady;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/MessageType.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/MessageType.java
new file mode 100644
index 0000000000000000000000000000000000000000..04d785846be3670b741d90634f5f691899127835
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/MessageType.java
@@ -0,0 +1,8 @@
+package top.leavesmc.leaves.protocol.syncmatica;
+
+public enum MessageType {
+    SUCCESS,
+    INFO,
+    WARNING,
+    ERROR
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/PacketType.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/PacketType.java
new file mode 100644
index 0000000000000000000000000000000000000000..8f3227d36da0a3055cc25e538437de58fd5730e3
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/PacketType.java
@@ -0,0 +1,30 @@
+package top.leavesmc.leaves.protocol.syncmatica;
+
+import net.minecraft.resources.ResourceLocation;
+
+public enum PacketType {
+    REGISTER_METADATA("register_metadata"),
+    CANCEL_SHARE("cancel_share"),
+    REQUEST_LITEMATIC("request_download"),
+    SEND_LITEMATIC("send_litematic"),
+    RECEIVED_LITEMATIC("received_litematic"),
+    FINISHED_LITEMATIC("finished_litematic"),
+    CANCEL_LITEMATIC("cancel_litematic"),
+    REMOVE_SYNCMATIC("remove_syncmatic"),
+    REGISTER_VERSION("register_version"),
+    CONFIRM_USER("confirm_user"),
+    FEATURE_REQUEST("feature_request"),
+    FEATURE("feature"),
+    MODIFY("modify"),
+    MODIFY_REQUEST("modify_request"),
+    MODIFY_REQUEST_DENY("modify_request_deny"),
+    MODIFY_REQUEST_ACCEPT("modify_request_accept"),
+    MODIFY_FINISH("modify_finish"),
+    MESSAGE("mesage");
+
+    public final ResourceLocation identifier;
+
+    PacketType(final String id) {
+        identifier = new ResourceLocation(SyncmaticaProtocol.PROTOCOL_ID, id);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/PlayerIdentifier.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/PlayerIdentifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..f9ba2a41ab1e0d50bf85fd024b6d29e65b3a5cf7
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/PlayerIdentifier.java
@@ -0,0 +1,37 @@
+package top.leavesmc.leaves.protocol.syncmatica;
+
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+
+import java.util.UUID;
+
+public class PlayerIdentifier {
+
+    public static final UUID MISSING_PLAYER_UUID = UUID.fromString("4c1b738f-56fa-4011-8273-498c972424ea");
+    public static final PlayerIdentifier MISSING_PLAYER = new PlayerIdentifier(MISSING_PLAYER_UUID, "No Player");
+
+    public final UUID uuid;
+    private String bufferedPlayerName;
+
+    PlayerIdentifier(final UUID uuid, final String bufferedPlayerName) {
+        this.uuid = uuid;
+        this.bufferedPlayerName = bufferedPlayerName;
+    }
+
+    public String getName() {
+        return bufferedPlayerName;
+    }
+
+    public void updatePlayerName(final String name) {
+        bufferedPlayerName = name;
+    }
+
+    public JsonObject toJson() {
+        final JsonObject jsonObject = new JsonObject();
+
+        jsonObject.add("uuid", new JsonPrimitive(uuid.toString()));
+        jsonObject.add("name", new JsonPrimitive(bufferedPlayerName));
+
+        return jsonObject;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/PlayerIdentifierProvider.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/PlayerIdentifierProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..f4fc3bac20359ecf17a25d7b8e8f34cfebcf4b24
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/PlayerIdentifierProvider.java
@@ -0,0 +1,46 @@
+package top.leavesmc.leaves.protocol.syncmatica;
+
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.protocol.syncmatica.exchange.ExchangeTarget;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+
+public class PlayerIdentifierProvider {
+
+    private final Map<UUID, PlayerIdentifier> identifiers = new HashMap<>();
+
+    public PlayerIdentifierProvider() {
+        identifiers.put(PlayerIdentifier.MISSING_PLAYER_UUID, PlayerIdentifier.MISSING_PLAYER);
+    }
+
+    public PlayerIdentifier createOrGet(final ExchangeTarget exchangeTarget) {
+        return createOrGet(SyncmaticaProtocol.getCommunicationManager().getGameProfile(exchangeTarget));
+    }
+
+    public PlayerIdentifier createOrGet(final @NotNull GameProfile gameProfile) {
+        return createOrGet(gameProfile.getId(), gameProfile.getName());
+    }
+
+    public PlayerIdentifier createOrGet(final UUID uuid, final String playerName) {
+        return identifiers.computeIfAbsent(uuid, id -> new PlayerIdentifier(uuid, playerName));
+    }
+
+    public void updateName(final UUID uuid, final String playerName) {
+        createOrGet(uuid, playerName).updatePlayerName(playerName);
+    }
+
+    public PlayerIdentifier fromJson(final @NotNull JsonObject obj) {
+        if (!obj.has("uuid") || !obj.has("name")) {
+            return PlayerIdentifier.MISSING_PLAYER;
+        }
+
+        final UUID jsonUUID = UUID.fromString(obj.get("uuid").getAsString());
+        return identifiers.computeIfAbsent(jsonUUID,
+            key -> new PlayerIdentifier(jsonUUID, obj.get("name").getAsString())
+        );
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/ServerPlacement.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/ServerPlacement.java
new file mode 100644
index 0000000000000000000000000000000000000000..8c5bc7d6244d6ccd9a561030fff44ccdecc1ed5c
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/ServerPlacement.java
@@ -0,0 +1,166 @@
+package top.leavesmc.leaves.protocol.syncmatica;
+
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.block.Mirror;
+import net.minecraft.world.level.block.Rotation;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.UUID;
+
+public class ServerPlacement {
+
+    private final UUID id;
+
+    private final String fileName;
+    private final UUID hashValue;
+
+    private PlayerIdentifier owner;
+    private PlayerIdentifier lastModifiedBy;
+
+    private ServerPosition origin;
+    private Rotation rotation;
+    private Mirror mirror;
+
+    private SubRegionData subRegionData = new SubRegionData();
+
+    public ServerPlacement(final UUID id, final String fileName, final UUID hashValue, final PlayerIdentifier owner) {
+        this.id = id;
+        this.fileName = fileName;
+        this.hashValue = hashValue;
+        this.owner = owner;
+        lastModifiedBy = owner;
+    }
+
+    public UUID getId() {
+        return id;
+    }
+
+    public String getName() {
+        return fileName;
+    }
+
+    public UUID getHash() {
+        return hashValue;
+    }
+
+    public String getDimension() {
+        return origin.getDimensionId();
+    }
+
+    public BlockPos getPosition() {
+        return origin.getBlockPosition();
+    }
+
+    public ServerPosition getOrigin() {
+        return origin;
+    }
+
+    public Rotation getRotation() {
+        return rotation;
+    }
+
+    public Mirror getMirror() {
+        return mirror;
+    }
+
+    public ServerPlacement move(final String dimensionId, final BlockPos origin, final Rotation rotation, final Mirror mirror) {
+        move(new ServerPosition(origin, dimensionId), rotation, mirror);
+        return this;
+    }
+
+    public ServerPlacement move(final ServerPosition origin, final Rotation rotation, final Mirror mirror) {
+        this.origin = origin;
+        this.rotation = rotation;
+        this.mirror = mirror;
+        return this;
+    }
+
+    public PlayerIdentifier getOwner() {
+        return owner;
+    }
+
+    public void setOwner(final PlayerIdentifier playerIdentifier) {
+        owner = playerIdentifier;
+    }
+
+    public PlayerIdentifier getLastModifiedBy() {
+        return lastModifiedBy;
+    }
+
+    public void setLastModifiedBy(final PlayerIdentifier lastModifiedBy) {
+        this.lastModifiedBy = lastModifiedBy;
+    }
+
+    public SubRegionData getSubRegionData() {
+        return subRegionData;
+    }
+
+    public JsonObject toJson() {
+        final JsonObject obj = new JsonObject();
+        obj.add("id", new JsonPrimitive(id.toString()));
+
+        obj.add("file_name", new JsonPrimitive(fileName));
+        obj.add("hash", new JsonPrimitive(hashValue.toString()));
+
+        obj.add("origin", origin.toJson());
+        obj.add("rotation", new JsonPrimitive(rotation.name()));
+        obj.add("mirror", new JsonPrimitive(mirror.name()));
+
+        obj.add("owner", owner.toJson());
+        if (!owner.equals(lastModifiedBy)) {
+            obj.add("lastModifiedBy", lastModifiedBy.toJson());
+        }
+
+        if (subRegionData.isModified()) {
+            obj.add("subregionData", subRegionData.toJson());
+        }
+
+        return obj;
+    }
+
+    @Nullable
+    public static ServerPlacement fromJson(final @NotNull JsonObject obj) {
+        if (obj.has("id")
+            && obj.has("file_name")
+            && obj.has("hash")
+            && obj.has("origin")
+            && obj.has("rotation")
+            && obj.has("mirror")) {
+            final UUID id = UUID.fromString(obj.get("id").getAsString());
+            final String name = obj.get("file_name").getAsString();
+            final UUID hashValue = UUID.fromString(obj.get("hash").getAsString());
+
+            PlayerIdentifier owner = PlayerIdentifier.MISSING_PLAYER;
+            if (obj.has("owner")) {
+                owner = SyncmaticaProtocol.getPlayerIdentifierProvider().fromJson(obj.get("owner").getAsJsonObject());
+            }
+
+            final ServerPlacement newPlacement = new ServerPlacement(id, name, hashValue, owner);
+            final ServerPosition pos = ServerPosition.fromJson(obj.get("origin").getAsJsonObject());
+            if (pos == null) {
+                return null;
+            }
+            newPlacement.origin = pos;
+            newPlacement.rotation = Rotation.valueOf(obj.get("rotation").getAsString());
+            newPlacement.mirror = Mirror.valueOf(obj.get("mirror").getAsString());
+
+            if (obj.has("lastModifiedBy")) {
+                newPlacement.lastModifiedBy = SyncmaticaProtocol.getPlayerIdentifierProvider()
+                    .fromJson(obj.get("lastModifiedBy").getAsJsonObject());
+            } else {
+                newPlacement.lastModifiedBy = owner;
+            }
+
+            if (obj.has("subregionData")) {
+                newPlacement.subRegionData = SubRegionData.fromJson(obj.get("subregionData"));
+            }
+
+            return newPlacement;
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/ServerPosition.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/ServerPosition.java
new file mode 100644
index 0000000000000000000000000000000000000000..3f6ee21ce72943e11f8d924321eb286652c5c533
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/ServerPosition.java
@@ -0,0 +1,51 @@
+package top.leavesmc.leaves.protocol.syncmatica;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import net.minecraft.core.BlockPos;
+
+public class ServerPosition {
+
+    private final BlockPos position;
+    private final String dimensionId;
+
+    public ServerPosition(final BlockPos pos, final String dim) {
+        position = pos;
+        dimensionId = dim;
+    }
+
+    public BlockPos getBlockPosition() {
+        return position;
+    }
+
+    public String getDimensionId() {
+        return dimensionId;
+    }
+
+    public JsonObject toJson() {
+        final JsonObject obj = new JsonObject();
+        final JsonArray arr = new JsonArray();
+        arr.add(new JsonPrimitive(position.getX()));
+        arr.add(new JsonPrimitive(position.getY()));
+        arr.add(new JsonPrimitive(position.getZ()));
+        obj.add("position", arr);
+        obj.add("dimension", new JsonPrimitive(dimensionId));
+        return obj;
+    }
+
+    public static ServerPosition fromJson(final JsonObject obj) {
+        if (obj.has("position") && obj.has("dimension")) {
+            final int x;
+            final int y;
+            final int z;
+            final JsonArray arr = obj.get("position").getAsJsonArray();
+            x = arr.get(0).getAsInt();
+            y = arr.get(1).getAsInt();
+            z = arr.get(2).getAsInt();
+            final BlockPos pos = new BlockPos(x, y, z);
+            return new ServerPosition(pos, obj.get("dimension").getAsString());
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/SubRegionData.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/SubRegionData.java
new file mode 100644
index 0000000000000000000000000000000000000000..6903c26742f5e10aa75f52b7abd5273e7116600b
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/SubRegionData.java
@@ -0,0 +1,90 @@
+package top.leavesmc.leaves.protocol.syncmatica;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.block.Mirror;
+import net.minecraft.world.level.block.Rotation;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class SubRegionData {
+
+    private boolean isModified;
+    private Map<String, SubRegionPlacementModification> modificationData; // is null when isModified is false
+
+    public SubRegionData() {
+        this(false, null);
+    }
+
+    public SubRegionData(final boolean isModified, final Map<String, SubRegionPlacementModification> modificationData) {
+        this.isModified = isModified;
+        this.modificationData = modificationData;
+    }
+
+    public void reset() {
+        isModified = false;
+        modificationData = null;
+    }
+
+    public void modify(final String name, final BlockPos position, final Rotation rotation, final Mirror mirror) {
+        modify(new SubRegionPlacementModification(name, position, rotation, mirror));
+    }
+
+    public void modify(final SubRegionPlacementModification subRegionPlacementModification) {
+        if (subRegionPlacementModification == null) {
+            return;
+        }
+        isModified = true;
+        if (modificationData == null) {
+            modificationData = new HashMap<>();
+        }
+        modificationData.put(subRegionPlacementModification.name, subRegionPlacementModification);
+    }
+
+    public boolean isModified() {
+        return isModified;
+    }
+
+    public Map<String, SubRegionPlacementModification> getModificationData() {
+        return modificationData;
+    }
+
+    public JsonElement toJson() {
+        return modificationDataToJson();
+    }
+
+    @NotNull
+    private JsonElement modificationDataToJson() {
+        final JsonArray arr = new JsonArray();
+
+        for (final Map.Entry<String, SubRegionPlacementModification> entry : modificationData.entrySet()) {
+            arr.add(entry.getValue().toJson());
+        }
+
+        return arr;
+    }
+
+    @NotNull
+    public static SubRegionData fromJson(final @NotNull JsonElement obj) {
+        final SubRegionData newSubRegionData = new SubRegionData();
+
+        newSubRegionData.isModified = true;
+
+        for (final JsonElement modification : obj.getAsJsonArray()) {
+            newSubRegionData.modify(SubRegionPlacementModification.fromJson(modification.getAsJsonObject()));
+        }
+
+        return newSubRegionData;
+    }
+
+    @Override
+    public String toString() {
+        if (!isModified) {
+            return "[]";
+        }
+        return modificationData == null ? "[ERROR:null]" : modificationData.toString();
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/SubRegionPlacementModification.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/SubRegionPlacementModification.java
new file mode 100644
index 0000000000000000000000000000000000000000..0d67b562ed06f8de990c2f3d545e2839837f853d
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/SubRegionPlacementModification.java
@@ -0,0 +1,65 @@
+package top.leavesmc.leaves.protocol.syncmatica;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.block.Mirror;
+import net.minecraft.world.level.block.Rotation;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class SubRegionPlacementModification {
+
+    public final String name;
+    public final BlockPos position;
+    public final Rotation rotation;
+    public final Mirror mirror;
+
+    SubRegionPlacementModification(final String name, final BlockPos position, final Rotation rotation, final Mirror mirror) {
+        this.name = name;
+        this.position = position;
+        this.rotation = rotation;
+        this.mirror = mirror;
+    }
+
+    public JsonObject toJson() {
+        final JsonObject obj = new JsonObject();
+
+        final JsonArray arr = new JsonArray();
+        arr.add(position.getX());
+        arr.add(position.getY());
+        arr.add(position.getZ());
+        obj.add("position", arr);
+
+        obj.add("name", new JsonPrimitive(name));
+        obj.add("rotation", new JsonPrimitive(rotation.name()));
+        obj.add("mirror", new JsonPrimitive(mirror.name()));
+
+        return obj;
+    }
+
+    @Nullable
+    public static SubRegionPlacementModification fromJson(final @NotNull JsonObject obj) {
+        if (!obj.has("name") || !obj.has("position") || !obj.has("rotation") || !obj.has("mirror")) {
+            return null;
+        }
+
+        final String name = obj.get("name").getAsString();
+        final JsonArray arr = obj.get("position").getAsJsonArray();
+        if (arr.size() != 3) {
+            return null;
+        }
+
+        final BlockPos position = new BlockPos(arr.get(0).getAsInt(), arr.get(1).getAsInt(), arr.get(2).getAsInt());
+        final Rotation rotation = Rotation.valueOf(obj.get("rotation").getAsString());
+        final Mirror mirror = Mirror.valueOf(obj.get("mirror").getAsString());
+
+        return new SubRegionPlacementModification(name, position, rotation, mirror);
+    }
+
+    @Override
+    public String toString() {
+        return String.format("[name=%s, position=%s, rotation=%s, mirror=%s]", name, position, rotation, mirror);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/SyncmaticManager.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/SyncmaticManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..9fbeef1ef528504276895faed4dba41ee0789e77
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/SyncmaticManager.java
@@ -0,0 +1,108 @@
+package top.leavesmc.leaves.protocol.syncmatica;
+
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+
+public class SyncmaticManager {
+
+    public static final String PLACEMENTS_JSON_KEY = "placements";
+    private final Map<UUID, ServerPlacement> schematics = new HashMap<>();
+
+    public void addPlacement(final ServerPlacement placement) {
+        schematics.put(placement.getId(), placement);
+        updateServerPlacement();
+    }
+
+    public ServerPlacement getPlacement(final UUID id) {
+        return schematics.get(id);
+    }
+
+    public Collection<ServerPlacement> getAll() {
+        return schematics.values();
+    }
+
+    public void removePlacement(final @NotNull ServerPlacement placement) {
+        schematics.remove(placement.getId());
+        updateServerPlacement();
+    }
+
+    public void updateServerPlacement() {
+        saveServer();
+    }
+
+    public void startup() {
+        loadServer();
+    }
+
+    private void saveServer() {
+        final JsonObject obj = new JsonObject();
+        final JsonArray arr = new JsonArray();
+
+        for (final ServerPlacement p : getAll()) {
+            arr.add(p.toJson());
+        }
+
+        obj.add(PLACEMENTS_JSON_KEY, arr);
+        final File backup = new File(SyncmaticaProtocol.getLitematicFolder(), "placements.json.bak");
+        final File incoming = new File(SyncmaticaProtocol.getLitematicFolder(), "placements.json.new");
+        final File current = new File(SyncmaticaProtocol.getLitematicFolder(), "placements.json");
+
+        try (final FileWriter writer = new FileWriter(incoming)) {
+            writer.write(new GsonBuilder().setPrettyPrinting().create().toJson(obj));
+        } catch (final IOException e) {
+            e.printStackTrace();
+            return;
+        }
+
+        SyncmaticaProtocol.backupAndReplace(backup.toPath(), current.toPath(), incoming.toPath());
+    }
+
+    private void loadServer() {
+        final File f = new File(SyncmaticaProtocol.getLitematicFolder(), "placements.json");
+        if (f.exists() && f.isFile() && f.canRead()) {
+            JsonElement element = null;
+            try {
+                final JsonParser parser = new JsonParser();
+                final FileReader reader = new FileReader(f);
+
+                element = parser.parse(reader);
+                reader.close();
+
+            } catch (final Exception e) {
+                e.printStackTrace();
+            }
+            if (element == null) {
+                return;
+            }
+            try {
+                final JsonObject obj = element.getAsJsonObject();
+                if (obj == null || !obj.has(PLACEMENTS_JSON_KEY)) {
+                    return;
+                }
+                final JsonArray arr = obj.getAsJsonArray(PLACEMENTS_JSON_KEY);
+                for (final JsonElement elem : arr) {
+                    final ServerPlacement placement = ServerPlacement.fromJson(elem.getAsJsonObject());
+                    if (placement != null) {
+                        schematics.put(placement.getId(), placement);
+                    }
+                }
+
+            } catch (final IllegalStateException | NullPointerException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/SyncmaticaProtocol.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/SyncmaticaProtocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..8f573eed1e124d70d7d6f2fd811df49b03a7f8b2
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/SyncmaticaProtocol.java
@@ -0,0 +1,123 @@
+package top.leavesmc.leaves.protocol.syncmatica;
+
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.LeavesConfig;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+import java.util.UUID;
+
+public class SyncmaticaProtocol {
+
+    public static final String PROTOCOL_ID = "syncmatica";
+    public static final String PROTOCOL_VERSION = "0.3.8";
+
+    private static final File litematicFolder = new File("." + File.separator + "syncmatics");
+    private static final PlayerIdentifierProvider playerIdentifierProvider = new PlayerIdentifierProvider();
+    private static final CommunicationManager communicationManager = new CommunicationManager();
+    private static final FeatureSet featureSet = new FeatureSet(Arrays.asList(Feature.values()));
+    private static final SyncmaticManager syncmaticManager = new SyncmaticManager();
+    private static final FileStorage fileStorage = new FileStorage();
+
+    public static File getLitematicFolder() {
+        return litematicFolder;
+    }
+
+    public static PlayerIdentifierProvider getPlayerIdentifierProvider() {
+        return playerIdentifierProvider;
+    }
+
+    public static CommunicationManager getCommunicationManager() {
+        return communicationManager;
+    }
+
+    public static FeatureSet getFeatureSet() {
+        return featureSet;
+    }
+
+    public static SyncmaticManager getSyncmaticManager() {
+        return syncmaticManager;
+    }
+
+    public static FileStorage getFileStorage() {
+        return fileStorage;
+    }
+
+    public static void init() {
+        litematicFolder.mkdirs();
+        syncmaticManager.startup();
+    }
+
+    @NotNull
+    public static UUID createChecksum(final @NotNull InputStream fis) throws NoSuchAlgorithmException, IOException {
+        final byte[] buffer = new byte[4096];
+        final MessageDigest messageDigest = MessageDigest.getInstance("MD5");
+        int numRead;
+
+        do {
+            numRead = fis.read(buffer);
+            if (numRead > 0) {
+                messageDigest.update(buffer, 0, numRead);
+            }
+        } while (numRead != -1);
+
+        fis.close();
+        return UUID.nameUUIDFromBytes(messageDigest.digest());
+    }
+
+    private static final int[] ILLEGAL_CHARS = {34, 60, 62, 124, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 58, 42, 63, 92, 47};
+    private static final String ILLEGAL_PATTERNS = "(^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\\..*)?$)|(^\\.\\.*$)";
+
+    @NotNull
+    public static String sanitizeFileName(final @NotNull String badFileName) {
+        final StringBuilder sanitized = new StringBuilder();
+        final int len = badFileName.codePointCount(0, badFileName.length());
+
+        for (int i = 0; i < len; i++) {
+            final int c = badFileName.codePointAt(i);
+            if (Arrays.binarySearch(ILLEGAL_CHARS, c) < 0) {
+                sanitized.appendCodePoint(c);
+                if (sanitized.length() == 255) {
+                    break;
+                }
+            }
+        }
+
+        return sanitized.toString().replaceAll(ILLEGAL_PATTERNS, "_");
+    }
+
+    public static boolean isOverQuota(int sent) {
+        return LeavesConfig.syncmaticaQuota && sent > LeavesConfig.syncmaticaQuotaLimit;
+    }
+
+    public static void backupAndReplace(final Path backup, final Path current, final Path incoming) {
+        if (!Files.exists(incoming)) {
+            return;
+        }
+        if (overwrite(backup, current, 2) && !overwrite(current, incoming, 4)) {
+            overwrite(current, backup, 8);
+        }
+    }
+
+    private static boolean overwrite(final Path backup, final Path current, final int tries) {
+        if (!Files.exists(current)) {
+            return true;
+        }
+        try {
+            Files.deleteIfExists(backup);
+            Files.move(current, backup);
+        } catch (final IOException exception) {
+            if (tries <= 0) {
+                return false;
+            }
+            return overwrite(backup, current, tries - 1);
+        }
+        return true;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/AbstractExchange.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/AbstractExchange.java
new file mode 100644
index 0000000000000000000000000000000000000000..625974f9ce0791b476336abafa6aa1af2f2ffbac
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/AbstractExchange.java
@@ -0,0 +1,66 @@
+package top.leavesmc.leaves.protocol.syncmatica.exchange;
+
+import net.minecraft.network.FriendlyByteBuf;
+import top.leavesmc.leaves.protocol.syncmatica.CommunicationManager;
+import top.leavesmc.leaves.protocol.syncmatica.SyncmaticaProtocol;
+
+import java.util.UUID;
+
+public abstract class AbstractExchange implements Exchange {
+
+    private boolean success = false;
+    private boolean finished = false;
+    private final ExchangeTarget partner;
+
+    protected AbstractExchange(final ExchangeTarget partner) {
+        this.partner = partner;
+    }
+
+    @Override
+    public ExchangeTarget getPartner() {
+        return partner;
+    }
+
+    @Override
+    public boolean isFinished() {
+        return finished;
+    }
+
+    @Override
+    public boolean isSuccessful() {
+        return success;
+    }
+
+    @Override
+    public void close(final boolean notifyPartner) {
+        finished = true;
+        success = false;
+        onClose();
+        if (notifyPartner) {
+            sendCancelPacket();
+        }
+    }
+
+    public CommunicationManager getManager() {
+        return SyncmaticaProtocol.getCommunicationManager();
+    }
+
+    protected void sendCancelPacket() {
+    }
+
+    protected void onClose() {
+    }
+
+    protected void succeed() {
+        finished = true;
+        success = true;
+        onClose();
+    }
+
+    protected static boolean checkUUID(final FriendlyByteBuf sourceBuf, final UUID targetId) {
+        final int r = sourceBuf.readerIndex();
+        final UUID sourceId = sourceBuf.readUUID();
+        sourceBuf.readerIndex(r);
+        return sourceId.equals(targetId);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/DownloadExchange.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/DownloadExchange.java
new file mode 100644
index 0000000000000000000000000000000000000000..7303769570656f36a3a76215e22020b1292007fb
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/DownloadExchange.java
@@ -0,0 +1,125 @@
+package top.leavesmc.leaves.protocol.syncmatica.exchange;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.protocol.syncmatica.MessageType;
+import top.leavesmc.leaves.protocol.syncmatica.PacketType;
+import top.leavesmc.leaves.protocol.syncmatica.ServerPlacement;
+import top.leavesmc.leaves.protocol.syncmatica.SyncmaticaProtocol;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.security.DigestOutputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.UUID;
+
+public class DownloadExchange extends AbstractExchange {
+
+    private final ServerPlacement toDownload;
+    private final OutputStream outputStream;
+    private final MessageDigest md5;
+    private final File downloadFile;
+    private int bytesSent;
+
+    public DownloadExchange(final ServerPlacement syncmatic, final File downloadFile, final ExchangeTarget partner) throws IOException, NoSuchAlgorithmException {
+        super(partner);
+        this.downloadFile = downloadFile;
+        final OutputStream os = new FileOutputStream(downloadFile);
+        toDownload = syncmatic;
+        md5 = MessageDigest.getInstance("MD5");
+        outputStream = new DigestOutputStream(os, md5);
+    }
+
+    @Override
+    public boolean checkPacket(final @NotNull ResourceLocation id, final FriendlyByteBuf packetBuf) {
+        if (id.equals(PacketType.SEND_LITEMATIC.identifier)
+            || id.equals(PacketType.FINISHED_LITEMATIC.identifier)
+            || id.equals(PacketType.CANCEL_LITEMATIC.identifier)) {
+            return checkUUID(packetBuf, toDownload.getId());
+        }
+        return false;
+    }
+
+    @Override
+    public void handle(final @NotNull ResourceLocation id, final @NotNull FriendlyByteBuf packetBuf) {
+        packetBuf.readUUID();
+        if (id.equals(PacketType.SEND_LITEMATIC.identifier)) {
+            final int size = packetBuf.readInt();
+            bytesSent += size;
+            if (SyncmaticaProtocol.isOverQuota(bytesSent)) {
+                close(true);
+                SyncmaticaProtocol.getCommunicationManager().sendMessage(
+                    getPartner(),
+                    MessageType.ERROR,
+                    "syncmatica.error.cancelled_transmit_exceed_quota"
+                );
+            }
+            try {
+                packetBuf.readBytes(outputStream, size);
+            } catch (final IOException e) {
+                close(true);
+                e.printStackTrace();
+                return;
+            }
+            final FriendlyByteBuf FriendlyByteBuf = new FriendlyByteBuf(Unpooled.buffer());
+            FriendlyByteBuf.writeUUID(toDownload.getId());
+            getPartner().sendPacket(PacketType.RECEIVED_LITEMATIC.identifier, FriendlyByteBuf);
+            return;
+        }
+        if (id.equals(PacketType.FINISHED_LITEMATIC.identifier)) {
+            try {
+                outputStream.flush();
+            } catch (final IOException e) {
+                close(false);
+                e.printStackTrace();
+                return;
+            }
+            final UUID downloadHash = UUID.nameUUIDFromBytes(md5.digest());
+            if (downloadHash.equals(toDownload.getHash())) {
+                succeed();
+            } else {
+                close(false);
+            }
+            return;
+        }
+        if (id.equals(PacketType.CANCEL_LITEMATIC.identifier)) {
+            close(false);
+        }
+    }
+
+    @Override
+    public void init() {
+        final FriendlyByteBuf FriendlyByteBuf = new FriendlyByteBuf(Unpooled.buffer());
+        FriendlyByteBuf.writeUUID(toDownload.getId());
+        getPartner().sendPacket(PacketType.REQUEST_LITEMATIC.identifier, FriendlyByteBuf);
+    }
+
+    @Override
+    protected void onClose() {
+        getManager().setDownloadState(toDownload, false);
+        try {
+            outputStream.close();
+        } catch (final IOException e) {
+            e.printStackTrace();
+        }
+        if (!isSuccessful() && downloadFile.exists()) {
+            downloadFile.delete();
+        }
+    }
+
+    @Override
+    protected void sendCancelPacket() {
+        final FriendlyByteBuf FriendlyByteBuf = new FriendlyByteBuf(Unpooled.buffer());
+        FriendlyByteBuf.writeUUID(toDownload.getId());
+        getPartner().sendPacket(PacketType.CANCEL_LITEMATIC.identifier, FriendlyByteBuf);
+    }
+
+    public ServerPlacement getPlacement() {
+        return toDownload;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/Exchange.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/Exchange.java
new file mode 100644
index 0000000000000000000000000000000000000000..26482e63b7c24c80bdc111cea51b8d7b8052d64e
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/Exchange.java
@@ -0,0 +1,20 @@
+package top.leavesmc.leaves.protocol.syncmatica.exchange;
+
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+
+public interface Exchange {
+    ExchangeTarget getPartner();
+
+    boolean checkPacket(ResourceLocation id, FriendlyByteBuf packetBuf);
+
+    void handle(ResourceLocation id, FriendlyByteBuf packetBuf);
+
+    boolean isFinished();
+
+    boolean isSuccessful();
+
+    void close(boolean notifyPartner);
+
+    void init();
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/ExchangeTarget.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/ExchangeTarget.java
new file mode 100644
index 0000000000000000000000000000000000000000..eae6aab5cb02ea167ebfbfcb5e3f20f933ee6d39
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/ExchangeTarget.java
@@ -0,0 +1,38 @@
+package top.leavesmc.leaves.protocol.syncmatica.exchange;
+
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.game.ClientboundCustomPayloadPacket;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.network.ServerGamePacketListenerImpl;
+import top.leavesmc.leaves.protocol.syncmatica.FeatureSet;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+public class ExchangeTarget {
+
+    private final List<Exchange> ongoingExchanges = new ArrayList<>();
+    private final ServerGamePacketListenerImpl client;
+    private FeatureSet features;
+
+    public ExchangeTarget(final ServerGamePacketListenerImpl client) {
+        this.client = client;
+    }
+
+    public void sendPacket(final ResourceLocation id, final FriendlyByteBuf packetBuf) {
+        client.send(new ClientboundCustomPayloadPacket(id, packetBuf));
+    }
+
+    public FeatureSet getFeatureSet() {
+        return features;
+    }
+
+    public void setFeatureSet(final FeatureSet f) {
+        features = f;
+    }
+
+    public Collection<Exchange> getExchanges() {
+        return ongoingExchanges;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/FeatureExchange.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/FeatureExchange.java
new file mode 100644
index 0000000000000000000000000000000000000000..f92739dbfa00de0e078834818dab79e34fc3d245
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/FeatureExchange.java
@@ -0,0 +1,48 @@
+package top.leavesmc.leaves.protocol.syncmatica.exchange;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.protocol.syncmatica.FeatureSet;
+import top.leavesmc.leaves.protocol.syncmatica.PacketType;
+import top.leavesmc.leaves.protocol.syncmatica.SyncmaticaProtocol;
+
+public abstract class FeatureExchange extends AbstractExchange {
+
+    protected FeatureExchange(final ExchangeTarget partner) {
+        super(partner);
+    }
+
+    @Override
+    public boolean checkPacket(final @NotNull ResourceLocation id, final FriendlyByteBuf packetBuf) {
+        return id.equals(PacketType.FEATURE_REQUEST.identifier)
+            || id.equals(PacketType.FEATURE.identifier);
+    }
+
+    @Override
+    public void handle(final @NotNull ResourceLocation id, final FriendlyByteBuf packetBuf) {
+        if (id.equals(PacketType.FEATURE_REQUEST.identifier)) {
+            sendFeatures();
+        } else if (id.equals(PacketType.FEATURE.identifier)) {
+            final FeatureSet fs = FeatureSet.fromString(packetBuf.readUtf(32767));
+            getPartner().setFeatureSet(fs);
+            onFeatureSetReceive();
+        }
+    }
+
+    protected void onFeatureSetReceive() {
+        succeed();
+    }
+
+    public void requestFeatureSet() {
+        getPartner().sendPacket(PacketType.FEATURE_REQUEST.identifier, new FriendlyByteBuf(Unpooled.buffer()));
+    }
+
+    private void sendFeatures() {
+        final FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+        final FeatureSet fs = SyncmaticaProtocol.getFeatureSet();
+        buf.writeUtf(fs.toString(), 32767);
+        getPartner().sendPacket(PacketType.FEATURE.identifier, buf);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/ModifyExchangeServer.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/ModifyExchangeServer.java
new file mode 100644
index 0000000000000000000000000000000000000000..b78c71ceb67aca814e8c7c772e079a8ab1bc2641
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/ModifyExchangeServer.java
@@ -0,0 +1,77 @@
+package top.leavesmc.leaves.protocol.syncmatica.exchange;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.protocol.syncmatica.PacketType;
+import top.leavesmc.leaves.protocol.syncmatica.PlayerIdentifier;
+import top.leavesmc.leaves.protocol.syncmatica.ServerPlacement;
+import top.leavesmc.leaves.protocol.syncmatica.SyncmaticaProtocol;
+
+import java.util.UUID;
+
+public class ModifyExchangeServer extends AbstractExchange {
+
+    private final ServerPlacement placement;
+    UUID placementId;
+
+    public ModifyExchangeServer(final UUID placeId, final ExchangeTarget partner) {
+        super(partner);
+        placementId = placeId;
+        placement = SyncmaticaProtocol.getSyncmaticManager().getPlacement(placementId);
+    }
+
+    @Override
+    public boolean checkPacket(final @NotNull ResourceLocation id, final FriendlyByteBuf packetBuf) {
+        return id.equals(PacketType.MODIFY_FINISH.identifier) && checkUUID(packetBuf, placement.getId());
+    }
+
+    @Override
+    public void handle(final @NotNull ResourceLocation id, final @NotNull FriendlyByteBuf packetBuf) {
+        packetBuf.readUUID();
+        if (id.equals(PacketType.MODIFY_FINISH.identifier)) {
+            SyncmaticaProtocol.getCommunicationManager().receivePositionData(placement, packetBuf, getPartner());
+            final PlayerIdentifier identifier = SyncmaticaProtocol.getPlayerIdentifierProvider().createOrGet(
+                getPartner()
+            );
+            placement.setLastModifiedBy(identifier);
+            SyncmaticaProtocol.getSyncmaticManager().updateServerPlacement();
+            succeed();
+        }
+    }
+
+    @Override
+    public void init() {
+        if (getPlacement() == null || SyncmaticaProtocol.getCommunicationManager().getModifier(placement) != null) {
+            close(true);
+        } else {
+            accept();
+        }
+    }
+
+    private void accept() {
+        final FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+        buf.writeUUID(placement.getId());
+        getPartner().sendPacket(PacketType.MODIFY_REQUEST_ACCEPT.identifier, buf);
+        SyncmaticaProtocol.getCommunicationManager().setModifier(placement, this);
+    }
+
+    @Override
+    protected void sendCancelPacket() {
+        final FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+        buf.writeUUID(placementId);
+        getPartner().sendPacket(PacketType.MODIFY_REQUEST_DENY.identifier, buf);
+    }
+
+    public ServerPlacement getPlacement() {
+        return placement;
+    }
+
+    @Override
+    protected void onClose() {
+        if (SyncmaticaProtocol.getCommunicationManager().getModifier(placement) == this) {
+            SyncmaticaProtocol.getCommunicationManager().setModifier(placement, null);
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/UploadExchange.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/UploadExchange.java
new file mode 100644
index 0000000000000000000000000000000000000000..9a1b37c69a3946b8f042a1118bf7dcf6ff0967ae
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/UploadExchange.java
@@ -0,0 +1,101 @@
+package top.leavesmc.leaves.protocol.syncmatica.exchange;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.protocol.syncmatica.PacketType;
+import top.leavesmc.leaves.protocol.syncmatica.ServerPlacement;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+
+public class UploadExchange extends AbstractExchange {
+
+    private static final int BUFFER_SIZE = 16384;
+
+    private final ServerPlacement toUpload;
+    private final InputStream inputStream;
+    private final byte[] buffer = new byte[BUFFER_SIZE];
+
+    public UploadExchange(final ServerPlacement syncmatic, final File uploadFile, final ExchangeTarget partner) throws FileNotFoundException {
+        super(partner);
+        toUpload = syncmatic;
+        inputStream = new FileInputStream(uploadFile);
+    }
+
+    @Override
+    public boolean checkPacket(final @NotNull ResourceLocation id, final FriendlyByteBuf packetBuf) {
+        if (id.equals(PacketType.RECEIVED_LITEMATIC.identifier)
+            || id.equals(PacketType.CANCEL_LITEMATIC.identifier)) {
+            return checkUUID(packetBuf, toUpload.getId());
+        }
+        return false;
+    }
+
+    @Override
+    public void handle(final @NotNull ResourceLocation id, final @NotNull FriendlyByteBuf packetBuf) {
+        packetBuf.readUUID();
+        if (id.equals(PacketType.RECEIVED_LITEMATIC.identifier)) {
+            send();
+        }
+        if (id.equals(PacketType.CANCEL_LITEMATIC.identifier)) {
+            close(false);
+        }
+    }
+
+    private void send() {
+        final int bytesRead;
+        try {
+            bytesRead = inputStream.read(buffer);
+        } catch (final IOException e) {
+            close(true);
+            e.printStackTrace();
+            return;
+        }
+        if (bytesRead == -1) {
+            sendFinish();
+        } else {
+            sendData(bytesRead);
+        }
+    }
+
+    private void sendData(final int bytesRead) {
+        final FriendlyByteBuf FriendlyByteBuf = new FriendlyByteBuf(Unpooled.buffer());
+        FriendlyByteBuf.writeUUID(toUpload.getId());
+        FriendlyByteBuf.writeInt(bytesRead);
+        FriendlyByteBuf.writeBytes(buffer, 0, bytesRead);
+        getPartner().sendPacket(PacketType.SEND_LITEMATIC.identifier, FriendlyByteBuf);
+    }
+
+    private void sendFinish() {
+        final FriendlyByteBuf FriendlyByteBuf = new FriendlyByteBuf(Unpooled.buffer());
+        FriendlyByteBuf.writeUUID(toUpload.getId());
+        getPartner().sendPacket(PacketType.FINISHED_LITEMATIC.identifier, FriendlyByteBuf);
+        succeed();
+    }
+
+    @Override
+    public void init() {
+        send();
+    }
+
+    @Override
+    protected void onClose() {
+        try {
+            inputStream.close();
+        } catch (final IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    protected void sendCancelPacket() {
+        final FriendlyByteBuf FriendlyByteBuf = new FriendlyByteBuf(Unpooled.buffer());
+        FriendlyByteBuf.writeUUID(toUpload.getId());
+        getPartner().sendPacket(PacketType.CANCEL_LITEMATIC.identifier, FriendlyByteBuf);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/VersionHandshakeServer.java b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/VersionHandshakeServer.java
new file mode 100644
index 0000000000000000000000000000000000000000..448d5e8423347c0154a146906617e32e18fbc30f
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/syncmatica/exchange/VersionHandshakeServer.java
@@ -0,0 +1,65 @@
+package top.leavesmc.leaves.protocol.syncmatica.exchange;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.protocol.syncmatica.FeatureSet;
+import top.leavesmc.leaves.protocol.syncmatica.PacketType;
+import top.leavesmc.leaves.protocol.syncmatica.ServerPlacement;
+import top.leavesmc.leaves.protocol.syncmatica.SyncmaticaProtocol;
+
+import java.util.Collection;
+
+public class VersionHandshakeServer extends FeatureExchange {
+
+    public VersionHandshakeServer(final ExchangeTarget partner) {
+        super(partner);
+    }
+
+    @Override
+    public boolean checkPacket(final @NotNull ResourceLocation id, final FriendlyByteBuf packetBuf) {
+        return id.equals(PacketType.REGISTER_VERSION.identifier)
+            || super.checkPacket(id, packetBuf);
+    }
+
+    @Override
+    public void handle(final @NotNull ResourceLocation id, final FriendlyByteBuf packetBuf) {
+        if (id.equals(PacketType.REGISTER_VERSION.identifier)) {
+            String partnerVersion = packetBuf.readUtf(32767);
+            if (partnerVersion.equals("0.0.1")) {
+                close(false);
+                return;
+            }
+            final FeatureSet fs = FeatureSet.fromVersionString(partnerVersion);
+            if (fs == null) {
+                requestFeatureSet();
+            } else {
+                getPartner().setFeatureSet(fs);
+                onFeatureSetReceive();
+            }
+        } else {
+            super.handle(id, packetBuf);
+        }
+
+    }
+
+    @Override
+    public void onFeatureSetReceive() {
+        final FriendlyByteBuf newBuf = new FriendlyByteBuf(Unpooled.buffer());
+        final Collection<ServerPlacement> l = SyncmaticaProtocol.getSyncmaticManager().getAll();
+        newBuf.writeInt(l.size());
+        for (final ServerPlacement p : l) {
+            getManager().putMetaData(p, newBuf, getPartner());
+        }
+        getPartner().sendPacket(PacketType.CONFIRM_USER.identifier, newBuf);
+        succeed();
+    }
+
+    @Override
+    public void init() {
+        final FriendlyByteBuf newBuf = new FriendlyByteBuf(Unpooled.buffer());
+        newBuf.writeUtf(SyncmaticaProtocol.PROTOCOL_VERSION);
+        getPartner().sendPacket(PacketType.REGISTER_VERSION.identifier, newBuf);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/structs/FluidDirectionCache.java b/src/main/java/top/leavesmc/leaves/structs/FluidDirectionCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..30dc532e75bc4dd7ddb086ffb24118cf4b7b5d2f
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/structs/FluidDirectionCache.java
@@ -0,0 +1,138 @@
+package top.leavesmc.leaves.structs;
+
+import it.unimi.dsi.fastutil.HashCommon;
+
+// Powered by Pufferfish(https://github.com/pufferfish-gg/Pufferfish)
+
+/**
+ * This is a replacement for the cache used in FluidTypeFlowing.
+ * The requirements for the previous cache were:
+ * - Store 200 entries
+ * - Look for the flag in the cache
+ * - If it exists, move to front of cache
+ * - If it doesn't exist, remove last entry in cache and insert in front
+ * <p>
+ * This class accomplishes something similar, however has a few different
+ * requirements put into place to make this more optimize:
+ * <p>
+ * - maxDistance is the most amount of entries to be checked, instead
+ * of having to check the entire list.
+ * - In combination with that, entries are all tracked by age and how
+ * frequently they're used. This enables us to remove old entries,
+ * without constantly shifting any around.
+ * <p>
+ * Usage of the previous map would have to reset the head every single usage,
+ * shifting the entire map. Here, nothing happens except an increment when
+ * the cache is hit, and when it needs to replace an old element only a single
+ * element is modified.
+ */
+public class FluidDirectionCache<T> {
+
+    private static class FluidDirectionEntry<T> {
+        private final T data;
+        private final boolean flag;
+        private int uses = 0;
+        private int age = 0;
+
+        private FluidDirectionEntry(T data, boolean flag) {
+            this.data = data;
+            this.flag = flag;
+        }
+
+        public int getValue() {
+            return this.uses - (this.age >> 1); // age isn't as important as uses
+        }
+
+        public void incrementUses() {
+            this.uses = this.uses + 1 & Integer.MAX_VALUE;
+        }
+
+        public void incrementAge() {
+            this.age = this.age + 1 & Integer.MAX_VALUE;
+        }
+    }
+
+    private final FluidDirectionEntry[] entries;
+    private final int mask;
+    private final int maxDistance; // the most amount of entries to check for a value
+
+    public FluidDirectionCache(int size) {
+        int arraySize = HashCommon.nextPowerOfTwo(size);
+        this.entries = new FluidDirectionEntry[arraySize];
+        this.mask = arraySize - 1;
+        this.maxDistance = Math.min(arraySize, 4);
+    }
+
+    public Boolean getValue(T data) {
+        FluidDirectionEntry curr;
+        int pos;
+
+        if ((curr = this.entries[pos = HashCommon.mix(data.hashCode()) & this.mask]) == null) {
+            return null;
+        } else if (data.equals(curr.data)) {
+            curr.incrementUses();
+            return curr.flag;
+        }
+
+        int checked = 1; // start at 1 because we already checked the first spot above
+
+        while ((curr = this.entries[pos = (pos + 1) & this.mask]) != null) {
+            if (data.equals(curr.data)) {
+                curr.incrementUses();
+                return curr.flag;
+            } else if (++checked >= this.maxDistance) {
+                break;
+            }
+        }
+
+        return null;
+    }
+
+    public void putValue(T data, boolean flag) {
+        FluidDirectionEntry<T> curr;
+        int pos;
+
+        if ((curr = this.entries[pos = HashCommon.mix(data.hashCode()) & this.mask]) == null) {
+            this.entries[pos] = new FluidDirectionEntry<>(data, flag); // add
+            return;
+        } else if (data.equals(curr.data)) {
+            curr.incrementUses();
+            return;
+        }
+
+        int checked = 1; // start at 1 because we already checked the first spot above
+
+        while ((curr = this.entries[pos = (pos + 1) & this.mask]) != null) {
+            if (data.equals(curr.data)) {
+                curr.incrementUses();
+                return;
+            } else if (++checked >= this.maxDistance) {
+                this.forceAdd(data, flag);
+                return;
+            }
+        }
+
+        this.entries[pos] = new FluidDirectionEntry<>(data, flag); // add
+    }
+
+    private void forceAdd(T data, boolean flag) {
+        int expectedPos = HashCommon.mix(data.hashCode()) & this.mask;
+
+        int toRemovePos = expectedPos;
+        FluidDirectionEntry entryToRemove = this.entries[toRemovePos];
+
+        for (int i = expectedPos + 1; i < expectedPos + this.maxDistance; i++) {
+            int pos = i & this.mask;
+            FluidDirectionEntry entry = this.entries[pos];
+            if (entry.getValue() < entryToRemove.getValue()) {
+                toRemovePos = pos;
+                entryToRemove = entry;
+            }
+
+            entry.incrementAge(); // use this as a mechanism to age the other entries
+        }
+
+        // remove the least used/oldest entry
+        this.entries[toRemovePos] = new FluidDirectionEntry(data, flag);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/structs/Long2FloatAgingCache.java b/src/main/java/top/leavesmc/leaves/structs/Long2FloatAgingCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..26f9d4d9099739d6ddc159184a20e2ae9abde5cd
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/structs/Long2FloatAgingCache.java
@@ -0,0 +1,121 @@
+package top.leavesmc.leaves.structs;
+
+import it.unimi.dsi.fastutil.HashCommon;
+
+// Powered by Pufferfish(https://github.com/pufferfish-gg/Pufferfish)
+
+/**
+ * A replacement for the cache used in Biome.
+ */
+public class Long2FloatAgingCache {
+
+    private static class AgingEntry {
+        private long data;
+        private float value;
+        private int uses = 0;
+        private int age = 0;
+
+        private AgingEntry(long data, float value) {
+            this.data = data;
+            this.value = value;
+        }
+
+        public void replace(long data, float flag) {
+            this.data = data;
+            this.value = flag;
+        }
+
+        public int getValue() {
+            return this.uses - (this.age >> 1); // age isn't as important as uses
+        }
+
+        public void incrementUses() {
+            this.uses = this.uses + 1 & Integer.MAX_VALUE;
+        }
+
+        public void incrementAge() {
+            this.age = this.age + 1 & Integer.MAX_VALUE;
+        }
+    }
+
+    private final AgingEntry[] entries;
+    private final int mask;
+    private final int maxDistance; // the most amount of entries to check for a value
+
+    public Long2FloatAgingCache(int size) {
+        int arraySize = HashCommon.nextPowerOfTwo(size);
+        this.entries = new AgingEntry[arraySize];
+        this.mask = arraySize - 1;
+        this.maxDistance = Math.min(arraySize, 4);
+    }
+
+    public float getValue(long data) {
+        AgingEntry curr;
+        int pos;
+
+        if ((curr = this.entries[pos = HashCommon.mix(HashCommon.long2int(data)) & this.mask]) == null) {
+            return Float.NaN;
+        } else if (data == curr.data) {
+            curr.incrementUses();
+            return curr.value;
+        }
+
+        int checked = 1; // start at 1 because we already checked the first spot above
+
+        while ((curr = this.entries[pos = (pos + 1) & this.mask]) != null) {
+            if (data == curr.data) {
+                curr.incrementUses();
+                return curr.value;
+            } else if (++checked >= this.maxDistance) {
+                break;
+            }
+        }
+
+        return Float.NaN;
+    }
+
+    public void putValue(long data, float value) {
+        AgingEntry curr;
+        int pos;
+
+        if ((curr = this.entries[pos = HashCommon.mix(HashCommon.long2int(data)) & this.mask]) == null) {
+            this.entries[pos] = new AgingEntry(data, value); // add
+            return;
+        } else if (data == curr.data) {
+            curr.incrementUses();
+            return;
+        }
+
+        int checked = 1; // start at 1 because we already checked the first spot above
+
+        while ((curr = this.entries[pos = (pos + 1) & this.mask]) != null) {
+            if (data == curr.data) {
+                curr.incrementUses();
+                return;
+            } else if (++checked >= this.maxDistance) {
+                this.forceAdd(data, value);
+                return;
+            }
+        }
+
+        this.entries[pos] = new AgingEntry(data, value); // add
+    }
+
+    private void forceAdd(long data, float value) {
+        int expectedPos = HashCommon.mix(HashCommon.long2int(data)) & this.mask;
+        AgingEntry entryToRemove = this.entries[expectedPos];
+
+        for (int i = expectedPos + 1; i < expectedPos + this.maxDistance; i++) {
+            int pos = i & this.mask;
+            AgingEntry entry = this.entries[pos];
+            if (entry.getValue() < entryToRemove.getValue()) {
+                entryToRemove = entry;
+            }
+
+            entry.incrementAge(); // use this as a mechanism to age the other entries
+        }
+
+        // remove the least used/oldest entry
+        entryToRemove.replace(data, value);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/ArrayConstants.java b/src/main/java/top/leavesmc/leaves/util/ArrayConstants.java
new file mode 100644
index 0000000000000000000000000000000000000000..0523062a825bd36f335f1fa6e1440eaaf400fd58
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/ArrayConstants.java
@@ -0,0 +1,21 @@
+package top.leavesmc.leaves.util;
+
+import net.minecraft.server.level.ServerLevel;
+
+// Powered by Gale(https://github.com/GaleMC/Gale)
+
+public class ArrayConstants {
+
+    private ArrayConstants() {}
+
+    public static final Object[] emptyObjectArray = new Object[0];
+    public static final int[] emptyIntArray = new int[0];
+    public static final int[] zeroSingletonIntArray = new int[]{0};
+    public static final byte[] emptyByteArray = new byte[0];
+    public static final String[] emptyStringArray = new String[0];
+    public static final long[] emptyLongArray = new long[0];
+    public static final org.bukkit.entity.Entity[] emptyBukkitEntityArray = new org.bukkit.entity.Entity[0];
+    public static final net.minecraft.world.entity.Entity[] emptyEntityArray = new net.minecraft.world.entity.Entity[0];
+    public static final ServerLevel[] emptyServerLevelArray = new ServerLevel[0];
+
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/AsyncExecutor.java b/src/main/java/top/leavesmc/leaves/util/AsyncExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..0c03f3f051eff7abaacfaa8adb992811f934b9c8
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/AsyncExecutor.java
@@ -0,0 +1,76 @@
+package top.leavesmc.leaves.util;
+
+import com.google.common.collect.Queues;
+import top.leavesmc.leaves.LeavesLogger;
+
+import java.util.Queue;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.logging.Level;
+
+// Powered by Pufferfish(https://github.com/pufferfish-gg/Pufferfish)
+public class AsyncExecutor implements Runnable {
+
+    private final Queue<Runnable> jobs = Queues.newArrayDeque();
+    private final Lock mutex = new ReentrantLock();
+    private final Condition cond = mutex.newCondition();
+    private final Thread thread;
+    private volatile boolean killswitch = false;
+
+    public AsyncExecutor(String threadName) {
+        this.thread = new Thread(this, threadName);
+    }
+
+    public void start() {
+        thread.start();
+    }
+
+    public void kill() {
+        killswitch = true;
+        cond.signalAll();
+    }
+
+    public void submit(Runnable runnable) {
+        mutex.lock();
+        try {
+            jobs.offer(runnable);
+            cond.signalAll();
+        } finally {
+            mutex.unlock();
+        }
+    }
+
+    @Override
+    public void run() {
+        while (!killswitch) {
+            try {
+                Runnable runnable = takeRunnable();
+                if (runnable != null) {
+                    runnable.run();
+                }
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt();
+            } catch (Exception e) {
+                LeavesLogger.LOGGER.log(Level.SEVERE, e, () -> "Failed to execute async job for thread " + thread.getName());
+            }
+        }
+    }
+
+    private Runnable takeRunnable() throws InterruptedException {
+        mutex.lock();
+        try {
+            while (jobs.isEmpty() && !killswitch) {
+                cond.await();
+            }
+
+            if (jobs.isEmpty()) {
+                return null;
+            }
+
+            return jobs.remove();
+        } finally {
+            mutex.unlock();
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/AsyncPlayerAreaMap.java b/src/main/java/top/leavesmc/leaves/util/AsyncPlayerAreaMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..4ccc1b3b29e9d62526b2d7c56ef06db77704bf80
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/AsyncPlayerAreaMap.java
@@ -0,0 +1,32 @@
+package top.leavesmc.leaves.util;
+
+import com.destroystokyo.paper.util.misc.PlayerAreaMap;
+import com.destroystokyo.paper.util.misc.PooledLinkedHashSets;
+import net.minecraft.server.level.ServerPlayer;
+
+import java.util.concurrent.ConcurrentHashMap;
+
+// Powered by Pufferfish(https://github.com/pufferfish-gg/Pufferfish)
+public class AsyncPlayerAreaMap extends PlayerAreaMap {
+
+    public AsyncPlayerAreaMap() {
+        super();
+        this.areaMap = new Long2ObjectOpenHashMapWrapper<>(new ConcurrentHashMap<>(1024, 0.7f));
+    }
+
+    public AsyncPlayerAreaMap(final PooledLinkedHashSets<ServerPlayer> pooledHashSets) {
+        super(pooledHashSets);
+        this.areaMap = new Long2ObjectOpenHashMapWrapper<>(new ConcurrentHashMap<>(1024, 0.7f));
+    }
+
+    public AsyncPlayerAreaMap(final PooledLinkedHashSets<ServerPlayer> pooledHashSets, final ChangeCallback<ServerPlayer> addCallback,
+                              final ChangeCallback<ServerPlayer> removeCallback) {
+        this(pooledHashSets, addCallback, removeCallback, null);
+    }
+
+    public AsyncPlayerAreaMap(final PooledLinkedHashSets<ServerPlayer> pooledHashSets, final ChangeCallback<ServerPlayer> addCallback,
+                              final ChangeCallback<ServerPlayer> removeCallback, final ChangeSourceCallback<ServerPlayer> changeSourceCallback) {
+        super(pooledHashSets, addCallback, removeCallback, changeSourceCallback);
+        this.areaMap = new Long2ObjectOpenHashMapWrapper<>(new ConcurrentHashMap<>(1024, 0.7f));
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/BlockPatternHelper.java b/src/main/java/top/leavesmc/leaves/util/BlockPatternHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..cbe424356db5237c261320f0ad5ef5bcf2c70ed4
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/BlockPatternHelper.java
@@ -0,0 +1,28 @@
+package top.leavesmc.leaves.util;
+
+import com.google.common.cache.LoadingCache;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.state.pattern.BlockInWorld;
+import net.minecraft.world.level.block.state.pattern.BlockPattern;
+
+// Powered by Carpet-AMS-Addition(https://github.com/Minecraft-AMS/Carpet-AMS-Addition)
+public class BlockPatternHelper {
+    public static BlockPattern.BlockPatternMatch partialSearchAround(BlockPattern pattern, Level world, BlockPos pos) {
+        LoadingCache<BlockPos, BlockInWorld> loadingCache = BlockPattern.createLevelCache(world, false);
+        int i = Math.max(Math.max(pattern.getWidth(), pattern.getHeight()), pattern.getDepth());
+
+        for (BlockPos blockPos : BlockPos.betweenClosed(pos, pos.offset(i - 1, 0, i - 1))) {
+            for (Direction direction : Direction.values()) {
+                for (Direction direction2 : Direction.values()) {
+                    BlockPattern.BlockPatternMatch result;
+                    if (direction2 == direction || direction2 == direction.getOpposite() || (result = pattern.matches(blockPos, direction, direction2, loadingCache)) == null)
+                        continue;
+                    return result;
+                }
+            }
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/BreakBedrockList.java b/src/main/java/top/leavesmc/leaves/util/BreakBedrockList.java
new file mode 100644
index 0000000000000000000000000000000000000000..a1194aca9f70a44472d1f2ce0cbd6a3e0463eba9
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/BreakBedrockList.java
@@ -0,0 +1,114 @@
+package top.leavesmc.leaves.util;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.DirectionalBlock;
+import net.minecraft.world.scores.Objective;
+import net.minecraft.world.scores.criteria.ObjectiveCriteria;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.LeavesConfig;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class BreakBedrockList {
+
+    private static final Map<Level, Map<BlockPos, Player>> pistonCache = new HashMap<>();
+    private static final List<Objective> BBL = new ArrayList<>();
+    private static final List<Objective> MBB = new ArrayList<>();
+    private static final List<Objective> LBL = new ArrayList<>();
+
+    public static void endTick() {
+        for (var map : pistonCache.values()) {
+            if (!map.isEmpty()) {
+                map.clear();
+            }
+        }
+    }
+
+    public static void onPlayerPlacePiston(Level level, Player player, BlockPos pos) {
+        if (LeavesConfig.bedrockBreakList) {
+            Direction pistonFacing = level.getBlockState(pos).getValue(DirectionalBlock.FACING);
+            BlockPos bedrockPos = pos.relative(pistonFacing);
+            if (level.getBlockState(bedrockPos).getBlock() == Blocks.BEDROCK) {
+                pistonCache.computeIfAbsent(level, k -> new HashMap<>()).put(bedrockPos, player);
+            }
+        }
+    }
+
+    public static void onPistonBreakBedrock(Level level, BlockPos bedrock) {
+        if (LeavesConfig.bedrockBreakList) {
+            Map<BlockPos, Player> map = pistonCache.get(level);
+
+            boolean flag = map != null && map.get(bedrock) != null;
+
+            if (flag) {
+                if (!BBL.isEmpty()) {
+                    String player = map.get(bedrock).getScoreboardName();
+                    for (Objective objective : BBL) {
+                        level.getScoreboard().getOrCreatePlayerScore(player, objective).increment();
+                    }
+                }
+            } else {
+                if (!MBB.isEmpty()) {
+                    String world = "$" + level.dimension().location();
+                    for (Objective objective : MBB) {
+                        level.getScoreboard().getOrCreatePlayerScore(world, objective).increment();
+                        level.getScoreboard().getOrCreatePlayerScore("$total", objective).increment();
+                    }
+                }
+            }
+
+            if (!LBL.isEmpty() && !level.players().isEmpty()) {
+                Player closestPlayer = level.getNearestPlayer(bedrock.getX(), bedrock.getY(), bedrock.getZ(), 10.5, null);
+                if (closestPlayer != null) {
+                    String player = closestPlayer.getScoreboardName();
+                    for (Objective objective : LBL) {
+                        level.getScoreboard().getOrCreatePlayerScore(player, objective).increment();
+                    }
+                }
+            }
+        }
+    }
+
+    public static void onScoreboardAdd(@NotNull Objective objective) {
+        if (LeavesConfig.bedrockBreakList) {
+            if (objective.getCriteria() == ObjectiveCriteria.DUMMY) {
+                String name = objective.getName();
+
+                int i = name.length() - 4;
+                if (i >= 0) {
+                    String suffix = name.substring(i);
+                    switch (suffix) {
+                        case ".bbl" -> BBL.add(objective);
+                        case ".mbb" -> MBB.add(objective);
+                        case ".lbl" -> LBL.add(objective);
+                    }
+                }
+            }
+        }
+    }
+
+    public static void onScoreboardRemove(@NotNull Objective objective) {
+        if (LeavesConfig.bedrockBreakList) {
+            if (objective.getCriteria() == ObjectiveCriteria.DUMMY) {
+                String name = objective.getName();
+
+                int i = name.length() - 4;
+                if (i >= 0) {
+                    String suffix = name.substring(i);
+                    switch (suffix) {
+                        case ".bbl" -> BBL.remove(objective);
+                        case ".mbb" -> MBB.remove(objective);
+                        case ".lbl" -> LBL.remove(objective);
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/ElytraAeronauticsHelper.java b/src/main/java/top/leavesmc/leaves/util/ElytraAeronauticsHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..fc25e2f960a2936e656541c0fe13745e62451179
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/ElytraAeronauticsHelper.java
@@ -0,0 +1,39 @@
+package top.leavesmc.leaves.util;
+
+import net.minecraft.core.SectionPos;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.phys.Vec3;
+import top.leavesmc.leaves.LeavesConfig;
+
+public class ElytraAeronauticsHelper {
+
+    public static void flightBehaviour(Player player, Vec3 velocity) {
+        if (LeavesConfig.elytraAeronauticsNoChunk) {
+            if ((LeavesConfig.elytraAeronauticsNoChunkSpeed <= 0.0D || velocity.horizontalDistanceSqr() >= LeavesConfig.elytraAeronauticsNoChunkSpeed)
+                && (LeavesConfig.elytraAeronauticsNoChunkHeight <= 0.0D || player.getY() >= LeavesConfig.elytraAeronauticsNoChunkHeight)) {
+                if (!player.elytraAeronauticsNoChunk) {
+                    player.elytraAeronauticsNoChunk = true;
+                    ServerPlayer serverPlayer = (ServerPlayer) player;
+                    if (LeavesConfig.elytraAeronauticsNoChunkMes) {
+                        serverPlayer.sendSystemMessage(Component.literal(LeavesConfig.elytraAeronauticsNoChunkStartMes), true);
+                    }
+                    ((ServerLevel) serverPlayer.level()).chunkSource.chunkMap.removePlayerFromDistanceMaps(serverPlayer);
+                    ((ServerLevel) serverPlayer.level()).chunkSource.chunkMap.getDistanceManager().removePlayer(serverPlayer.getLastSectionPos(), serverPlayer);
+                }
+            } else {
+                if (player.elytraAeronauticsNoChunk) {
+                    player.elytraAeronauticsNoChunk = false;
+                    ServerPlayer serverPlayer = (ServerPlayer) player;
+                    if (LeavesConfig.elytraAeronauticsNoChunkMes) {
+                        serverPlayer.sendSystemMessage(Component.literal(LeavesConfig.elytraAeronauticsNoChunkEndMes), true);
+                    }
+                    ((ServerLevel) serverPlayer.level()).chunkSource.chunkMap.addPlayerToDistanceMaps(serverPlayer);
+                    ((ServerLevel) serverPlayer.level()).chunkSource.chunkMap.getDistanceManager().addPlayer(SectionPos.of(serverPlayer), serverPlayer);
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/IterableWrapper.java b/src/main/java/top/leavesmc/leaves/util/IterableWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..0dc58b78c84a825ec7025534cd0fc7be9c4610ad
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/IterableWrapper.java
@@ -0,0 +1,21 @@
+package top.leavesmc.leaves.util;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Iterator;
+
+// Powered by Pufferfish(https://github.com/pufferfish-gg/Pufferfish)
+public class IterableWrapper<T> implements Iterable<T> {
+
+    private final Iterator<T> iterator;
+
+    public IterableWrapper(Iterator<T> iterator) {
+        this.iterator = iterator;
+    }
+
+    @NotNull
+    @Override
+    public Iterator<T> iterator() {
+        return iterator;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/LeavesUpdateHelper.java b/src/main/java/top/leavesmc/leaves/util/LeavesUpdateHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..83c9f6b60450d45d9dadfafc51739f3ecc568d08
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/LeavesUpdateHelper.java
@@ -0,0 +1,191 @@
+package top.leavesmc.leaves.util;
+
+import com.google.common.base.Charsets;
+import com.google.gson.Gson;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonSyntaxException;
+import net.minecraft.Util;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.LeavesLogger;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.nio.channels.Channels;
+import java.nio.channels.FileChannel;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.security.MessageDigest;
+import java.util.concurrent.locks.ReentrantLock;
+
+import static java.nio.file.StandardOpenOption.CREATE;
+import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;
+import static java.nio.file.StandardOpenOption.WRITE;
+
+public class LeavesUpdateHelper {
+
+    private final static String autoUpdateDir = "auto_update";
+    private final static String corePathFileName = autoUpdateDir + File.separator + "core.path";
+
+    private final static ReentrantLock updateLock = new ReentrantLock();
+    private static boolean updateTaskStarted = false;
+
+    public static void initAutoUpdate() {
+        File workingDirFile = new File(autoUpdateDir);
+        if (!workingDirFile.exists()) {
+            workingDirFile.mkdir();
+        }
+
+        File corePathFile = new File(corePathFileName);
+        if (!corePathFile.exists()) {
+            try {
+                corePathFile.createNewFile();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        File leavesUpdateDir = new File(autoUpdateDir + File.separator + "leaves");
+        if (!leavesUpdateDir.exists()) {
+            leavesUpdateDir.mkdir();
+        }
+    }
+
+    public static void tryUpdateLeaves() {
+        updateLock.lock();
+        try {
+            if (!updateTaskStarted) {
+                updateTaskStarted = true;
+                new Thread(new Runnable() {
+                    @Override
+                    public void run() {
+                        downloadLeaves();
+                    }
+                }).start();
+            }
+        } finally {
+            updateLock.unlock();
+        }
+    }
+
+    private static void downloadLeaves() {
+        String minecraftVersion = Bukkit.getMinecraftVersion();
+        LeavesLogger.LOGGER.info("Trying to get latest build info.");
+        LeavesBuildInfo buildInfo = getLatestBuildInfo(minecraftVersion);
+
+        if (buildInfo != LeavesBuildInfo.NULL) {
+            LeavesLogger.LOGGER.info("Got build info, trying to download " + buildInfo.fileName);
+            try {
+                URL url = new URL("https://api.leavesmc.top/projects/leaves/versions/1.20.1/builds/" + buildInfo.build + "/downloads/" + buildInfo.fileName);
+                Path outFile = Path.of(autoUpdateDir, "leaves", buildInfo.fileName + ".cache");
+
+                Files.deleteIfExists(outFile);
+
+                try (
+                    final ReadableByteChannel source = Channels.newChannel(url.openStream());
+                    final FileChannel fileChannel = FileChannel.open(outFile, CREATE, WRITE, TRUNCATE_EXISTING)
+                ) {
+                    fileChannel.transferFrom(source, 0, Long.MAX_VALUE);
+                } catch (final IOException e) {
+                    LeavesLogger.LOGGER.warning("Download " + buildInfo.fileName + " failed.");
+                    Files.deleteIfExists(outFile);
+                    e.printStackTrace();
+                    updateTaskStarted = false;
+                    return;
+                }
+
+                LeavesLogger.LOGGER.info("Download " + buildInfo.fileName + " completed.");
+                if (isFileValid(outFile, buildInfo.sha256)) {
+                    LeavesLogger.LOGGER.warning("Hash check failed for downloaded file " + buildInfo.fileName);
+                    Files.deleteIfExists(outFile);
+                    updateTaskStarted = false;
+                    return;
+                }
+
+                File nowServerCore = new File(autoUpdateDir + File.separator + "leaves" + File.separator + buildInfo.fileName);
+                File backupServerCore = new File(autoUpdateDir + File.separator + "leaves" + File.separator + buildInfo.fileName + ".old");
+                Util.safeReplaceFile(nowServerCore, outFile.toFile(), backupServerCore);
+
+                try (BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(corePathFileName))) {
+                    bufferedWriter.write(autoUpdateDir + File.separator + "leaves" + File.separator + "leaves-1.20.1.jar");
+                } catch (IOException e) {
+                    e.printStackTrace();
+                    updateTaskStarted = false;
+                    return;
+                }
+
+                LeavesLogger.LOGGER.info("Leaves update completed, please restart your server.");
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        } else {
+            LeavesLogger.LOGGER.warning("Can't get build info, stop update.");
+        }
+        updateTaskStarted = false;
+    }
+
+    private static boolean isFileValid(Path file, String hash) {
+        try (FileInputStream inputStream = new FileInputStream(file.toFile())) {
+            byte[] buffer = new byte[1024];
+            MessageDigest md5 = MessageDigest.getInstance("SHA-256");
+
+            for (int numRead; (numRead = inputStream.read(buffer)) > 0; ) {
+                md5.update(buffer, 0, numRead);
+            }
+
+            return toHexString(md5.digest()).equals(hash);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return false;
+    }
+
+    @NotNull
+    private static String toHexString(byte @NotNull [] bytes) {
+        StringBuilder builder = new StringBuilder();
+        for (byte b : bytes) {
+            builder.append(Integer.toHexString(b & 0xFF));
+        }
+        return builder.toString();
+    }
+
+    private static LeavesBuildInfo getLatestBuildInfo(String version) {
+        try {
+            HttpURLConnection connection = (HttpURLConnection) new URL("https://api.leavesmc.top/projects/leaves/versions/" + version + "/builds/latest").openConnection();
+            connection.connect();
+            if (connection.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) return LeavesBuildInfo.NULL;
+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), Charsets.UTF_8))) {
+                JsonObject obj = new Gson().fromJson(reader, JsonObject.class);
+                String channel = obj.get("channel").getAsString();
+
+                if (channel.equals("default")) {
+                    int build = obj.get("build").getAsInt();
+                    JsonObject downloadInfo = obj.get("downloads").getAsJsonObject().get("application").getAsJsonObject();
+                    String name = downloadInfo.get("name").getAsString();
+                    String sha256 = downloadInfo.get("sha256").getAsString();
+                    return new LeavesBuildInfo(build, name, sha256);
+                } else {
+                    return LeavesBuildInfo.NULL;
+                }
+            } catch (JsonSyntaxException | NumberFormatException e) {
+                e.printStackTrace();
+                return LeavesBuildInfo.NULL;
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            return LeavesBuildInfo.NULL;
+        }
+    }
+
+    private record LeavesBuildInfo(int build, String fileName, String sha256) {
+        public static LeavesBuildInfo NULL = new LeavesBuildInfo(-1, null, null);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/Long2ObjectOpenHashMapWrapper.java b/src/main/java/top/leavesmc/leaves/util/Long2ObjectOpenHashMapWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..b684d8f576acbc5de8d06b0ff779c257198bc32d
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/Long2ObjectOpenHashMapWrapper.java
@@ -0,0 +1,41 @@
+package top.leavesmc.leaves.util;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Map;
+
+public class Long2ObjectOpenHashMapWrapper<V> extends Long2ObjectOpenHashMap<V> {
+
+    private final Map<Long, V> backingMap;
+
+    public Long2ObjectOpenHashMapWrapper(Map<Long, V> map) {
+        backingMap = map;
+    }
+
+    @Override
+    public V put(Long key, V value) {
+        return backingMap.put(key, value);
+    }
+
+    @Override
+    public V get(Object key) {
+        return backingMap.get(key);
+    }
+
+    @Override
+    public V remove(Object key) {
+        return backingMap.remove(key);
+    }
+
+    @Nullable
+    @Override
+    public V putIfAbsent(Long key, V value) {
+        return backingMap.putIfAbsent(key, value);
+    }
+
+    @Override
+    public int size() {
+        return backingMap.size();
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/MathUtils.java b/src/main/java/top/leavesmc/leaves/util/MathUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..349cd0c0d2d9dc2c9c745ef3469e548a798931ba
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/MathUtils.java
@@ -0,0 +1,78 @@
+package top.leavesmc.leaves.util;
+
+import org.bukkit.util.NumberConversions;
+import org.bukkit.util.Vector;
+
+import java.util.regex.Pattern;
+
+public class MathUtils {
+    // Lag ?
+    public static void clean(Vector vector) {
+        if (!NumberConversions.isFinite(vector.getX())) vector.setX(0);
+        if (!NumberConversions.isFinite(vector.getY())) vector.setY(0);
+        if (!NumberConversions.isFinite(vector.getZ())) vector.setZ(0);
+    }
+
+    private static final Pattern numericPattern = Pattern.compile("^-?[1-9]\\d*$|^0$");
+    public static boolean isNumeric(String str){
+        return numericPattern.matcher(str).matches();
+    }
+
+    public static float[] fetchYawPitch(Vector dir) {
+        double x = dir.getX();
+        double z = dir.getZ();
+
+        float[] out = new float[2];
+
+        if (x == 0.0D && z == 0.0D) {
+            out[1] = (float) (dir.getY() > 0.0D ? -90 : 90);
+        }
+
+        else {
+            double theta = Math.atan2(-x, z);
+            out[0] = (float) Math.toDegrees((theta + 6.283185307179586D) % 6.283185307179586D);
+
+            double x2 = NumberConversions.square(x);
+            double z2 = NumberConversions.square(z);
+            double xz = Math.sqrt(x2 + z2);
+            out[1] = (float) Math.toDegrees(Math.atan(-dir.getY() / xz));
+        }
+
+        return out;
+    }
+
+    public static float fetchPitch(Vector dir) {
+        double x = dir.getX();
+        double z = dir.getZ();
+
+        float result;
+
+        if (x == 0.0D && z == 0.0D) {
+            result = (float) (dir.getY() > 0.0D ? -90 : 90);
+        }
+
+        else {
+            double x2 = NumberConversions.square(x);
+            double z2 = NumberConversions.square(z);
+            double xz = Math.sqrt(x2 + z2);
+            result = (float) Math.toDegrees(Math.atan(-dir.getY() / xz));
+        }
+
+        return result;
+    }
+
+    public static Vector getDirection(double rotX, double rotY) {
+        Vector vector = new Vector();
+
+        rotX = Math.toRadians(rotX);
+        rotY = Math.toRadians(rotY);
+
+        double xz = Math.abs(Math.cos(rotY));
+
+        vector.setX(-Math.sin(rotX) * xz);
+        vector.setZ(Math.cos(rotX) * xz);
+        vector.setY(-Math.sin(rotY));
+
+        return vector;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/ProtocolUtils.java b/src/main/java/top/leavesmc/leaves/util/ProtocolUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..a29da205e542edb0400b8c5db76dc97cff015b8c
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/ProtocolUtils.java
@@ -0,0 +1,19 @@
+package top.leavesmc.leaves.util;
+
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.game.ClientboundCustomPayloadPacket;
+import net.minecraft.network.protocol.game.ServerboundCustomPayloadPacket;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+
+public class ProtocolUtils {
+
+    public static void sendPayloadPacket(@NotNull ServerPlayer player, ResourceLocation channel, FriendlyByteBuf data) {
+        player.connection.send(new ClientboundCustomPayloadPacket(channel, data));
+    }
+
+    public static boolean isNamespacePacket(@NotNull ServerboundCustomPayloadPacket packet, String namespace) {
+        return packet.identifier.getNamespace().equals(namespace);
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/ReturnPortalManager.java b/src/main/java/top/leavesmc/leaves/util/ReturnPortalManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..24f887cbe608eea3beb7dc69cabdca7f32a66a9d
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/ReturnPortalManager.java
@@ -0,0 +1,105 @@
+package top.leavesmc.leaves.util;
+
+import net.minecraft.BlockUtil;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.portal.PortalForcer;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.UUID;
+
+// Powered by NetherPortalFix(https://github.com/TwelveIterationMods/NetherPortalFix)
+public class ReturnPortalManager {
+
+    private static final int MAX_PORTAL_DISTANCE_SQ = 16;
+    private static final String RETURN_PORTAL_LIST = "ReturnPortalList";
+    private static final String RETURN_PORTAL_UID = "UID";
+    private static final String FROM_DIM = "FromDim";
+    private static final String FROM_POS = "FromPos";
+    private static final String TO_MIN_CORNER = "ToMinCorner";
+    private static final String TO_AXIS_1_SIZE = "ToAxis1Size";
+    private static final String TO_AXIS_2_SIZE = "ToAxis2Size";
+
+    public static BlockUtil.FoundRectangle findPortalAt(Player player, ResourceKey<Level> dim, BlockPos pos) {
+        MinecraftServer server = player.level().getServer();
+        if (server != null) {
+            ServerLevel fromWorld = server.getLevel(dim);
+            if (fromWorld != null) {
+                PortalForcer portalForcer = fromWorld.getPortalForcer();
+                return portalForcer.findPortalAround(pos, false, fromWorld.getWorldBorder()).orElse(null);
+            }
+        }
+
+        return null;
+    }
+
+    public static ListTag getPlayerPortalList(Player player) {
+        CompoundTag data = player.getLeavesData();
+        ListTag list = data.getList(RETURN_PORTAL_LIST, Tag.TAG_COMPOUND);
+        data.put(RETURN_PORTAL_LIST, list);
+        return list;
+    }
+
+    @Nullable
+    public static ReturnPortal findReturnPortal(ServerPlayer player, ResourceKey<Level> fromDim, BlockPos fromPos) {
+        ListTag portalList = getPlayerPortalList(player);
+        for (Tag entry : portalList) {
+            CompoundTag portal = (CompoundTag) entry;
+            ResourceKey<Level> entryFromDim = ResourceKey.create(Registries.DIMENSION, new ResourceLocation(portal.getString(FROM_DIM)));
+            if (entryFromDim == fromDim) {
+                BlockPos portalTrigger = BlockPos.of(portal.getLong(FROM_POS));
+                if (portalTrigger.distSqr(fromPos) <= MAX_PORTAL_DISTANCE_SQ) {
+                    UUID uid = portal.hasUUID(RETURN_PORTAL_UID) ? portal.getUUID(RETURN_PORTAL_UID) : UUID.randomUUID();
+                    BlockPos minCorner = BlockPos.of(portal.getLong(TO_MIN_CORNER));
+                    int axis1Size = portal.getInt(TO_AXIS_1_SIZE);
+                    int axis2Size = portal.getInt(TO_AXIS_2_SIZE);
+                    return new ReturnPortal(uid, new BlockUtil.FoundRectangle(minCorner, axis1Size, axis2Size));
+                }
+            }
+        }
+
+        return null;
+    }
+
+    public static void storeReturnPortal(ServerPlayer player, ResourceKey<Level> fromDim, BlockPos fromPos, BlockUtil.FoundRectangle toPortal) {
+        ListTag portalList = getPlayerPortalList(player);
+        ReturnPortal returnPortal = findReturnPortal(player, fromDim, fromPos);
+        if (returnPortal != null) {
+            removeReturnPortal(player, returnPortal);
+        }
+
+        CompoundTag portalCompound = new CompoundTag();
+        portalCompound.putUUID(RETURN_PORTAL_UID, UUID.randomUUID());
+        portalCompound.putString(FROM_DIM, String.valueOf(fromDim.location()));
+        portalCompound.putLong(FROM_POS, fromPos.asLong());
+        portalCompound.putLong(TO_MIN_CORNER, toPortal.minCorner.asLong());
+        portalCompound.putInt(TO_AXIS_1_SIZE, toPortal.axis1Size);
+        portalCompound.putInt(TO_AXIS_2_SIZE, toPortal.axis2Size);
+        portalList.add(portalCompound);
+    }
+
+    public static void removeReturnPortal(ServerPlayer player, ReturnPortal portal) {
+        // This doesn't check if it's the right toDim, but it's probably so rare for positions to actually overlap that I don't care
+        ListTag portalList = getPlayerPortalList(player);
+        for (int i = 0; i < portalList.size(); i++) {
+            CompoundTag entry = (CompoundTag) portalList.get(i);
+            if (entry.hasUUID(RETURN_PORTAL_UID) && entry.getUUID(RETURN_PORTAL_UID).equals(portal.uid())) {
+                portalList.remove(i);
+                break;
+            }
+        }
+    }
+
+    public record ReturnPortal(UUID uid, BlockUtil.FoundRectangle rectangle) {
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/ShulkerBoxUtils.java b/src/main/java/top/leavesmc/leaves/util/ShulkerBoxUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..82b4337965663ec8eccbc8c77892e3c49bff87cf
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/ShulkerBoxUtils.java
@@ -0,0 +1,71 @@
+package top.leavesmc.leaves.util;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.inventory.Slot;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.ShulkerBoxBlock;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.LeavesConfig;
+
+// Powered by fabric-carpet/src/main/java/carpet/helpers/InventoryHelper.java
+public class ShulkerBoxUtils {
+    // From nbt/NbtElement.java createTag()
+    public static final int TAG_END = 0;
+    public static final int TAG_BYTE = 1;
+    public static final int TAG_SHORT = 2;
+    public static final int TAG_INT = 3;
+    public static final int TAG_LONG = 4;
+    public static final int TAG_FLOAT = 5;
+    public static final int TAG_DOUBLE = 6;
+    public static final int TAG_BYTEARRAY = 7;
+    public static final int TAG_STRING = 8;
+    public static final int TAG_LIST = 9;
+    public static final int TAG_COMPOUND = 10;
+    public static final int TAG_INTARRAY = 11;
+    public static final int TAG_LONGARRAY = 12;
+
+    public static boolean cleanUpShulkerBoxTag(@NotNull ItemStack stack) {
+        boolean changed = false;
+        CompoundTag tag = stack.getTag();
+
+        if (tag == null || !tag.contains("BlockEntityTag", TAG_COMPOUND)) return false;
+
+        CompoundTag bet = tag.getCompound("BlockEntityTag");
+        if (bet.contains("Items", TAG_LIST) && bet.getList("Items", TAG_COMPOUND).isEmpty()) {
+            bet.remove("Items");
+            changed = true;
+        }
+
+        if (bet.isEmpty() || (bet.size() == 1 && bet.getString("id").equals("minecraft:shulker_box"))) {
+            tag.remove("BlockEntityTag");
+            changed = true;
+        }
+        if (tag.isEmpty()) {
+            stack.setTag(null);
+            changed = true;
+        }
+        return changed;
+    }
+
+    public static boolean shulkerBoxHasItems(@NotNull ItemStack stack) {
+        CompoundTag tag = stack.getTag();
+
+        if (tag == null || !tag.contains("BlockEntityTag", TAG_COMPOUND)) return false;
+
+        CompoundTag bet = tag.getCompound("BlockEntityTag");
+        return bet.contains("Items", TAG_LIST) && !bet.getList("Items", TAG_COMPOUND).isEmpty();
+    }
+
+    public static int getItemStackMaxCount(ItemStack stack) {
+        if (LeavesConfig.shulkerBoxStackSize > 1 && stack.getItem() instanceof BlockItem bi &&
+            bi.getBlock() instanceof ShulkerBoxBlock && !top.leavesmc.leaves.util.ShulkerBoxUtils.shulkerBoxHasItems(stack)) {
+            return top.leavesmc.leaves.LeavesConfig.shulkerBoxStackSize;
+        }
+        return stack.getMaxStackSize();
+    }
+
+    public static boolean isStackable(ItemStack itemStack) {
+        return getItemStackMaxCount(itemStack) > 1 && (!itemStack.isDamageableItem() || !itemStack.isDamaged());
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/util/UpdateSuppressionException.java b/src/main/java/top/leavesmc/leaves/util/UpdateSuppressionException.java
new file mode 100644
index 0000000000000000000000000000000000000000..f9a9f3e28bebdaa5038ebf81ac53447182c2bc10
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/util/UpdateSuppressionException.java
@@ -0,0 +1,33 @@
+package top.leavesmc.leaves.util;
+
+import net.minecraft.core.BlockPos;
+
+public class UpdateSuppressionException extends RuntimeException {
+
+    private final BlockPos pos;
+    private final BlockPos source;
+
+    public UpdateSuppressionException(BlockPos pos, BlockPos source) {
+        super("Update suppression");
+        this.pos = pos;
+        this.source = source;
+    }
+
+    public BlockPos getPos() {
+        return pos;
+    }
+
+    public BlockPos getSource() {
+        return source;
+    }
+
+    public String getMessage() {
+        if (pos != null) {
+            return "An update suppression processed, form [x:%d,y:%d,z:%d] to [x:%d,y:%d,z:%d]"
+                .formatted(source.getX(), source.getY(), source.getZ(), pos.getX(), pos.getY(), pos.getZ());
+        } else {
+            return "An update suppression processed, form [x:%d,y:%d,z:%d]"
+                .formatted(source.getX(), source.getY(), source.getZ());
+        }
+    }
+}
diff --git a/src/main/resources/logo.png b/src/main/resources/logo.png
index 8b924977b7886df9ab8790b1e4ff9b1c04a2af45..e6a7ee1232cb34840f454187f50f44d17300ad9c 100644
GIT binary patch
literal 51130
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
Bd`<uW

literal 16900
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
LFIp>X81%mY^Bg|U

